{
    "metadata": {
        "overview": "This lecture, part of the SYSC4101/SYSC5105 course, introduces fundamental concepts in software testing, focusing on defining and understanding the difference between a fault, an error, and a failure. The lecture also emphasizes the importance of observability and controllability in testing, explaining how they relate to reaching faults, infecting states, and propagating errors.",
        "topics": [
            "Definitions of fault, error, and failure",
            "Reachability, infection, and propagation",
            "Observability and controllability",
            "Relationship of observability and controllability to fault, error, and failure",
            "Test scaffolding and test harness",
            "Components of test scaffolding: driver, stub, oracle",
            "Example illustrating test scaffolding with a stub"
        ],
        "format": "Lecture",
        "date": "2024-09-10",
        "course": "SYSC 4101",
        "title": "Definitions 1",
        "path": "input/SYSC4101-5105_Definitions_PI.pdf"
    },
    "notes": "# SYSC4101 / SYSC5105: Definitions - Part I\n\n## What are we looking for?\n\n* **Fault:** A defect in a system.  Humans commit faults.\n    * Example: A faulty statement in code.\n* **Error:**  An unexpected state reached at runtime due to a fault.\n    * Example: An erroneous state in a variable.\n* **Failure:** The delivered service deviates from its intended behavior. \n\n**Important**: The term \"bug\" is not used in SYSC4101. \n\n**Relationship:** Fault → Error → Failure\n\n**Three conditions for a failure to be observed:**\n\n* **Reachability:** The location(s) in the program containing the fault must be reached.\n* **Infection:** The state of the program must be incorrect.\n* **Propagation:** The infected state must propagate to cause an incorrect output.\n\n**All three conditions are necessary for a failure to occur.**\n\n* Reaching the fault alone is not sufficient. There may not be any infection, and the delivered service may not be affected. \n* Infecting the state alone is not sufficient. The delivered service may not be affected.\n\n## Observability vs. Controllability\n\n* **Software Observability:** How easy it is to observe a program's behavior in terms of its outputs and effects on the environment and other hardware/software components.\n    * Observability is **low** for software affecting hardware devices, databases, or remote files.\n    * **Observability relates to Propagation.**\n\n* **Software Controllability:** How easy it is to provide a program with the needed inputs, operations, and behaviors.\n    * Controllability is **high** for software with inputs from keyboards. \n    * Controllability is **low** for software with inputs from hardware sensors or distributed software. \n    * **Data abstraction reduces both controllability and observability.** \n    * **Controllability relates to Reachability and Infection.**\n\n## Test Scaffolding / Test Harness\n\n* **Infrastructure (software and/or hardware) for executing test cases.**\n\n* **Key Components:**\n    * **Test Driver:** A software component or test tool that replaces a component and controls the calling of a software component. The test driver executes a test case (one execution of the system under test with input values) or a test suite/set (a set of test cases).\n    * **Test Stub (a.k.a. mock):** A skeletal or special-purpose implementation of a software module used to develop or test a component that calls the stub. The stub replaces a called component. \n        * Example: Simulates a piece of code that is not yet ready.\n    * **Test Oracle:** Assists in deciding whether a test outcome is successful or not. It evaluates the outcome (pass/fail) by comparing the actual output with the expected output.\n        * **Two important tasks of the test oracle:**\n            1. Comparing the actual output against the expected output. (Often done by software.)\n            2. Deciding what the expected output is, given the test inputs of a test case. (Often done by humans.)\n\n**Stubs and drivers enable components to be isolated from the rest of the system for testing purposes.**\n\n## Putting Things Together\n\n**Diagram:**\n\n[Diagram depicting a test harness, showing the relationship between the driver, stub(s), program under test, oracle, test inputs, and outputs.]\n\n## A Simple Example\n\n**Code:**\n\n```c\n#include “mySquareRoot.h”\n\nint root(double a, double b, double c, double *root1, double *root2) {\n    double determinant = b*b-4*a*c;\n    if (determinant > 0) {\n        *root1 = (-b+mySquareRoot(determinant))/(2*a);\n        *root2 = (-b-mySquareRoot(determinant))/(2*a);\n        return 1;\n    } else if (determinant == 0) {\n        *root1 = *root2 = -b/(2*a);\n        return 1;\n    } else {\n        return 0;\n    }\n}\n```\n\n**Scenario:**\n\n* You want to test the `root()` function. \n* The `mySquareRoot()` function is not yet available.\n\n**Solution:**\n\n* **Stub `mySquareRoot()`:**\n\n```c\n// file mySquareRoot-Stub.c\n#include \"mySquareRoot.h\"\n#include \"stubFormySquareRoot.h\"\nstatic double valueToReturn;\n\ndouble mySquareRoot(double n) {\n    return valueToReturn;\n}\n\nvoid setReturnValue(double r) {\n    valueToReturn = r;\n}\n```\n\n* **Test Driver:**\n\n```c\n#include \"root.h\"\n#include \"stubFormySquareRoot.h\"\n\nint main() {\n    double a, b, c, root1, root2;\n    int result;\n    double expectedRoot1, expectedRoot2;\n    double epsilon = 0.000001;\n\n    // test case 1\n    setReturnValue(5); //instructing the stub what to respond to root()\n    a = -2; b = 1; c = 3;\n    expectedRoot1 = -1; expectedRoot2 = 1.5;\n    result = root(a, b, c, &root1, &root2);\n    if ((result==1) && (fabs(expectedRoot1-root1)<epsilon) &&\n    (fabs(expectedRoot2-root2)<epsilon) ) printf(\"test case 1 passes.\\n\");\n    else printf(\"test case 1 fails.\\n\");\n}\n```\n\n**Compiling and executing the test:**\n\n```bash\ncc -c mySquareRoot-Stub.c\ncc -c root.c\ncc -c root-UnitTestWithStub.c\ncc mySquareRoot-Stub.o root.o root-UnitTestWithStub.o -o root-UnitTestWithStubs\n./root-UnitTestWithStubs\n```\n\n**Compiling and running the program with all components:**\n\n```bash\ncc -c mySquareRoot.c\ncc -c root.c\ncc -c quadratic.c\ncc mySquareRoot.o root.o quadratic.o -o quadratic\n./quadratic\n```\n\n## Automated Test Infrastructure\n\n* **Familiar tools:** JUnit, Google's C++ xUnit\n* **Less familiar tools:** TTCN-3 (organization-specific set up)\n\n**What changes in automated testing?**\n\n* **The syntax**\n\n**What does not change in automated testing?**\n\n* You still need to decide what inputs and outputs to choose for your tests. \n",
    "review": [
        {
            "answer": "A **fault** is a defect in a system, representing a mistake in the software's design or implementation. For example, a faulty statement in the code could lead to incorrect behavior.",
            "question": "What is a 'fault' in the context of software systems, and provide an example?"
        },
        {
            "answer": "An **error** occurs at runtime when the system enters an unexpected state due to the activation of a fault.  Imagine a program trying to divide by zero – this would be an error triggered by a fault in the code.",
            "question": "Describe what an 'error' is in software systems, and give an example."
        },
        {
            "answer": "A **failure** occurs when the system's delivered service deviates from its intended behavior. If a website crashes and users cannot access it, that's a failure resulting from underlying faults or errors.",
            "question": "Define 'failure' in the context of software systems and give a real-world scenario."
        },
        {
            "answer": "**Observability** measures how easy it is to understand the behavior of a program based on its outputs and effects on its environment. If a program interacts with hardware or remote files, its observability is likely lower.",
            "question": "What does 'observability' refer to in software systems? Provide an example where observability would be lower."
        },
        {
            "answer": "**Controllability** determines how easy it is to provide a program with the correct inputs to trigger desired behaviors.  Software controlled by keyboard inputs is highly controllable, but software with inputs from hardware sensors can be less so.",
            "question": "Explain 'controllability' in the context of software systems and provide an example where controllability might be challenging."
        },
        {
            "answer": "The three conditions are **reachability**, **infection**, and **propagation**. Reachability ensures the fault's location in the code is executed. Infection means the program's state becomes incorrect due to the fault. Propagation signifies the incorrect state affecting the system's outputs, making the failure observable.",
            "question": "Identify the three conditions necessary for a failure to be observed in a software system and briefly describe each."
        },
        {
            "answer": "A **test driver** is a component that orchestrates the execution of test cases by calling the software component being tested and providing it with input values. Think of it as the 'conductor' of a test scenario.",
            "question": "What is the role of a 'test driver' in software testing?"
        }
    ],
    "keywords": "# Glossary of Key Terms and Concepts\n\nThis glossary provides definitions for key terms and concepts presented in the lecture document. \n\n- **Controllability**:  The ease of providing a program with the needed inputs (values, operations, and behaviors) to reach a specific state. This relates to the **Reachability** and **Infection** aspects of fault detection.\n- **Error**: An unexpected state of the system that occurs at runtime due to the activation of a **Fault**.\n- **Fault**: A defect in a system that, when activated, can lead to an **Error**. Often referred to as a \"bug\" historically.\n- **Failure**: A deviation of the delivered service from the intended behavior of the system. Occurs when a **Fault** leads to an **Error** that propagates to an observable outcome.\n- **Infection**: The state of the program being incorrect due to the activation of a **Fault**. This is one of the conditions needed for a **Failure** to occur.\n- **Observability**:  The ease of observing a program's behavior in terms of its outputs, effects on the environment, and interactions with other software and hardware components. This relates to the **Propagation** aspect of fault detection.\n- **Oracle**: A component that assists in determining whether a test outcome is successful or not. It compares actual outputs with expected outputs and decides the verdict (pass/fail). \n- **Propagation**: The infected state caused by a **Fault** propagating to cause some output of the program to be observed as incorrect. This is one of the conditions needed for a **Failure** to occur.\n- **Reachability**:  The ability to reach the location(s) in the program where the **Fault** resides. This is one of the conditions needed for a **Failure** to occur.\n- **Stub**: A skeletal or special-purpose implementation of a software module used to develop or test a component that calls the stub. It replaces a called component and often simulates code that is not yet ready.\n- **Test Driver**: A software component or test tool that replaces a component that takes care of the control and/or calling of a software component. It executes a test case or test suite.\n- **Test Harness**: The infrastructure (software and/or hardware) used to execute test cases. It includes test drivers, stubs, and oracles.\n- **Test Scaffolding**:  A synonym for Test Harness.\n"
}