{
    "metadata": {
        "overview": "This lecture explores the concept of test criteria in software testing, focusing on the distinction between functional and structural testing.  It delves into the theoretical hierarchy of test criteria and examines different approaches to using them, particularly the recommendations of Brian Marick.",
        "topics": [
            "Exhaustive Testing",
            "Test Data Selection",
            "Functional vs. Structural Testing",
            "Test Model Criterion",
            "Theoretical Hierarchy of Criteria",
            "Two Ways to Use Test Criteria",
            "Miss-use of Terminology",
            "Using a Test Selection Criterion",
            "Test Criteria Based on Structure",
            "Test Criteria - Graphs",
            "Test Criteria - Logic Expressions",
            "Test Criteria - Input Domain Characterization",
            "Test Criteria - Syntactic Structures",
            "Marick's Recommendation"
        ],
        "format": "Lecture",
        "date": "2024-09-13",
        "course": "SYSC 4101",
        "title": "Definitions 2",
        "path": "input/SYSC4101-5105_Definitions_PII.pdf"
    },
    "notes": "# SYSC 4101 / SYSC 5105 - Definitions - Part II\n\n## Exhaustive Testing\n\n* **Definition**: Testing using all possible inputs.\n* **Challenges**: Most of the time, it is **impossible** to perform exhaustive testing.\n\n* **Examples**:\n    * **Factorial Function:** Testing a program that calculates the factorial function (n! = n * (n-1) * (n-2) * ... * 1) would require running it with all possible integer values (0, 1, 2, ..., 100, ...).\n    * **Compiler:** Exhaustive testing of a compiler like `javac` would involve compiling every possible Java program.\n\n* **Techniques to Reduce Input**:\n    * **Equivalence Classes**: Group similar inputs into equivalence classes. Select one input per class to ensure adequate test data coverage.\n    * **Criteria for Input Selection**: Determine which test inputs to use and when to stop testing based on specific criteria.\n\n## Test Data: Procedure to Select?\n\n* **Test Model**: A representation of the software, either the specification (for **functional testing**) or the implementation (for **structural testing**).\n\n* **Test Objectives (Requirements)**:  The goals that the test cases must achieve.\n\n* **Test Data**: The specific inputs that exercise the test model to achieve the objectives.\n\n* **Older Terminology**:\n    * **Black-Box Testing**: Focuses on the functionality of the software, without considering internal implementation details.\n    * **White-Box Testing**:  Considers the internal structure and implementation details of the software.\n\n## Functional vs. Structural Testing\n\n**Functional Testing**\n* **Goal**: Check conformance with the specification.\n* **Advantages**:\n    * **Scalability**: Works across different levels of granularity (functions, classes, packages, systems).\n    * **Clear Objective**: Focused on validating the intended behavior of the software.\n* **Disadvantages**:\n    * **Dependency on Specification**: Requires a detailed and accurate specification.\n    * **Limited Scope**: Does not reveal potential issues that are not explicitly covered by the specification.\n\n**Structural Testing**\n* **Goal**: Based on control and data flow criteria.\n* **Advantages**:\n    * **Confidence in Coverage**: Provides assurance that a significant portion of the code has been executed.\n* **Disadvantages**:\n    * **Limited Scalability**: Mostly applicable at unit and integration testing levels.\n    * **Missing Functionality**: Cannot reveal functionality that is missing from the specification.\n\n**Key Points:**\n\n* Functional testing focuses on what the system *should* do, while structural testing focuses on how the system *does* it.\n* Both functional and structural testing are valuable, but they have different strengths and weaknesses.\n* A combination of both approaches is often the most effective testing strategy.\n\n## Test Model Criterion\n\n* **Criterion (C)**: A specific rule or standard that defines the desired coverage for a test model (M).\n* **Coverage Ratio**: The proportion of elements in M that are covered by a test set (T).\n* **C-Adequate Test Set**: A test set that achieves 100% coverage for the given criterion.\n\n* **Example 1**:\n    * **M**: Control flow graph of a function.\n    * **C**: \"All statements\".\n    * **T**: Exercises 5 out of 8 statements.\n    * **Result**: Coverage ratio is 62.5%. The test suite is **not adequate** for the all-statements criterion.\n\n* **Example 2**:\n    * **M**: Set of use case scenarios.\n    * **C**: \"All scenarios\".\n    * **T**: Exercises all 12 scenarios.\n    * **Result**: Coverage ratio is 100%. The test suite is **adequate** for the all-scenarios criterion.\n\n**Important Point**:  A test criterion specifies a set of test requirements or objectives that need to be fulfilled for the test suite to be considered adequate.\n\n## Theoretical Hierarchy of Criteria\n\n* **Subsumption Relation**: C1 **subsumes** C2 if any C1-adequate test set is also C2-adequate. This means that satisfying C1 ensures that C2 is also satisfied.\n\n* **Example**:\n    * **M**: Finite state machine.\n    * **C1**: All-paths criterion.\n    * **C2**: All-transitions criterion.\n    * **Result**: C1 subsumes C2, because any test suite that covers all paths necessarily covers all transitions.\n\n* **General Rule**:\n    * **Cost**: Satisfying a more subsuming criterion (like C1) tends to be more expensive than satisfying a less subsuming criterion (like C2).\n    * **Fault Detection**: A test suite that is adequate for a more subsuming criterion tends to detect more faults than a test suite that is adequate for a less subsuming criterion.\n\n## Two Ways to Use Test Criteria\n\n* **Generate Test Values/Cases**:\n    * **Criterion**: **Selection criterion**.\n    * **Tool**: **Generator** (automatically produces test values to satisfy the criterion).\n    * **Example**: A generator for the \"all-transitions\" criterion for a finite state machine might generate test cases that cover every possible transition.\n\n* **Evaluate Coverage**:\n    * **Criterion**: **Coverage criterion**.\n    * **Tool**: **Recognizer** (determines whether a set of test values satisfies the criterion).\n    * **Example**: A recognizer for the \"all-statements\" criterion for a function might analyze a test suite to see if it executes every statement in the function.\n\n**Challenges**:\n* **Undecidability**:  Creating perfect generators and recognizers for most test criteria is **provably undecidable**. This means that no single algorithm can always guarantee a correct solution.\n\n**Practical Approach**: It is often easier to create a recognizer than a generator. Coverage analysis tools, which are recognizers, are widely available.\n\n## Miss-Use of Terminology\n\n* **Beware**:  The term \"coverage\" is often misused, leading to confusion.\n* **Common Errors**:\n    * Using the term \"coverage\" when referring to a selection criterion (generator).\n    * Using the term \"structural testing\" when referring to coverage analysis of the implementation (recognizer).\n* **Key Point**:  Different criteria can have significantly different costs, so understanding the specific criterion being used is essential.\n\n## Using a Test Selection Criterion\n\n**Steps**:\n\n1. **Choose a test model**:  Define the representation of the software under test.\n2. **Select a test criterion**:  Choose a criterion that specifies the desired coverage.\n3. **Identify test objectives**:  Define the goals that the test cases must achieve.\n4. **Create test case specifications**: Describe the steps that each test case will perform.\n5. **Identify test data/input**:  Determine the specific input values that will be used for each test case.\n6. **Identify Oracle**:  Define the expected outcomes for each test case.\n\n**Example**:\n1. **Test Model**: State machine.\n2. **Test Criterion**: All-transitions.\n3. **Test Objectives**: Ensure that every transition in the state machine is exercised.\n4. **Test Case Specifications**: Create test cases that cover all transitions.\n5. **Test Data/Input**: Identify input values that trigger each transition.\n6. **Oracle**: Define the expected state changes for each transition.\n\n## Example (Graph) Model\n\n* **Test Model**: A vending machine that accepts 5p or 10p coins and dispenses 15p cans.\n* **Test Criterion**: All-transitions.\n* **Test Cases**:\n    * **TC1**: Got0 -> Got5 -> Got10. Input: 5p, 5p.\n    * **TC2**: Got0 -> Got10 -> Got0. Input: 10p, 5p.\n    * **TC3**: Got0 -> Got10 -> Got5 -> Got0. Input: 10p, 10p, 10p.\n* **Oracles**:\n    * **TC1**: Machine has 10p in, no can.\n    * **TC2**: Machine has 0p in, one can.\n    * **TC3**: Machine has 0p in, two cans.\n\n## Marick's Recommendation\n\n* **Brian Marick's Approach**: A three-step process for testing:\n    1. **Functional Testing**: Generate functional tests from requirements and design.\n    * **Criterion**: Functional selection criterion (generator).\n    2. **Structural Coverage Check**: Verify that the structural coverage is adequate after the functional tests are successful.\n    * **Criterion**: Structural coverage criterion (recognizer).\n    3. **Additional Functional Testing**: Generate functional tests (not structural) to achieve missing structural coverage.\n\n* **Rationale**: \"Form (structure) should follow function.\" Uncovered code must have a purpose, and if it is not being executed, then the corresponding function is untested.\n\n## Test Criteria Based on Structure [Offutt]\n\n* **Graphs**:  Representations of program structure, such as control flow graphs, call graphs, and state machines.\n\n* **Logical Expressions**:  Representations of logical conditions in code, such as `(not X or not Y) and A and B`.\n\n* **Input Domain Characterization**:  Describe the range of inputs that the software is expected to handle.\n\n* **Syntactic Structures**:  Based on the grammar or other syntactic definition of the programming language, such as mutation testing.\n\n## Test Criteria - Graphs\n\n* **Example**: Control flow graph of a program.\n* **Criterion**: \"All transitions\" ensures that every possible transition in the graph is executed at least once.\n\n## Test Criteria - Logic Expressions\n\n* **Example**: Logical expressions in a program that determine the flow of execution.\n* **Criterion**:  Coverage of all possible combinations of truth values for the variables in the expression.\n\n## Test Criteria - Input Domain Characterization\n\n* **Example**:  A function that processes file names.\n* **Criterion**:  Test cases with different types of file names, including valid, invalid, and boundary cases.\n\n## Test Criteria - Syntactic Structures\n\n* **Example**:  Mutation testing, which involves introducing small changes to the code and testing whether the system can detect the change.\n* **Criterion**:  Coverage of all possible syntactic structures in the code.\n\n",
    "review": [
        {
            "answer": "Exhaustive testing is a type of testing that involves running the software with all possible inputs. This approach ensures that the software performs correctly under every conceivable condition.  However, it is often impossible to achieve exhaustive testing due to the vast number of potential inputs that may exist for a program, especially for systems with complex input spaces.",
            "question": "What is exhaustive testing, and why is it often impractical?"
        },
        {
            "answer": "In the context of software testing, 'coverage' refers to the extent to which a test suite exercises the elements of a software model.  A test suite that achieves 100% coverage for a given criterion means it has covered all elements of the model defined by that criterion.",
            "question": "Explain the concept of 'coverage' in software testing."
        },
        {
            "answer": "The two main approaches to selecting test data are Functional Testing and Structural Testing. Functional Testing focuses on validating the software's behavior against the specified requirements or the documented specification.  Structural Testing, on the other hand, examines the internal structure of the software, testing the control flow, code paths, and data structures within the program.",
            "question": "What are the two main approaches to selecting test data, and how do they differ?"
        },
        {
            "answer": "A test criterion, also known as a test selection criterion, defines a set of requirements or objectives that a test suite should meet. These criteria guide the development of test cases, ensuring that the software is tested according to specific guidelines.",
            "question": "What is a test criterion, and what is its purpose?"
        },
        {
            "answer": "The subsumption relation states that a test criterion C1 subsumes another criterion C2 if any test suite that is adequate for C1 is also adequate for C2. This means that satisfying C1 automatically satisfies C2.  An example of this is the relationship between all-transitions and all-paths criteria in state machines.  A test suite that exercises all paths will necessarily also exercise all transitions.",
            "question": "Describe the subsumption relation between test criteria, and provide an example."
        },
        {
            "answer": "Test criteria can be used in two primary ways: as selection criteria and as coverage criteria.  Selection criteria are used to generate test cases that satisfy a specific set of requirements.  Coverage criteria are used to evaluate the coverage of a test suite, determining whether it exercises all elements defined by the criterion.",
            "question": "How are test criteria used in the context of software testing?"
        },
        {
            "answer": "The process of applying test criteria to a software model involves a series of steps.  Firstly, select a test model, which represents the software's behavior or structure.  Next, choose a test criterion, defining the requirements or objectives for testing.  Then, identify test objectives based on the chosen criterion.  Create test case specifications to outline the inputs and expected outcomes for each test case.  Finally, identify the test data and an oracle, which will be used to verify the correctness of the test results.",
            "question": "Outline the general steps involved in using a test selection criterion."
        }
    ],
    "keywords": "# Glossary of Key Terms and Concepts\n\nHere's a glossary of key terms and concepts from the lecture document:\n\n- **Adequate**\n    - A test set is considered adequate for a criterion if it achieves 100% coverage for that criterion.\n    - For example, a test set that exercises all statements in a control flow graph is adequate for the \"all-statements\" criterion.\n- **All-paths**\n    - A test criterion that requires all possible paths through a finite state machine to be exercised.\n    - This is a very strong criterion, and it can be difficult to achieve in practice.\n- **All-transitions**\n    - A test criterion that requires all transitions in a finite state machine to be exercised.\n    - This criterion is less strong than the all-paths criterion, but it is still useful for testing.\n- **Coverage Ratio**\n    - The proportion of elements in a model defined by a criterion that are covered by a test set.\n    - It is typically expressed as a percentage.\n- **Exhaustive Testing**\n    - A testing technique that involves testing with all possible inputs.\n    - This is often impossible in practice, especially for complex software systems.\n- **Functional Testing**\n    - A testing technique that focuses on checking whether the software meets its requirements.\n    - It is often referred to as \"black-box\" testing.\n- **Generator**\n    - A tool or process that automatically generates test values or test cases to satisfy a selection criterion.\n    - For example, a generator could be used to create test cases that exercise all branches in a control flow graph.\n- **Issue**\n    - A problem or challenge that arises when applying a criterion to a test model.\n    - For example, it may be impossible to achieve 100% coverage for a given criterion, or it may be too expensive to do so.\n- **Recognizer**\n    - A tool or process that automatically decides whether a set of test values or test cases satisfies a coverage criterion.\n    - For example, a recognizer could be used to determine whether a test set has achieved 100% statement coverage.\n- **Selection Criterion**\n    - A test criterion that is used to guide the selection of test values or test cases.\n    - Examples of selection criteria include all-statements, all-transitions, and all-paths.\n- **Structural Testing**\n    - A testing technique that focuses on checking the internal structure of the software.\n    - It is often referred to as \"white-box\" testing.\n- **Subsumes**\n    - A criterion C1 subsumes a criterion C2 if any test set that is adequate for C1 is also adequate for C2.\n    - For example, the all-paths criterion subsumes the all-transitions criterion.\n- **Test Model**\n    - A representation of the software being tested.\n    - The test model can be a graph, a state machine, or any other suitable representation.\n- **Test Objectives**\n    - The specific goals that the testing is intended to achieve.\n    - Test objectives should be derived from the requirements for the software."
}