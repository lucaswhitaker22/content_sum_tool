{
    "metadata": {
        "overview": "This lecture, part of the SYSC4101/SYSC5105 course, focuses on understanding and defining key concepts in software testing, particularly the distinction between 'faults,' 'errors,' and 'failures.' It emphasizes the importance of these concepts and how they relate to the key factors of 'observability' and 'controllability' in testing.",
        "topics": [
            "Defining Faults, Errors, and Failures",
            "Observability and Controllability in Software Testing",
            "Reachability, Infection, and Propagation",
            "The Importance of All Three Concepts",
            "Observability: How Easy to Observe Program Behavior",
            "Controllability: How Easy to Provide Needed Inputs",
            "Test Scaffolding and Test Harness",
            "Components of a Test Harness: Test Driver, Test Stub, Test Oracle",
            "Functions of a Test Driver",
            "Functions of a Test Stub",
            "Functions of a Test Oracle",
            "Illustrative Example: Testing a Function"
        ],
        "format": "Lecture",
        "date": "2024-09-10",
        "course": "SYSC 4101",
        "title": "Definitions 1",
        "path": "input/SYSC4101-5105_Definitions_PI.pdf"
    },
    "notes": "# SYSC4101 / SYSC5105: Definitions - Part I\n\n## What are we looking for?\n\n* **Fault:** A defect in a system, often referred to as a \"bug\" historically.\n    * Humans commit faults.\n    * Example: A faulty statement in code.\n* **Error:**  A state entered at runtime due to the activation of a fault. \n    * Example: An erroneous state in the program.\n* **Failure:**  When the delivered service deviates from its intended behavior.\n\n**Important:**  The word \"bug\" is not used in SYSC4101.\n\n## The Fault-Error-Failure Chain\n\n* **Fault → Error → Failure:**  These three concepts are essential to understand.\n* **Three conditions for a failure to be observed:**\n    * **Reachability:** The location(s) in the program containing the fault must be reached.\n    * **Infection:** The state of the program must be incorrect.\n    * **Propagation:** The incorrect state must propagate to cause some output of the program to be observed as incorrect. \n\n**Key point:**  All three conditions are necessary for a failure to occur. Reaching the fault or infecting the state alone is not sufficient.\n\n## Observability vs. Controllability\n\n* **Software Observability:** How easy it is to observe a program's behavior in terms of its outputs, effects on the environment, and interactions with other components.\n    * Observability is lower for software that affects hardware devices, databases, or remote files.\n    * **Observability relates to Propagation.**\n\n* **Software Controllability:** How easy it is to provide a program with the needed inputs to achieve specific values, operations, and behaviors.\n    * Controllability is higher for software with inputs from keyboards. \n    * Controllability is lower for software with inputs from hardware sensors or distributed systems.\n    * Data abstraction can reduce both controllability and observability.\n    * **Controllability relates to Reachability and Infection.**\n\n## Test Scaffolding / Test Harness\n\n* **Infrastructure (software and/or hardware) to execute test cases:**\n    * **Test Driver:** Replaces a component and takes care of controlling and calling software components.\n        * Executes a test case (one execution) or a test suite (set of test cases).\n    * **Test Stub (a.k.a., mock):** A skeletal or specialized implementation of a software module used to develop or test a component that depends on it.\n        * Replaces a called component.\n        * Example: Simulating a piece of code not yet ready.\n    * **Test Oracle:** Assists in deciding whether a test outcome is successful or not.\n        * Evaluates the outcome with a pass/fail verdict.\n        * Two important tasks:\n            1. **Compare actual output to expected output:** Done by software using assert() statements.\n            2. **Decide expected output based on test inputs:** Done by humans.\n\n## Putting Things Together\n\n* **Test Scaffolding:**\n    * The test driver executes the program under test.\n    * The test driver creates or interacts with stubs.\n    * The program under test uses stubs.\n    * The program under test produces outputs.\n    * The oracle uses inputs to determine expected outputs.\n    * The oracle compares expected outputs with actual outputs.\n    * The oracle produces a verdict (pass/fail).\n\n## A Simple Example\n\n* **Goal:**  Test the `root()` function.\n* **Challenge:** The `mySquareRoot()` function is not yet available.\n* **Solution:**  Stub `mySquareRoot()`.\n\n**Key Concepts**\n\n* **mySquareRoot.h:**  Header file defining the `mySquareRoot()` function.\n* **mySquareRoot-Stub.c:** The stub implementation of `mySquareRoot()`.\n* **stubFormySquareRoot.h:** Header file defining the `setReturnValue()` function to control the stub's behavior. \n* **root.h:** Header file defining the `root()` function.\n* **root-UnitTestWithStub.c:**  The test driver.\n\n**Steps**\n\n1. **Stub `mySquareRoot()`:**\n    * The stub `mySquareRoot()`  returns the value set by the driver's `setReturnValue()` function.\n2. **Test Driver:**\n    * Sets the environment including the stub.\n    * Executes the `root()` function with known inputs.\n    * Compares the actual outputs with expected outputs.\n    * Prints the test result (pass/fail). \n\n**Important:**  The test driver and stub are separate components that work together to isolate and test the `root()` function.\n\n## Automated Test Infrastructure\n\n* **Familiar tools:**\n    * JUnit\n    * Google's C++ xUnit\n    * Other similar frameworks in different programming languages.\n\n* **Less familiar tools:**\n    * TTCN-3\n    * Organization-specific setups.\n\n**Key Points:**\n\n* **What changes?** The syntax of the test frameworks might differ. \n* **What doesn't change?** The fundamental need to decide what inputs/outputs to choose for testing. \n\n## Areas for Further Research/Clarification\n\n* **Advanced Test Frameworks:** Explore the features and capabilities of different test frameworks beyond the basic examples. \n* **Testing Techniques:** Research different testing methodologies and strategies, such as black-box testing, white-box testing, integration testing, etc.\n* **Test Automation Tools:**  Investigate tools that can help with automating test cases, generating test reports, and managing test environments. \n* **The Role of Stubs and Mocks:** Delve into more advanced uses of stubs and mocks, such as how they can be used for dependency injection and isolating components.\n* **Test Driven Development (TDD):**  Understand the principles of TDD and its impact on software development. \n",
    "review": [
        {
            "answer": "A **fault** is a defect in a system that can cause errors during runtime. For example, a faulty statement or incorrect logic.",
            "question": "What is a fault in the context of software engineering?"
        },
        {
            "answer": "An **error** occurs when a fault is activated during runtime, leading to the system entering an unexpected state. For example, an erroneous calculation or data corruption.",
            "question": "Explain the difference between a fault and an error."
        },
        {
            "answer": "**Failure** happens when the system's delivered service deviates from its intended behavior due to a fault or error. This could mean the system produces incorrect outputs, crashes, or fails to meet its performance requirements.",
            "question": "Describe the concept of failure in relation to faults and errors."
        },
        {
            "answer": "The three conditions necessary for a failure to be observed are **reachability**, **infection**, and **propagation**. Reachability refers to reaching the faulty code in the program. Infection means the program's state becomes incorrect due to the fault. Propagation signifies that the infected state causes incorrect outputs in the system.",
            "question": "What are the three conditions necessary for a failure to be observed, and explain each briefly."
        },
        {
            "answer": "**Observability** measures how easy it is to understand a program's behavior by examining its outputs and effects on the environment. High observability means it's easy to see the program's actions and their consequences. Low observability makes it difficult to understand what's happening. Observability is closely related to propagation, as it's about how easily the impact of faults or errors can be observed in the system's output.",
            "question": "Define observability and explain its relationship to the concept of propagation."
        },
        {
            "answer": "**Controllability** refers to how easily we can provide a program with the required inputs to trigger different behaviors. High controllability means we can easily control the program's execution flow and input values. Low controllability makes it challenging to test specific scenarios and behaviors. Controllability is closely related to reachability and infection because we need to control the program's execution to reach the faulty code and induce the incorrect state that causes the failure.",
            "question": "What is controllability, and how does it connect to reachability and infection?"
        },
        {
            "answer": "Test scaffolding, also known as a test harness, is the infrastructure (software or hardware) used to execute test cases. It consists of three key components: \n\n1. **Test driver:** Executes test cases by providing input values and controlling the program under test. \n2. **Test stub (mock):** Simulates the behavior of a dependent component that is not yet fully developed or unavailable for testing. \n3. **Test oracle:** Compares the actual output produced by the program with the expected output to determine the success or failure of the test case.",
            "question": "Describe the concept of test scaffolding, and list its three key components."
        }
    ],
    "keywords": "## Glossary of Key Terms and Concepts \n\nHere is a glossary of key terms and concepts from the lecture document/presentation on \"Definitions - Part I\" related to software testing and verification:\n\n**Controllability**\n- A measure of how easy it is to provide a program with the needed inputs in terms of values, operations, and behaviors.\n- For example, it is easier to control a program that receives inputs from a keyboard compared to a program that receives inputs from hardware sensors. \n\n**Error** \n- An unexpected state that occurs at runtime due to the activation of a fault. \n- For example, a program might encounter an error if it attempts to divide by zero. \n\n**Fault** \n- A defect in a system. A fault can lead to errors in a program.\n- For example, a faulty statement in code could cause a program to crash. \n\n**Failure** \n- An instance where the delivered service deviates from what the system is intended for. Failures are typically caused by errors. \n- For example, a web server may experience a failure if it is unable to respond to requests due to an error in its code. \n\n**Infection**\n- The state of the program being incorrect, often due to a fault.\n- For example, a variable in a program could be assigned an incorrect value. \n\n**Observability** \n- A measure of how easy it is to observe the behavior of a program in terms of its outputs, effects on the environment, and interactions with other hardware and software components. \n- For example, it is harder to observe the behavior of a program that interacts with a database than a program that only prints to the console. \n\n**Propagation**\n- The process by which an infected state spreads to affect other parts of the system, potentially leading to failure.\n- For example, an error in a function could propagate to other functions that depend on it. \n\n**Reachability** \n- The ability to reach the locations in the program that contain the fault.\n- For example, it may be difficult to reach a fault if it is in a part of the program that is not executed under normal circumstances. \n\n**Test driver** \n- A software component or test tool that takes care of the control and calling of a software component during testing. \n- For example, a test driver could be used to execute a specific set of test cases against a program. \n\n**Test harness**\n- The infrastructure (software and/or hardware) used to execute test cases. This includes components like test drivers and stubs. \n\n**Test oracle**\n- A component that helps determine if a test outcome is successful or not.\n- The oracle compares the actual output of the system under test against the expected output.\n\n**Test stub**\n- A skeletal or special-purpose implementation of a software module used to develop or test a component that calls the stub. It acts as a placeholder for a real component that may not be available yet.\n- For example, a stub could be used to simulate the behavior of a complex function during testing.\n"
}