{
    "metadata": {
        "overview": "This lecture, \"Definitions-Part I,\" focuses on the essential terminology used in software testing, emphasizing the distinction between faults, errors, and failures and how these concepts relate to observability and controllability in software testing.",
        "topics": [
            "Fault, Error, and Failure Definitions",
            "Reachability, Infection, and Propagation Conditions",
            "Software Observability and Controllability",
            "Observability vs. Controllability in Practice",
            "Test Scaffolding/Test Harness",
            "Test Driver, Stub, and Oracle",
            "Putting Things Together in Test Scaffolding",
            "A Simple Example of Test Scaffolding",
            "Automated Test Infrastructure"
        ],
        "format": "Lecture",
        "date": "2024-09-10",
        "course": "SYSC 4101",
        "title": "Definitions 1",
        "path": "input/SYSC4101-5105_Definitions_PI.pdf"
    },
    "notes": "# SYSC4101 / SYSC5105: Definitions - Part I\n\n## What are we looking for?\n\n- **Fault:** A defect in a system. Usually referred to as a bug in other contexts. Humans commit faults. \n    - **Example:** A faulty statement in code.\n\n- **Error:** An unexpected state entered by the system at runtime due to the activation of a fault. \n    - **Example:** An erroneous state due to a faulty statement.\n\n- **Failure:** The delivered service deviates from what the system is intended for.\n\n**Important Note:**  The word \"bug\" is not part of the vocabulary in SYSC4101.\n\n- **Fault → Error → Failure:** A failure can only be observed when three conditions are met:\n    - **Reachability:** The location in the program that contains the fault must be reached.\n    - **Infection:** The state of the program must be incorrect.\n    - **Propagation:** The incorrect state must propagate to cause some output of the program to be observed as incorrect.\n\n- **All three conditions are necessary for a failure to be observed.**\n\n    - It is not sufficient to reach the fault, as there may not be any infection, or the delivered service may not be affected. \n    - It is not sufficient to infect the state, as the delivered service may not be affected.\n\n## Observability vs. Controllability\n\n- **Software Observability:**  How easy it is to observe the behavior of a program in terms of its outputs and effects on its environment and other hardware and software components. \n    - **Example:** Software that interacts with hardware devices, databases, or remote files has low observability. \n    - **Observability relates to propagation.**\n\n- **Software Controllability:** How easy it is to provide a program with the needed inputs in terms of values, operations, and behaviors. \n    - **Example:** Software that receives input from keyboards is easy to control. Software that receives input from hardware sensors or distributed software is harder to control.\n    - **Controllability relates to reachability and infection.**\n\n## Test Scaffolding / Test Harness\n\n- **Test Scaffolding / Test Harness:** Infrastructure (software and/or hardware) that is put in place to execute test cases.\n\n- **Components:**\n\n    - **Test Driver:** A software component or test tool that replaces a component that takes care of the control and/or the calling of a software component.\n        - Executes a test case (one execution of system under test with input values) or a test suite (a set of test cases).\n\n    - **Test Stub (a.k.a. mock):** A skeletal or special-purpose implementation of a software module that is used to develop or test a component that calls the stub or otherwise depends on it.\n        - Replaces a called component.\n        - **Example:** Simulates a piece of code that is not yet ready.\n\n    - **Test Oracle:** Assists in deciding whether a test outcome is successful or not.\n        - Has two important tasks:\n            1. **Comparing the actual output against the expected output.** This is often done by software (e.g., using an assert() statement).\n            2. **Deciding what the expected output is given the test inputs.** This is often done by humans (e.g., deciding what to check in an assert() statement).\n\n**Stubs and drivers enable components to be isolated from the rest of the system for testing purposes.**\n\n## Putting Things Together\n\n- The test driver interacts with the program under test by providing inputs and receiving outputs.\n\n- The oracle uses the inputs provided by the test driver to determine the expected outputs.\n\n- The oracle then compares the actual outputs received from the program under test with the expected outputs.\n\n- The oracle produces a verdict (pass/fail) based on the comparison.\n\n- Stubs are used to simulate the behavior of components that are not yet ready or that are not being tested.\n\n## A Simple Example\n\n- **Function:** `root(a, b, c, *root1, *root2)` calculates the roots of a quadratic equation.\n\n- **Stub:** `mySquareRoot(double num)` simulates the behavior of the `sqrt()` function.\n\n- **Test Case:** The test driver sets up the stub to return a specific value for `mySquareRoot()`, then calls `root()` with specific input values. The oracle checks the calculated roots against the expected roots.\n\n## Automated Test Infrastructure\n\n- Common testing frameworks: JUnit, Google's C++ xUnit, TTCN-3\n\n- **Changes:**\n    - The syntax of test code may differ between frameworks.\n\n- **Things that don't change:**\n    - The core principles of testing remain the same.\n    - You still need to decide what inputs and outputs to use for your tests.\n\n**Important Note:** Automated testing infrastructure simplifies the process of creating and running tests, but you still need to carefully design your test cases to ensure that they effectively cover the behavior of your software.",
    "review": [
        {
            "answer": "A fault, also historically known as a bug, represents a defect within a system. It's typically introduced by human error, such as a faulty statement or a coding mistake.",
            "question": "What is a \"fault\" in the context of software systems?"
        },
        {
            "answer": "An error occurs at runtime when a fault is activated, causing the system to enter an unexpected or incorrect state. For example, an erroneous calculation or a memory access violation.",
            "question": "Explain what an \"error\" is in software systems and provide an example."
        },
        {
            "answer": "A failure occurs when the system's delivered service deviates from its intended behavior. It represents an observable consequence of an error, resulting in the system not functioning as expected.",
            "question": "What constitutes a \"failure\" in a software system?"
        },
        {
            "answer": "The three essential conditions for a failure to be observed are:\n\n1.  **Reachability:** The faulty code must be reached during execution.\n2.  **Infection:** The program's state must be incorrect due to the fault.\n3.  **Propagation:** The incorrect state must propagate to produce an observable incorrect output.",
            "question": "Describe the three conditions necessary for a failure to be observed."
        },
        {
            "answer": "Software observability measures how easily one can observe a program's behavior based on its outputs and its interactions with the environment and other software components. Factors like hardware dependencies, databases, or remote file access can reduce observability.",
            "question": "Define \"software observability\" and explain factors that can affect it."
        },
        {
            "answer": "Software controllability refers to the ease of providing a program with the necessary inputs (values, operations, and behaviors) for testing.  While keyboard input is easily controllable, inputs from hardware sensors or distributed software pose greater challenges.",
            "question": "Explain \"software controllability\" and discuss how input sources impact it."
        },
        {
            "answer": "Test scaffolding, also known as a test harness, is the infrastructure (software or hardware) that facilitates the execution of test cases. It typically involves components like a test driver, test stubs, and a test oracle.",
            "question": "What is test scaffolding, or test harness, and what components does it often include?"
        }
    ],
    "keywords": [
        {
            "definition": "The state of the program must be incorrect due to the activation of a fault.",
            "term": "Infection"
        },
        {
            "definition": "The location(s) in the program that contain the fault must be reached.",
            "term": "Reachability"
        },
        {
            "definition": "A defect in a system.",
            "term": "Fault"
        },
        {
            "definition": "Errors occur at runtime when some part of the system enters an unexpected state due to the activation of a fault.",
            "term": "Error"
        },
        {
            "definition": "A failure of the system occurs when the delivered service deviates from what the system is intended for.",
            "term": "Failure"
        },
        {
            "definition": "How easy it is to observe the behavior of a program in terms of its outputs, effects on the environment and other hardware and software components.",
            "term": "Software Observability"
        },
        {
            "definition": "How easy it is to provide a program with the needed inputs, in terms of values, operations, and behaviors.",
            "term": "Software Controllability"
        },
        {
            "definition": "Infrastructure (software and/or hardware) we put in place to execute test cases.",
            "term": "Test Scaffolding"
        },
        {
            "definition": "A skeletal or special-purpose implementation of a software module, used to develop or test a component that calls the stub or otherwise depends on it. It replaces a called component.",
            "term": "Test Stub"
        },
        {
            "definition": "A software component or test tool that replaces a component that takes care of the control and/or the calling of a software component.",
            "term": "Test Driver"
        },
        {
            "definition": "Assist in deciding whether a test outcome is successful or not.",
            "term": "Test Oracle"
        }
    ]
}