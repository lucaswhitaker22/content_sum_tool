{
    "metadata": {
        "overview": "This lecture introduces key concepts in software testing and emphasizes the importance of understanding the differences between faults, errors, and failures. It also highlights the role of observability and controllability in effective testing.",
        "topics": [
            "Defining Key Terms: Fault, Error, and Failure",
            "Importance of Three Conditions: Reachability, Infection, and Propagation",
            "Observability vs. Controllability",
            "Understanding Observability and Controllability in Relation to the Testing Process",
            "Test Scaffolding/Harness: Test Driver, Test Stub, and Test Oracle",
            "Functioning of Test Scaffolding/Harness in a Test Case",
            "A Simple Example to Illustrate Testing Concepts",
            "Automated Test Infrastructure: Familiar and Less Familiar Tools",
            "Key Changes and Constants in Automated Testing"
        ],
        "format": "Lecture",
        "date": "2024-09-11",
        "course": "SYSC 4101",
        "title": "Definitions 1",
        "path": "input/SYSC4101-5105_Definitions_PI.pdf"
    },
    "notes": "# SYSC4101 / SYSC5105: Definitions - Part I\n\n## What are we looking for?\n\n- **Fault:** A defect in a system. \n    - Humans commit faults.\n    -  Example: a faulty statement\n- **Error:** An unexpected state reached at runtime due to the activation of a fault.\n    - Example: an erroneous state.\n- **Failure:** The delivered service deviates from what the system is intended for.\n\n**Important Takeaway:**  Faults, errors, and failures are distinct, yet interconnected. All three must occur for a failure to be observable.\n\n- **Reachability:** The location(s) in the program containing the fault must be reached.\n- **Infection:** The state of the program must be incorrect.\n- **Propagation:** The infected state must propagate to cause some output to be observed as incorrect.\n\n**Important Takeaway:**  All three conditions (reachability, infection, and propagation) are necessary for a failure to be observed. Reaching the fault or infecting the state alone isn't enough.\n\n## Observability vs. Controllability\n\n- **Software Observability:**  How easy is it to observe the behavior of a program in terms of its outputs, effects on the environment, and interactions with other hardware/software components?\n    - Software that affects hardware devices, databases, or remote files has low observability.\n    - **Observability relates to propagation.**\n\n- **Software Controllability:**  How easy is it to provide a program with the needed inputs (values, operations, and behaviors)?\n    - Easy to control software with inputs from keyboards.\n    - Inputs from hardware sensors or distributed software are harder to control.\n    - **Controllability relates to reachability and infection.**\n\n## The Relationship Between Observability, Controllability, and System Components\n\nThe figure on page 5 shows the relationship between observability, controllability, and the system components involved.  The figure demonstrates how:\n\n- **Controllability:**  Determines whether we can reach specific parts of the program (reachability) and trigger a fault.\n- **Observability:** Determines whether we can observe the effects of the fault, such as erroneous outputs, to distinguish from expected behavior.\n\n**Important Takeaway:** The combination of controllability and observability helps us understand how easily a program can be tested.\n\n## Test Scaffolding/Test Harness\n\n- **Test scaffolding/test harness:**  Infrastructure (software and/or hardware) used to execute test cases.\n\n### Components of Test Scaffolding\n\n- **Test Driver:**\n    - Replaces a component to control or call another software component.\n    - Executes test cases (single executions) or test suites (sets of cases).\n\n- **Test Stub (a.k.a., mock):**\n    - A skeletal implementation of a software module used to develop or test a component that calls the stub. \n    - Replaces a called component.\n    - Example: simulates a piece of code not yet ready.\n\n- **Test Oracle:**\n    - Assists in deciding whether a test outcome is successful or not.\n    - **Important Tasks:**\n        1. **Compare Actual vs. Expected Output:** Uses assert() statements to check actual outputs against expected outputs.\n        2. **Determine Expected Output:** Given test inputs, decide what the expected output should be.\n\n**Important Takeaway:** Stubs and drivers enable the isolation of components for testing. The test oracle verifies the correctness of test outcomes.\n\n## Putting Things Together\n\nThe diagram on page 9 summarizes how the components of test scaffolding work together.  The diagram shows how:\n\n- **The Test Driver:** Executes the Program Under Test, providing input values.\n- **Test Stubs:**  Simulate the behavior of missing or incomplete components called by the Program Under Test.\n- **The Test Oracle:** Compares the actual outputs produced by the Program Under Test with the expected outputs (determined using the test inputs), and determines whether the test passes or fails.\n\n## A Simple Example\n\nThis example demonstrates how to use stubs and test harnesses to test a function called `root()` that calculates the roots of a quadratic equation.  The function requires a function called `mySquareRoot()` to calculate square roots, but `mySquareRoot()` isn't yet available.  We can use a stub called `mySquareRoot-Stub.c` to simulate the behavior of `mySquareRoot()` and allow us to test `root()` before `mySquareRoot()` is complete.\n\n**Example Summary:**\n\n- The stub `mySquareRoot-Stub.c` simulates the behavior of `mySquareRoot()` by storing the return value in a variable.\n- The driver (main program) sets the return value of the stub using `setReturnValue()`, which allows us to test `root()` with specific square root values.\n- We can execute the test by compiling and running the driver with the stub. \n\n**Important Takeaway:** Stubs allow us to test code that depends on incomplete or unavailable components, promoting early testing. \n\n## Automated Test Infrastructure\n\n- **Familiar Tools:** JUnit, Google's C++ xUnit, and similar tools for other languages.\n- **Less Familiar Tools:** TTCN-3 and other organization-specific tools.\n\n**Important Takeaway:** Automated test frameworks provide a standardized and efficient way to execute and manage tests. \n\n**Key Challenges in Automated Testing:**\n\n- **Choosing Inputs and Outputs:** The most significant challenge is to carefully select the inputs and outputs that thoroughly test the program.\n- **The Importance of Observability and Controllability:**  The design of test cases should consider both observability (to verify expected outputs) and controllability (to trigger various states and scenarios).\n\n**Important Takeaway:** While the syntax of testing frameworks may differ, the fundamental principles of test design, including choosing appropriate inputs/outputs, remain crucial.",
    "review": [
        {
            "answer": "A fault is a defect or error in a system that can lead to an error or failure during runtime.",
            "question": "What is a 'fault' in the context of software systems?"
        },
        {
            "answer": "An error occurs when a fault is activated at runtime, causing the system to enter an unexpected state.",
            "question": "What is an 'error' in software systems, and how is it related to a 'fault'?"
        },
        {
            "answer": "A failure occurs when the delivered service of the system deviates from its intended behavior due to an error.",
            "question": "What is a 'failure' in software systems, and how is it related to an 'error'?"
        },
        {
            "answer": "Observability refers to the ease of understanding and analyzing the behavior of a program, particularly in terms of its outputs and effects on the environment. Controllability refers to the ease of providing the program with the necessary inputs to trigger desired behaviors.",
            "question": "Explain the concepts of 'observability' and 'controllability' in software testing."
        },
        {
            "answer": "Reachability, Infection, and Propagation. Reachability refers to reaching the location(s) in the code where the fault exists. Infection means the program's state becomes incorrect due to the fault. Propagation refers to the spread of the incorrect state, leading to observable incorrect outputs.",
            "question": "What are the three conditions necessary for a failure to be observed in a system?"
        },
        {
            "answer": "A test harness or test scaffolding refers to the infrastructure (software and/or hardware) used to execute test cases. It typically includes components like a test driver, test stub, and test oracle.",
            "question": "What is a test harness or test scaffolding, and what are its key components?"
        },
        {
            "answer": "A test driver is a software component or tool that controls the execution of test cases, providing input values to the system under test. A test stub is a simplified implementation of a component used to simulate the behavior of a called component during testing. A test oracle is responsible for determining whether the output produced by the system under test is correct.",
            "question": "Describe the roles of the following components in a test harness: test driver, test stub, and test oracle."
        }
    ],
    "keywords": [
        {
            "definition": "A defect in a system. Often referred to as a \"bug\" for historic reasons.",
            "term": "Fault"
        },
        {
            "definition": "An unexpected state entered by the system at runtime due to the activation of a fault.",
            "term": "Error"
        },
        {
            "definition": "Occurs when the delivered service deviates from the system's intended behavior.",
            "term": "Failure"
        },
        {
            "definition": "The ability to observe a program's behavior based on its outputs, effects on the environment, and interactions with other hardware and software components. The ease with which you can see how a program behaves in its environment.",
            "term": "Software Observability"
        },
        {
            "definition": "The ability to control a program by providing it with the needed inputs, operations, and behaviors.",
            "term": "Software Controllability"
        },
        {
            "definition": "The location(s) in the program that contain the fault must be reached in order for a failure to be observed.",
            "term": "Reachability"
        },
        {
            "definition": "The state of the program must be incorrect in order for a failure to be observed. This means the fault must have influenced the program's state.",
            "term": "Infection"
        },
        {
            "definition": "The incorrect state must propagate to cause some output of the program to be observed as incorrect. The fault must have affected a part of the system that is visible.",
            "term": "Propagation"
        },
        {
            "definition": "The ease with which you can distinguish a program's actual output from its expected output. This refers to how clearly the program's behavior is manifested.",
            "term": "Observability"
        },
        {
            "definition": "Infrastructure (software and/or hardware) used to execute test cases.",
            "term": "Test Scaffolding / Test Harness"
        },
        {
            "definition": "A software component or test tool that replaces a component that takes care of the control and/or the calling of a software component. It executes test cases or test suites.",
            "term": "Test Driver"
        },
        {
            "definition": "A skeletal or special-purpose implementation of a software module used to develop or test a component that calls the stub or otherwise depends on it. It replaces a called component.",
            "term": "Test Stub"
        },
        {
            "definition": "Assists in deciding whether a test outcome is successful or not. Has two important tasks: (1) Comparing actual output against the expected output and (2) Deciding what the expected output should be.",
            "term": "Test Oracle"
        }
    ]
}