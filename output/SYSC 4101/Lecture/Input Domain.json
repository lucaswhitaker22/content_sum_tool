{
    "metadata": {
        "overview": "This lecture focuses on software testing, particularly exploring the concepts of test data selection and different test model criteria. It aims to equip students with the knowledge and techniques for effective software testing.",
        "topics": [
            "Exhaustive Testing",
            "Test Data Selection: Functional and Structural Testing",
            "Test Model Criteria",
            "Theoretical Hierarchy of Criteria",
            "Using Test Criteria",
            "Marick's Recommendation for Test Criteria",
            "Test Criteria Based on Structure: Graphs, Logical Expressions, Input Domain Characterization, and Syntactic Structures"
        ],
        "format": "Lecture",
        "date": "2024-09-17",
        "course": "SYSC 4101",
        "title": "Input Domain",
        "path": "input/SYSC4101-5105_Definitions_PII.pdf"
    },
    "notes": "# SYSC4101 / SYSC5105: Definitions - Part II\n\n## Exhaustive Testing\n\n- **Exhaustive Testing:** Testing using all possible inputs.\n  - Most of the time this is impossible.\n- **Examples:**\n  - A program that computes the factorial function (n! = n * (n-1) * (n-2) * ... * 1)\n    - Exhaustive testing would mean running the program with all possible integer values (0, 1, 2, ...).\n  - A compiler (e.g., javac)\n    - Exhaustive testing would mean compiling every possible Java program.\n\n- **Technique to Reduce Inputs:**\n  - **Equivalence Classes:** Group input elements into equivalence classes based on testing criteria.\n  - **Test Data Adequacy:** Select one input from each equivalence class.\n  - **Criteria for Selection:**  Use criteria to decide which test inputs to use and when to stop testing.\n\n## Test Data: Procedure to Select\n\n- **Test Model:** A representation of either the specification or implementation of the software.\n  - **Functional Testing:** The test model represents the specification.\n  - **Structural Testing:** The test model represents the implementation.\n- **Test Objectives (Requirements):** The criteria associated with the test model.\n- **Test Cases:** Must exercise all the elements defined by the test objectives within the test model.\n- **Test Data:** The input values used to execute the test cases.\n\n## Functional vs. Structural Testing\n\n| Functional Testing                                                                   | Structural Testing                                                                   |\n| --------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |\n| **Advantages:**                                                                | **Advantages:**                                                                |\n| - Checks conformance with the specification.                                    | - Based on control and data flow criteria.                                      |\n| - Scales up to different levels of granularity (function, class, system, etc.). | - Provides confidence about the coverage of the system being tested.              |\n| **Disadvantages:**                                                              | **Disadvantages:**                                                              |\n| - Depends on the specification and the level of detail provided.                | - Does not scale up well, mainly used at unit and integration testing levels. |\n| - Cannot reveal missing functionalities.                                       | - Cannot reveal unexpected functionalities.                                     |\n\n## Test Model Criterion\n\n- **Coverage Ratio:** The proportion of elements in a model M, defined by a criterion C, that are covered by a test set T.\n- **C-Adequate Test Set:** A test set T is C-adequate when the coverage ratio achieves 100% for criterion C.\n\n**Example 1:**\n\n- M: Control flow graph of a function.\n- C: All the statements.\n- If a test suite exercises 5 out of 8 statements, the coverage ratio is 62.5%. This test suite is **not adequate** for the all-statements criterion.\n\n**Example 2:**\n\n- M: A set of use case scenarios.\n- C: All the scenarios.\n- If a test suite exercises 12 out of 12 scenarios, the coverage ratio is 100%. This test suite is **adequate** for the all-scenarios criterion.\n\n## Test Model Criterion (cont.)\n\n- **Test Criterion:** Specifies a set of test requirements/objectives that must be satisfied to obtain an adequate test suite.\n- **Issue:** When applying a criterion to a test model, not all test requirements may be feasible.\n- **Revised Notion of Adequacy:** The coverage ratio of a test set T is the proportion of **feasible** elements in M defined by C covered by T.\n- **Revised C-Adequate Test Set:** A test set T is C-adequate when the coverage ratio achieves 100% for criterion C, considering only feasible elements.\n\n## Theoretical Hierarchy of Criteria\n\n- **Subsumption Relation:** C1 subsumes C2 if any C1-adequate test set is also C2-adequate.\n- **Important:** This is **not a subset relation**. The set of model elements needed to satisfy C2 may not be a subset of those needed to satisfy C1.\n- **Example:**\n  - Criteria: all-transitions and all-paths for finite state machines.\n  - All-paths subsumes all-transitions, as any test suite exercising all paths will automatically cover all transitions.\n- **Usually, if C1 subsumes C2:**\n  - Satisfying C1 is **more expensive** than satisfying C2.\n  - A C1-adequate test suite **detects more faults** than a C2-adequate test suite.\n\n## Two Ways to Use Test Criteria\n\n1. **Generate Test Values / Test Cases:**\n   - **Selection Criterion:** The test criterion is used to generate test values/cases.\n   - **Generator:** A tool (or human) that automatically generates test values/cases to satisfy the criterion.\n   - **Wish:** Create a software generator?\n\n2. **Evaluate Coverage:**\n   - **Coverage Criterion:** The test criterion is used to evaluate coverage achieved by externally generated test values/cases.\n   - **Recognizer:** A tool (or human) that automatically determines whether a set of values satisfies the criterion.\n   - **Wish:** Create a software recognizer?\n\n## Two Ways to Use Test Criteria (cont.)\n\n- **Problems:**\n  - How to create a generator?\n  - How to create a recognizer?\n- **Issue!:** Both problems are provably **undecidable** for most criteria.\n  - It is not possible to create a single algorithm that always finds a correct solution.\n- **However:** It is often easier to build a **recognizer** than a **generator**.\n  - Coverage analysis tools (recognizers) are quite plentiful.\n\n## Miss-Use of Terminology\n\n- **Beware:** Of the miss-use of the term \"coverage\".\n- **Example:**\n  - \"I am checking what my tests exercise with the all-statements selection criterion.\"\n    - **Incorrect:** This statement implies using the all-statements criterion as a **recognizer**, but it should be a **selection criterion** for generating test cases.\n  - \"I am creating tests with the all-scenarios coverage criterion.\"\n    - **Incorrect:** This statement implies using the all-scenarios criterion as a **generator**, but it should be a **coverage criterion** for evaluating test cases.\n  - \"I am doing structural testing since I check my tests execute all statements.\"\n    - **Incorrect:** Structural testing involves using a selection criterion to generate tests based on the implementation model. Checking test execution is a **recognizer** function, not structural testing itself.\n\n## Using a Test Selection Criterion\n\n**Steps:**\n\n1. **Choose a Test Model:** Define the model representing the software under test (e.g., state machine, flow graph).\n2. **Select a Test Criterion:** Choose a criterion to guide test case generation (e.g., all-transitions, all-paths).\n3. **Identify Test Objectives:** Define the specific aspects of the model to be covered by the tests.\n4. **Create Test Case Specifications:** Outline the intended behavior of each test case.\n5. **Identifying Test Data/Input:** Determine the input values needed to execute each test case.\n6. **Identify Oracle:** Define the expected outputs or behavior for each test case.\n\n**Example:**\n\n- **Test Model:** State machine\n- **Test Criterion:** All-transitions\n- **Test Objectives:** Ensure all transitions in the state machine are covered by the test cases.\n- **Test Case Specifications:** Create test cases that exercise specific sets of transitions.\n- **Test Data/Input:** Define input values that trigger the desired transitions.\n- **Oracle:** Specify the expected state transitions and outputs for each test case.\n\n## Example (Graph) Model\n\n- **Test Model:** A vending machine represented as a graph.\n- **Test Criterion:** All-transitions.\n- **Test Objectives:** Cover all transitions in the vending machine graph.\n- **Test Case Specifications:**\n  - TCS1: [Got0, Got5, Got10] - Cover the transitions from state Got0 to Got5, Got5 to Got10, and Got10 to Got0.\n  - TCS2: [Got0, Got10, Got0] - Cover the transitions from Got0 to Got10, Got10 to Got0, and Got0 to Got10.\n  - TCS3: [Got0, Got10, Got5, Got0] - Cover the transitions from Got0 to Got10, Got10 to Got5, Got5 to Got0, and Got0 to Got0.\n- **Test Data:**\n  - TC1: [5p, 5p] - Represents two 5p coins inserted.\n  - TC2: [10p, 5p] - Represents a 10p coin followed by a 5p coin.\n  - TC3: [10p, 10p, 10p] - Represents three 10p coins inserted.\n- **Oracles:**\n  - TC1: The machine should have 10p inside and no cans dispensed.\n  - TC2: The machine should have 0p inside and one can dispensed.\n  - TC3: The machine should have 0p inside and two cans dispensed.\n\n## Marick's Recommendation\n\nBrian Marick recommends a three-step approach:\n\n1. **Generate Functional Tests:**\n   - Use a functional selection criterion (generator) to generate test cases that cover all functions in the software.\n2. **Check Structural Coverage:**\n   - Use a structural coverage criterion (recognizer) to evaluate if the generated functional tests provide adequate structural coverage of the code.\n3. **Induce Missing Coverage:**\n   - If the structural coverage is incomplete, generate additional functional tests (not structural) that induce the missing coverage.\n\n**Rationale:** This approach prioritizes testing functionality first and then uses structural testing to ensure comprehensive coverage. The assumption is that uncovered code must have a purpose, which is likely untested functionality.\n\n## Test Criteria Based on Structure (Offutt)\n\n- **Graphs:**\n  -  Model the structure of software components using graph representations.\n  -  Examples:\n    - Method body\n    - Methods and calls\n    - Components interactions\n    - State transitions\n- **Logical Expressions:**\n  -  Represent conditions or relationships within the software.\n  -  Examples:\n    - (not X or not Y) and A and B\n    - A: {0, 1, >1}\n    - B: {600, 700, 800}\n    - C: {swe, cs, isa, infs}\n- **Input Domain Characterization:**\n  -  Describes the possible input values for a specific component or the entire system.\n  -  Example:\n    - if (x > y)\n      - z = x - y;\n    - else\n      - z = 2 * x\n- **Syntactic Structures:**\n  -  Focus on the syntactic aspects of the code, such as grammar or specific constructs.\n  -  Example: Mutation testing, where code mutations are introduced to evaluate if the tests can detect them.\n\n## Test Criteria - Graphs\n\n- **Example:** A graph representing the control flow of a program, showing nodes for different states and edges for transitions.\n- **Use:** To analyze the flow of control and identify potential paths that are not covered by existing test cases.\n\n## Test Criteria - Logic Expressions\n\n- **Example:**  A boolean expression representing a condition in the code.\n- **Use:** To generate test cases that cover different truth values (true or false) of the condition.\n\n## Test Criteria - Input Domain Characterization\n\n- **Example:** Describing the possible input values for a function or a system.\n- **Use:** To ensure that test cases cover the full range of possible inputs.\n\n## Test Criteria - Syntactic Structure\n\n- **Example:** Analyzing the code based on its grammar or syntactic constructs.\n- **Use:** To ensure that test cases cover different variations of code structure, such as different ways to express the same logic.\n\n## Conclusion\n\nThis lecture introduced key concepts related to test criteria, including:\n\n- **Exhaustive Testing:** Ideal but usually impractical.\n- **Test Data Selection:** Based on test models and criteria.\n- **Functional vs. Structural Testing:** Complementary approaches with different strengths and weaknesses.\n- **Test Model Criteria:** Define coverage requirements for test suites.\n- **Hierarchical Relationship of Criteria:** C1 subsumes C2 if any C1-adequate test set is also C2-adequate.\n- **Using Test Criteria:** Either generate test values/cases or evaluate coverage.\n- **Miss-use of Terminology:** Common errors related to the term \"coverage\".\n- **Marick's Recommendation:** Prioritize functional testing, then check structural coverage, and lastly induce missing coverage.\n- **Test Criteria Based on Structure (Offutt):** Graphs, logical expressions, input domain characterization, and syntactic structures.\n\n**Further Research:**\n\n- Explore different techniques for generating and evaluating test cases.\n- Investigate the use of test criteria in various software development methodologies.\n- Analyze the trade-offs between functional and structural testing in practice.\n- Delve into the implementation of coverage analysis tools.\n",
    "review": [
        {
            "answer": "Exhaustive testing aims to cover all possible input combinations for a program or system. It's often impossible to achieve due to the vast number of potential inputs.",
            "question": "What is exhaustive testing, and why is it often impractical?"
        },
        {
            "answer": "Exhaustive testing becomes unfeasible when dealing with programs that accept numerous inputs, like those handling integer values, as the number of potential inputs grows exponentially.",
            "question": "Explain why testing a program that calculates factorials using exhaustive testing is impractical."
        },
        {
            "answer": "Equivalence class testing is a technique that groups similar inputs into classes, allowing testers to select representative inputs from each class, thereby reducing the overall test cases.",
            "question": "What is equivalence class testing, and how does it simplify the testing process?"
        },
        {
            "answer": "Functional testing focuses on verifying that a system behaves as specified in its requirements. It's concerned with how the system works from an external perspective.",
            "question": "What is functional testing, and what is its primary focus?"
        },
        {
            "answer": "Structural testing checks if the code's internal structure is adequately exercised during testing. It's more concerned with how the code is written and executed rather than its external behavior.",
            "question": "What is structural testing, and what does it aim to assess?"
        },
        {
            "answer": "Functional testing is more scalable and adaptable to different system complexities, while structural testing is often limited to unit and integration levels.",
            "question": "Compare the scalability of functional and structural testing approaches."
        },
        {
            "answer": "The test model criterion is a set of requirements or objectives that specify what should be covered by the test suite. It helps ensure that the chosen test cases adequately address the system's functionality or structure.",
            "question": "Explain the purpose of the test model criterion in software testing."
        }
    ],
    "keywords": "# Glossary of Terms\n\nHere is a glossary of key terms and concepts from the lecture document/presentation, organized alphabetically.\n\n- **All-paths criterion:** A test criterion for finite state machines that requires a test suite to exercise all possible paths through the machine. \n- **All-transitions criterion:** A test criterion for finite state machines that requires a test suite to exercise all possible transitions of the machine.\n- **Adequate test set:** A test set that satisfies all the requirements of a given test criterion.\n- **Coverage criterion:** A test criterion used to evaluate the coverage achieved by a set of test cases. It determines whether a set of test cases satisfies a specific criterion. \n- **Coverage ratio:** The proportion of the elements in a model that are covered by a test set.\n- **Exhaustive testing:** Testing a program using all possible inputs. In most cases, this is impossible due to the vast number of potential inputs.\n- **Feasible elements:** The elements of a model that are relevant to a particular test criterion. These elements are usually a subset of the total number of elements in the model.\n- **Functional testing:** Testing that focuses on verifying the behavior of a system according to its specifications. It doesn't consider the internal structure of the system.\n- **Generator:** A tool or method that automatically generates test cases to satisfy a selection criterion.\n- **Input domain characterization:** A test criterion based on the input domain of a system, method, or component. It describes the range and types of valid inputs for a specific part of the software.\n- **Recognizer:** A tool or method that automatically determines whether a set of test cases satisfies a specific criterion.\n- **Selection criterion:** A test criterion used to generate test cases, focusing on specific aspects of the system to test. It's often used with generators.\n- **Structural testing:** Testing that focuses on verifying the internal structure of a system, ensuring that all components and paths are covered. \n- **Subsumes:** A relationship between two test criteria for the same model where a test set that satisfies one criterion (C1) also automatically satisfies another criterion (C2). \n- **Test criterion:** A rule or set of rules that defines the objectives and requirements for testing a specific aspect of a system. \n- **Test model:** A representation of the software under test. This representation can be a graph, a specification, or any other structure that captures the essential aspects of the system.\n- **Test objectives:** The specific goals or requirements that need to be met during testing, derived from the system's specifications or requirements. \n\nUnderstanding these terms is essential for comprehending the lecture material and applying the concepts of test criteria and test case generation. \n"
}