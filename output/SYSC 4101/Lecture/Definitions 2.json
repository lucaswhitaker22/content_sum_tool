{
    "metadata": {
        "overview": "This lecture explores the concepts of test model criteria, focusing on the distinction between functional and structural testing. It also delves into the practical applications of test criteria, including their use in generating test cases and evaluating test coverage.",
        "topics": [
            "Exhaustive Testing",
            "Test Data Selection",
            "Functional vs. Structural Testing",
            "Test Model Criterion",
            "Theoretical Hierarchy of Criteria",
            "Two Ways to Use Test Criteria",
            "Miss-use of Terminology",
            "Using a Test Selection Criterion",
            "Example (graph) Model",
            "Marick's Recommendation",
            "Test Criteria Based on Structure [Offutt]",
            "Test Criteria - Graphs",
            "Test Criteria - Logic Expressions",
            "Test Criteria - Input Domain Characterization",
            "Test Criteria - Syntactic Structure"
        ],
        "format": "Lecture",
        "date": "2024-09-13",
        "course": "SYSC 4101",
        "title": "Definitions 2",
        "path": "input/SYSC4101-5105_Definitions_PII.pdf"
    },
    "notes": "# SYSC4101 / SYSC5105: Definitions - Part II\n\n## Exhaustive Testing\n\n- **Definition:** Testing using all possible inputs.\n- **Why it's not practical:** Most of the time, this is impossible.\n- **Examples:**\n    - A program computing the factorial function: Testing would require running the program with all possible integer values (0, 1, 2, ...).\n    - A compiler: Testing would involve compiling every possible program.\n\n- **Technique to reduce the number of inputs:**\n    - **Equivalence Classes:** Group input elements into equivalence classes based on testing criteria.\n    - **Test Data Adequacy:** Select one input from each equivalence class.\n    - **Criteria for Stopping:**  Define criteria to determine when to stop testing. \n\n## Selecting Test Data\n\n- **Test Model:** Represents the software (e.g., specification or implementation).\n- **Test Objectives (Requirements):** Define the goals of the test.\n- **Criterion Associated to the Test Model:** Specifies how test cases should exercise the test model.\n    - **Test Data:** The specific inputs used for testing.\n- **Older Terminology:**\n    - **Black-Box Testing:** Focuses on the specification.\n    - **White-Box Testing:** Focuses on the implementation.\n\n## Functional vs. Structural Testing\n\n**Functional Testing**\n\n- **Focus:** Conformance with the specification.\n- **Benefits:** \n    - Scales up to different levels of granularity (functions, classes, packages, systems).\n    - Works at various levels of detail.\n- **Drawbacks:**\n    - Depends heavily on the specification and its level of detail.\n    - Cannot reveal missing functionalities.\n    - Doesn't guarantee that all code is being tested.\n\n**Structural Testing**\n\n- **Focus:** Control flow and data flow.\n- **Benefits:** \n    - Provides confidence about how much of the system is being tested.\n- **Drawbacks:**\n    - Does not scale well. Primarily applicable at the unit and integration levels.\n    - Cannot reveal unexpected functionalities.\n    - Doesn't work for entire systems.\n\n## Test Model Criteria\n\n- **Coverage Ratio:** Proportion of elements in the test model that are covered by the test set.\n- **C-Adequate Test Set:**  A test set is said to be C-adequate if its coverage ratio achieves 100% for a given criterion C.\n- **Example 1 (Control Flow Graph):**\n    - **Test Model:** Control flow graph of a function.\n    - **Criterion:** All statements.\n    - **Coverage Ratio:** 62.5% (5 statements out of 8).\n    - **Adequacy:** Not adequate.\n- **Example 2 (Use Case Scenarios):**\n    - **Test Model:** Set of use case scenarios.\n    - **Criterion:** All scenarios.\n    - **Coverage Ratio:** 100% (12 scenarios out of 12).\n    - **Adequacy:** Adequate.\n\n- **Test Criterion:** Specifies a set of requirements or objectives that must be satisfied for a test suite to be considered adequate.\n- **Issue:** Not all test requirements are feasible.\n- **Revised Notion of Adequacy:** The coverage ratio considers only feasible elements defined by the criterion.\n\n## Theoretical Hierarchy of Criteria\n\n- **Subsumption Relation:** Criterion C1 subsumes criterion C2 if any C1-adequate test set is also C2-adequate.\n- **Example:** \n    - **Test Model:** Finite state machines.\n    - **Criteria:** All-transitions and all-paths.\n    - **Subsumption:** All-paths subsumes all-transitions.\n- **Consequences:**\n    - **Cost:** Satisfying a more comprehensive criterion (like C1) often requires more resources than satisfying a less comprehensive criterion (like C2).\n    - **Fault Detection:** A test suite that adequately satisfies a more comprehensive criterion tends to detect more faults.\n\n## Using Test Criteria\n\n- **Two Ways:**\n    - **Generate Test Cases:**\n        - **Criterion:** Selection criterion.\n        - **Tool:** Generator (software or human) that automatically creates test cases.\n    - **Evaluate Coverage:**\n        - **Criterion:** Coverage criterion.\n        - **Tool:** Recognizer (software or human) that automatically determines if a set of values satisfies a criterion.\n\n- **Problems with Automation:**\n    - Creating generators and recognizers for most criteria is provably undecidable.\n    - **Easier to Build Recognizers:**  Coverage analysis tools are more common than automatic test case generators.\n\n## Miss-Use of Terminology\n\n- **Beware:** Avoid misusing the term \"coverage\" incorrectly.\n- **Common Errors:**\n    - **Confusion between selection and coverage criteria:**\n        - Using an all-statements criterion for evaluation instead of test case generation.\n        - Using an all-scenarios criterion for test case generation instead of evaluation.\n    - **Mistaking structural testing for coverage evaluation:** Structural testing uses a selection criterion for test case generation, not a coverage criterion.\n    - **Overstating 100% coverage:** Achieving 100% coverage for one criterion doesn't mean it's adequate for other criteria or that the cost was reasonable.\n\n## Using a Test Selection Criterion\n\n1. **Choose a Test Model:**  Represents the software (e.g., a state machine).\n2. **Select a Test Criterion:** Defines how to exercise the test model (e.g., all-transitions).\n3. **Identify Test Objectives:** Define the goals of the test (e.g., ensuring all transitions are covered).\n4. **Create Test Case Specifications:**  Outline the steps for each test case.\n5. **Identify Test Data/Input:** Determine the specific inputs needed for each test case.\n6. **Identify Oracle:** Define the expected outcomes for each test case.\n\n## Example: Vending Machine\n\n- **Test Model:**  State machine representing a vending machine that accepts 5p and 10p coins and dispenses 15p cans.\n- **Test Criterion:** All-transitions.\n- **Test Objectives:** Ensure all possible transitions in the state machine are covered.\n- **Test Case Specifications:**\n    - TCS1: Got0 -> Got5 -> Got10\n    - TCS2: Got0 -> Got10 -> Got0\n    - TCS3: Got0 -> Got10 -> Got5 -> Got0\n- **Test Data:**\n    - TC1: [5p, 5p]\n    - TC2: [10p, 5p]\n    - TC3: [10p, 10p, 10p]\n- **Oracles:**\n    - TC1: Machine has 10p, no can dispensed.\n    - TC2: Machine has 0p, one can dispensed.\n    - TC3: Machine has 0p, two cans dispensed.\n\n## Marick's Recommendation\n\nBrian Marick suggests a systematic approach to testing:\n\n1. **Generate Functional Tests:** \n    - Use a functional selection criterion to generate tests that aim to exercise all functions.\n    - This involves using a generator to create test cases.\n2. **Check Structural Coverage:**\n    - Use a structural coverage criterion to evaluate the coverage achieved by the functional tests.\n    - This involves using a recognizer to assess the coverage.\n3. **Generate Additional Functional Tests:**\n    - If the structural coverage is incomplete, create additional functional tests that address the uncovered areas.\n    - This can help reveal missing or unexpected functionalities.\n\n- **Justification:**  Form (structure) should follow function. Uncovered code likely has a purpose, and if it hasn't been invoked, it indicates a missing or untested function.\n\n## Test Criteria Based on Structure (Offutt)\n\n- **Graphs:** Represent structures like control flow graphs, state machines, or component interactions.\n- **Logical Expressions:**  Capture conditions and relationships within the software (e.g., \"not X or not Y\" or \"A and B\").\n- **Input Domain Characterization:**  Describes the range of valid inputs for a method, component, or system.\n- **Syntactic Structures:** Based on grammatical or syntactic definitions, often used in techniques like mutation testing.\n\n**Example (Control Flow Graph):**\n\n- **Node Types:**  State, Decision, Function call, etc.\n- **Edges:**  Represent transitions between nodes based on program flow.\n- **Test Criterion:**  Ensure all nodes and edges in the control flow graph are covered.\n\n## Test Criteria - Logic Expressions\n\n- **Example:**  Logic expressions from a vending machine program.\n- **Variables:**\n    - *Ss*: Amount of money in the machine\n    - *Se*: Number of cans dispensed\n- **Operators:** +, -, *, /, =, <, >, etc.\n- **Test Criteria:**\n    - **Example 1:** *Ss* > 0, *Se* = 0.\n    - **Example 2:** *Ss* > 10p, *Se* = 1.\n\n## Test Criteria - Input Domain Characterization\n\n- **Example 1:**  grep utility\n    - **Input:** File paths and regular expressions.\n    - **Test Criteria:**\n        - Test with various file types (text, binary, etc.).\n        - Test with different regular expression complexities.\n- **Example 2:**  TCAS system\n    - **Input:**  Aircraft positions, altitudes, and speeds.\n    - **Test Criteria:**\n        - Test with various aircraft types.\n        - Test with different scenarios (e.g., close approaches, head-on collisions).\n\n## Test Criteria - Syntactic Structures\n\n- **Example:**  Code fragment from a C program.\n- **Syntactic Elements:**  Statements, expressions, data types, etc.\n- **Test Criteria:**\n    - **Mutation Testing:**  Introduce small changes to the code (mutations) and test if the program can still detect these errors.\n    - **Statement Coverage:**  Ensure all statements in the code are executed at least once.\n    - **Branch Coverage:**  Ensure all branches in the code (e.g., both branches of an if-else statement) are executed.\n\n**Note:** These notes are a concise summary. Further research or clarification may be needed depending on the specific context and course materials.",
    "review": [
        {
            "answer": "Exhaustive testing refers to executing a program with all possible inputs. However, this approach is often impractical, especially for programs with a vast input space. For instance, testing a factorial function exhaustively would involve running it with every possible integer value.",
            "question": "What is exhaustive testing, and why is it usually not feasible?"
        },
        {
            "answer": "Testing criteria help reduce the number of test cases by grouping inputs into equivalence classes. This ensures that a representative sample from each class is tested, leading to more efficient and effective testing.",
            "question": "How do testing criteria help reduce the number of test cases?"
        },
        {
            "answer": "Functional testing focuses on verifying that the software behaves as specified in the requirements. It checks the program's functionality based on the external behavior described in the specification.",
            "question": "What is the main focus of functional testing?"
        },
        {
            "answer": "Structural testing examines the internal structure of the software, aiming to ensure that all code paths are covered. This approach is often called \"white-box testing\" because it involves analyzing the code itself.",
            "question": "What is structural testing, and why is it sometimes called \"white-box testing\"?"
        },
        {
            "answer": "The coverage ratio measures the proportion of elements in a test model covered by a test set. A test set is considered adequate for a specific criterion if it achieves 100% coverage for that criterion.",
            "question": "What is the coverage ratio, and how is it used to assess the adequacy of a test set?"
        },
        {
            "answer": "A test criterion defines a set of requirements or objectives that must be met to achieve an adequate test suite. These requirements can be related to different aspects of the software, such as code coverage, functionality, or specific scenarios.",
            "question": "What is a test criterion, and what role does it play in testing?"
        },
        {
            "answer": "Marick's recommendation suggests a two-step approach to testing: (1) start with functional testing using a selection criterion to ensure that all functions are covered; (2) follow up with structural testing using a coverage criterion to check for gaps in code coverage. This approach prioritizes functional correctness while ensuring that structural aspects are not neglected.",
            "question": "What is Marick's recommendation for combining functional and structural testing, and why is it considered effective?"
        }
    ],
    "keywords": "# Glossary of Terms\n\nHere is a glossary of terms from the lecture document/presentation:\n\n- **All-paths criterion:** A test criterion that requires all possible paths through a program or system to be exercised by the test suite.\n- **All-scenarios criterion:** A test criterion that requires all possible scenarios to be exercised by the test suite.\n- **All-transitions criterion:** A test criterion that requires all possible transitions in a state machine to be exercised by the test suite.\n- **C-adequate:** A test set is said to be C-adequate for a test criterion C when the coverage ratio for criterion C achieves 100%.\n- **Coverage ratio:** The proportion of elements in a model M defined by a test criterion C that are covered by a test set T. \n- **Exhaustive testing:** Testing using all possible inputs. Most of the time, this is impossible.\n- **Functional testing:** A type of software testing that checks the conformance of the software to its specification. It focuses on the external behavior of the system.\n- **Generator:** A tool (or human) that automatically generates test values or cases to satisfy a test criterion.\n- **Recognizer:** A tool (or human) that automatically decides whether a set of test values or cases satisfies a test criterion.\n- **Structural testing:** A type of software testing that checks the internal structure of the software. It focuses on the internal workings of the system, such as control flow and data flow.\n- **Subsumes:** Criterion C1 subsumes criterion C2 if any C1-adequate test set is also C2-adequate.\n- **Test criterion:** A set of test requirements or objectives that must be satisfied in order to obtain an adequate test suite.\n- **Test model:** A representation of the software, either the specification or the implementation.\n- **Test objectives:** The goals or requirements that the test suite is designed to achieve.\n\nThis glossary covers the most crucial vocabulary and ideas a student would need to understand the lecture material. \n"
}