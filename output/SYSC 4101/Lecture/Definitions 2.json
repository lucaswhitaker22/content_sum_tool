{
    "metadata": {
        "overview": "This lecture focuses on the concept of test model criteria, which are used to define the quality and adequacy of test cases. It explores different types of test criteria, including structural and functional criteria, and examines the challenges and trade-offs associated with using them.",
        "topics": [
            "Exhaustive Testing and Test Data Adequacy",
            "Functional vs. Structural Testing",
            "Test Model Criterion",
            "Theoretical Hierarchy of Criteria",
            "Two Ways to Use Test Criteria",
            "Miss-use of Terminology",
            "Using a Test Selection Criterion",
            "Example of a Test Selection Criterion",
            "Marick's Recommendation",
            "Test Criteria Based on Structure",
            "Test Criteria - Graphs",
            "Test Criteria - Logic Expressions",
            "Test Criteria - Input Domain Characterization",
            "Test Criteria - Syntactic Structures"
        ],
        "format": "Lecture",
        "date": "2024-09-13",
        "course": "SYSC 4101",
        "title": "Definitions 2",
        "path": "input/SYSC4101-5105_Definitions_PII.pdf"
    },
    "notes": "# SYSC4101 / SYSC5105: Definitions - Part II\n\n## Exhaustive Testing\n\n*   **Exhaustive testing** - Testing using all possible inputs.\n    *   Most of the time **impossible!**\n*   **Examples:**\n    *   A program that computes the factorial function (n! = n.(n-1).(n-2)...1)\n        *   Exhaustive testing = running the program with 0, 1, ..., 100, ..., i.e., all possible integer values!\n    *   A compiler (e.g., javac)\n        *   Exhaustive testing = compiling every possible (Java) program\n\n**Technique used to reduce the number of inputs (i.e., test cases):**\n\n*   Testing criteria group input elements into (equivalence) classes\n*   One input is selected in each class (notion of test data adequacy)\n*   Criteria are used to decide which test inputs to use\n*   Criteria are used to decide when to stop testing\n\n## Test Data: Procedure to Select?\n\n*   **Test model** - A representation of the software.\n    *   **Functional Testing** - The test model is a representation of the specification.\n    *   **Structural Testing** - The test model is a representation of the implementation.\n*   **Test objectives (requirements)** - Criteria associated with the test model.\n*   **Test cases** - Must exercise all the elements defined by the test objectives in the model.\n*   **Older terminology:**\n    *   Black-box testing - Functional Testing\n    *   White-box testing - Structural Testing\n\n**Example:**\n\n1.  **Model of the implementation**\n2.  **Structural Testing** - Test cases must exercise all the components and their interactions in the implementation.\n\n**Example:**\n\n1.  **Model of the functionality**\n2.  **Functional Testing** - Test cases must exercise all the functionalities defined in the specification.\n\n## Functional vs. Structural Testing\n\n**Functional Testing:**\n\n*   **Advantages:**\n    *   Checks conformance with the specification.\n    *   Scales up (different techniques at different granularity levels).\n        *   Works for a function, a class, a package/component, a system.\n*   **Disadvantages:**\n    *   Depends on the specification and the degree of detail.\n    *   Does not know how much of the system (code) is being tested.\n        *   What if the system performs some unexpected, undesirable task?\n\n**Structural Testing:**\n\n*   **Advantages:**\n    *   Based on control and data flow criteria.\n    *   Allows you to be confident about how much of the system is being tested.\n*   **Disadvantages:**\n    *   Does not scale up (mostly applicable at unit and integration testing levels).\n        *   Doesn't work for a package/component, a system.\n    *   Cannot reveal missing functionalities.\n        *   What if part of the specification is not implemented?\n\n**Diagram:**\n\n*   **System** - The implementation.\n*   **Specification** - The requirements.\n*   **Missing functionality** - Cannot be revealed by white-box (structural) techniques.\n*   **Unexpected functionality** - Cannot be revealed by black-box (functional) techniques.\n\n## Test Model Criterion\n\n*   **Given a criterion C for a model M:**\n    *   **Coverage ratio** - The proportion of the elements in M defined by C that are covered by T.\n    *   **C-adequate** - A test set T is said to be adequate for C when the coverage ratio achieves 100% for criterion C.\n\n*   **Example 1:**\n    *   M - the control flow graph of a function.\n    *   C - \"all the statements.\"\n    *   A test suite exercises 5 (out of 8) statements: 62.5% coverage (ratio).\n    *   **The test suite is not adequate for the all-statements criterion.**\n\n*   **Example 2:**\n    *   M - a set of use case scenarios.\n    *   C - \"all the scenarios.\"\n    *   A test suite exercises 12 (out of 12) scenarios: 100% coverage (ratio).\n    *   **The test suite is adequate for the all-scenarios criterion.**\n    *   **The test suite is all-scenarios adequate.**\n\n## Test Model Criterion (cont.)\n\n*   **Test criterion:**\n    *   Specifies a set of test requirements/objectives.\n    *   Test requirements must be satisfied in order to obtain an adequate test suite.\n\n*   **Issue!**\n    *   When applying a criterion on a test model, not all test requirements are feasible.\n\n*   **Revised notion of adequacy:**\n    *   **Coverage ratio** - The proportion of the **feasible** elements in M defined by C covered by T.\n    *   **C-adequate** - A test set T is said to be adequate for C when the coverage ratio achieves 100% for criterion C.\n\n## Theoretical Hierarchy of Criteria\n\n*   **Subsumption relation** - C1 **subsumes** C2 if any C1-adequate test set is also C2-adequate.\n    *   **Beware!** This is not a subset relation.\n\n*   **Example:**\n    *   Consider criteria all-transitions and all-paths for finite state machines.\n    *   All-paths subsumes all-transitions.\n    *   Any all-paths adequate test suite necessarily exercises all the transitions.\n\n*   **Usually (but not always), if C1 subsumes C2:**\n    *   Satisfying C1 **tends** to be more expensive than satisfying C2 (e.g., C1 tends to require more test cases than C2).\n    *   A C1-adequate test suite **tends** to detect more faults than a C2-adequate test suite.\n\n## Two Ways to Use Test Criteria\n\n*   **Generate test values / test cases to satisfy the criterion.**\n    *   **Selection criterion** - Criterion = selection criterion.\n    *   **Generator** - Need a tool (or human), a generator, that (automatically) generates values to satisfy the criterion.\n    *   **Wish:** Create a (software) generator?\n\n*   **Evaluate coverage achieved by externally generated test values / test cases.**\n    *   **Coverage criterion** - Criterion = coverage criterion.\n    *   **Recognizer** - Need a tool (or human), a recognizer, that (automatically) decides whether a set of values satisfies a criterion.\n    *   **Wish:** Create a (software) recognizer?\n\n## Two Ways to Use Test Criteria (cont.)\n\n*   **Problems:**\n    *   How to create a generator?\n    *   How to create a recognizer?\n\n*   **Issue!**\n    *   Both problems are provably undecidable for most criteria.\n        *   i.e., not possible to construct a single algorithm that will always, in every situation, find a correct solution.\n    *   However, it is often easier to build a **recognizer** than a **generator**.\n        *   Coverage analysis tools (recognizer) are quite plentiful.\n\n## Miss-Use of Terminology\n\n*   **Beware of miss-use of term \"coverage.\"**\n\n*   **Your colleague says:**\n\n    *   \"I am checking what my tests exercise with the all-statements selection criterion.\"\n        *   **Wrong!** They are using the all-statements criterion in a **recognizer context**.\n        *   **Coverage criterion**\n\n    *   \"I am creating tests with the all-scenarios coverage criterion.\"\n        *   **Wrong!** They are using the all-scenarios criterion in a **generator context**.\n        *   **Selection criterion**\n\n    *   \"I am doing structural testing since I check my tests execute all statements.\"\n        *   **Wrong!** With structural testing, one uses a selection criterion that applies on a model of the implementation (generator context). Here they are using the criterion in a **recognizer context**.\n\n    *   \"My tests achieve 100% coverage.\"\n        *   **What criterion?** Different criteria may have extremely different costs!\n\n## Using a Test Selection Criterion\n\n**Steps:**\n\n1.  **Choose a test model.**\n2.  **Select a test criterion.**\n3.  **Identify test objectives.**\n4.  **Create test case specifications.**\n5.  **Identifying test data/input.**\n6.  **Identify Oracle.**\n\n**Example:**\n\n1.  **State machine**\n2.  **All-transitions**\n3.  **The transitions are t1, t2, ...**\n4.  *   Test case 1 will exercise transitions t1, t4, t5.\n    *   Test case 2 will exercise transitions t1, t2, t8, ...\n5.  *   To execute test case 1, I need to execute with input value 10.\n    *   To execute test case 2, I need to execute with input value 20.\n6.  What do you feel you need to check during and at the end of the execution of test case 1, test case 2, ... and what is it you should expect?\n\n## Example (Graph) Model\n\n*   **Got 0** - initial state\n*   **Got 5** - state after inserting 5p\n*   **Got 10** - state after inserting 10p\n*   **-5p, no can** - transition after inserting 5p and no can is dispensed\n*   **-10p, can** - transition after inserting 10p and a can is dispensed\n*   **10p, no can** - transition after inserting 10p and no can is dispensed\n\n**Steps:**\n\n1.  **Choose a test model (see on the left).**\n2.  **Select a test criterion: all-transitions.**\n3.  **Identify test objectives**\n    *   Got0 -> Got5\n    *   Got5 -> Got10\n    *   Got10 -> Got5\n    *   Got0 -> Got10\n    *   Got5 -> Got10\n4.  **Create test case specification.**\n    *   TCS1 = [Got0, Got5, Got10]\n    *   TCS2 = [Got0, Got10, Got0]\n    *   TCS3 = [Got0, Got10, Got5, Got0]\n5.  **Identify test data.**\n    *   TC1 = [5p, 5p]\n    *   TC2 = [10p, 5p]\n    *   TC3 = [10p, 10p, 10p]\n6.  **Oracles**\n    *   TC1 = machine has 10p in, no can\n    *   TC2 = machine has 0p in, one can\n    *   TC3 = machine has 0p in, two cans\n\n## Marick's Recommendation\n\nBrian Marick recommends the following approach:\n\n1.  **Generate functional tests from requirements and design to try every function.**\n    *   **Use a functional selection criterion (generator).**\n\n2.  **Check the structural coverage after the functional tests are all verified to be successful.**\n    *   **Use a structural coverage criterion (recognizer).**\n\n3.  **Where the structural coverage is imperfect, generate functional tests (not structural) that induce the additional coverage.**\n\n**This works because form (structure) should follow function!**\n\n*   Uncovered code must have some purpose, and that purpose has not been invoked, so some function is untested.\n\n## Test Criteria Based on Structure [Offutt]\n\n*   **Graphs** - Based on the structure of the program, such as:\n    *   Method body\n    *   Methods and calls\n    *   Components interactions\n    *   State and transitions\n\n*   **Logical Expressions** - Can appear in:\n    *   State machine\n    *   Source code\n    *   Software specification\n\n*   **Input Domain Characterization** - Describes the input domain of the software under test (method, component, system).\n\n*   **Syntactic Structures** - Based on a grammar, or other syntactic definition.\n    *   e.g., mutation testing\n\n## Test Criteria - Graphs\n\n*   **Example:** A Control Flow Graph of a program.\n\n## Test Criteria - Logic Expressions\n\n*   **Example:** Logic expressions can be used to represent the conditions of a program.\n    *   **Input** - The input values for the logic expression.\n    *   **Gi** - The expected output of the logic expression given the input.\n    *   **N** - The logic expression is not decidable (i.e., the output is unknown).\n    *   **S** - The logic expression is decidable and the output is \"Send.\"\n    *   **R** - The logic expression is decidable and the output is \"Send.\"\n    *   **T** - The logic expression is decidable and the output is \"Send.\"\n    *   **Cr** - The logic expression is decidable and the output is \"Send.\"\n    *   **Op** - The logic expression is an operation.\n    *   **ac** - The logic expression is an \"Accept\" operation.\n    *   **Udata** - The logic expression is an \"Udata\" operation.\n    *   **Send_sq** - The logic expression is a \"Send_sq\" operation.\n    *   **XpSsq, cr** - The logic expression is an \"XpSsq, cr\" operation.\n    *   **XpSsq, cr** - The logic expression is an \"XpSsq, cr\" operation.\n    *   **XpSsq, cr** - The logic expression is an \"XpSsq, cr\" operation.\n    *   **XpSsq, cr** - The logic expression is an \"XpSsq, cr\" operation.\n    *   **XpSsq, cr** - The logic expression is an \"XpSsq, cr\" operation.\n    *   **XpSsq, cr** - The logic expression is an \"XpSsq, cr\" operation.\n\n## Test Criteria - Input Domain Characterization\n\n*   **Example:** The input domain of a program can be used to generate test cases.\n    *   **The grep utility searches any given input files, selecting lines that match one or more patterns. By default, a pattern matches an input line if the regular expression (RE) matches at least one character in the input line.  The RE must match one of the following:  a single character or a character class (e.g., [a-z]) or a range of characters (e.g., a-z) or a character sequence (e.g., [a-z]).  The RE can be made more complex by using the \".*\" operator.  The \".\" operator matches any single character, while \"*\" matches 0 or more of the previous character.  For example, \".*\" will match any string.  The grep utility is commonly used to search for text within files.**\n    *   **A general ATM (Automatic Teller Machine) system is implemented as Web service and deployed in the Tomcat server. The user and business data are stored in a MySQL database. The system offers several features such as withdrawal deposit transfer query and each of them has its own backend logic.**\n    *   **TCAS is a family of airborne devices that function independently of the ground-based air traffic control (ATC) system, and provide collision avoidance protection for a broad spectrum of aircraft types.  All TCAS systems provide some degree of collision threat alerting, and a traffic display. TCAS I and II differ primarily by their alerting capability. TCAS I provides traffic advisories (TAs) to assist the pilot in the visual acquisition of intruder aircraft. TCAS I is mandated for use in the U.S. for turbine powered, passenger-carrying aircraft having more than 10 and less than 31 seats. TCAS I is also installed on a number of general aviation fixed wing aircraft and helicopters. TCAS II provides TAs and resolution advisories (RAs), i.e., recommended escape maneuvers, in the vertical dimension to either increase or maintain the existing vertical separation between aircraft. TCAS II is mandated by the U.S. for commercial aircraft, including regional airline aircraft with more than 30 seats or a maximum takeoff weight greater than 33,000 lbs. Although not mandated for general aviation use, many turbine-powered general aviation aircraft and some helicopters are also equipped with TCAS II.**\n\n## Test Criteria - Syntactic Structure\n\n*   **Example:** The syntactic structure of a program can be used to generate test cases.\n    *   **The `malloc` function in the C standard library is a function that allocates a block of memory.  The `malloc` function takes a single argument, which is the size of the block of memory to be allocated.  The `malloc` function returns a pointer to the newly allocated block of memory.  The `malloc` function can be used to allocate memory for arrays, structures, and other data types.**\n    *   **The `free` function in the C standard library is a function that frees a block of memory.  The `free` function takes a single argument, which is a pointer to the block of memory to be freed.  The `free` function does not return a value.**\n    *   **The `realloc` function in the C standard library is a function that changes the size of a block of memory.  The `realloc` function takes two arguments.  The first argument is a pointer to the block of memory to be resized.  The second argument is the new size of the block of memory.  The `realloc` function returns a pointer to the resized block of memory.  If the `realloc` function fails, it returns a null pointer.**\n    *   **The `calloc` function in the C standard library is a function that allocates a block of memory and initializes it to zero.  The `calloc` function takes two arguments.  The first argument is the number of elements to be allocated.  The second argument is the size of each element.  The `calloc` function returns a pointer to the newly allocated block of memory.  The `calloc` function can be used to allocate memory for arrays, structures, and other data types.  The `calloc` function is useful when you want to ensure that the memory you are allocating is initialized to zero.**",
    "review": [
        {
            "answer": "Exhaustive testing involves executing a program with every possible input combination. However, it is often impractical or even impossible to perform exhaustive testing due to the vast number of potential inputs, particularly for complex software systems.",
            "question": "What is meant by 'exhaustive testing' and why is it typically not feasible?"
        },
        {
            "answer": "Equivalence classes are groups of inputs that are expected to produce similar outcomes. By selecting one representative input from each equivalence class, testers can significantly reduce the number of test cases required while still achieving adequate coverage.",
            "question": "Explain the concept of equivalence classes in software testing and how they are used to reduce the number of test cases."
        },
        {
            "answer": "Test data selection can be guided by either functional testing or structural testing. Functional testing focuses on verifying the software's behavior against its specifications, while structural testing aims to ensure all components of the code are adequately exercised.",
            "question": "What are the two primary approaches to test data selection, and how do they differ in their focus?"
        },
        {
            "answer": "A test model is a representation of either the software's specification (functional testing) or its implementation (structural testing). This model serves as the basis for selecting test cases that aim to cover the specified functionalities or code structures.",
            "question": "What is a 'test model' in the context of software testing, and what role does it play in test data selection?"
        },
        {
            "answer": "The coverage ratio measures the extent to which a test set covers the elements defined by a specific test criterion. An adequate test set achieves 100% coverage for the criterion, indicating that all elements are adequately tested.",
            "question": "Define 'coverage ratio' in software testing and explain what constitutes an 'adequate' test set in relation to a given criterion."
        },
        {
            "answer": "A test criterion specifies a set of requirements or objectives that a test set must satisfy to be considered adequate. It provides a framework for ensuring that testing is comprehensive and covers all essential aspects.",
            "question": "What is a 'test criterion' in software testing, and how does it contribute to the overall quality of testing?"
        },
        {
            "answer": "While test criteria are beneficial for guiding test data selection, they are not always perfectly feasible. Some criteria may require testing that is impractical or impossible to perform due to limitations in the software or testing environment.",
            "question": "What is the 'issue' that arises when applying test criteria to software testing, and what implications does this have?"
        }
    ],
    "keywords": "## Glossary of Key Terms and Concepts\n\nHere is a glossary of important terms and concepts from the lecture, ordered alphabetically. \n\n**All-paths Criterion** \nA test criterion that requires a test suite to cover all possible paths through a program or system. \n\n**All-scenarios Criterion**\nA test criterion that requires a test suite to cover all possible scenarios or use cases defined in a system's specification.\n\n**All-statements Criterion**\nA test criterion that requires a test suite to cover all possible statements in a program or system. \n\n**All-transitions Criterion**\nA test criterion used for state machines that requires a test suite to cover all possible transitions between states. \n\n**Coverage Ratio**\nThe proportion of elements in a model covered by a test suite. \n\n**Exhaustive Testing**\nTesting a system using all possible inputs. In most cases, this is impossible to achieve due to the vast number of potential inputs. \n\n**Functional Testing**\nTesting that focuses on verifying the functional behavior of a system against its specification.  \n\n**Generator**\nA tool or process that automatically generates test cases based on a given selection criterion.  \n\n**Input Domain Characterization**\nA test criterion that focuses on testing the system's behavior with various inputs from a defined input domain.\n\n**Recognizer**\nA tool or process that automatically checks if a set of test data satisfies a specific coverage criterion. \n\n**Selection Criterion**\nA test criterion used to select or generate test cases based on a specific aspect of the system, such as specific functionalities or inputs. \n\n**Structural Testing**\nTesting that focuses on exercising the internal structure and code of a system. \n\n**Subsumes**\nA relationship between two test criteria for the same model where a test suite that satisfies the first criterion also satisfies the second criterion.  \n\n**Syntactic Structures**\nA test criterion that utilizes the syntactic structure of a program or system to generate test cases, often used for techniques like mutation testing. \n\n**Test Model**\nA representation of a system used for testing, which could be a graph, state machine, or other model. \n\n**Test Objectives**\nThe specific requirements or goals that are to be tested. \n\n**Test Suite**\nA collection of test cases designed to comprehensively test a system. \n\n**Undecidable**\nA problem for which there is no general algorithm that can always determine a solution.  \n\n**White-Box Testing**\nAnother name for structural testing, as the tester has access to the internal code and structure of the system."
}