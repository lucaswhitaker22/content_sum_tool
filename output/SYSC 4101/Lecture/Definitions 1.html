
    <html>
    <head>
        <title>Definitions 1</title>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                line-height: 1.6; 
                padding: 20px; 
                background-color: #f9f9f9; 
                color: #333; 
            }
            h1 { 
                text-align: center; 
                color: #4CAF50; 
            }
            h2, h3 { 
                color: #333; 
                margin-top: 20px; 
            }
            p { 
                margin: 10px 0; 
            }
            .collapsible { 
                background-color: #4CAF50; 
                color: white; 
                cursor: pointer; 
                padding: 15px; 
                width: 100%; 
                border: none; 
                text-align: left; 
                outline: none; 
                font-size: 16px; 
                border-radius: 5px;
                transition: background-color 0.3s;
            }
            .collapsible:hover { 
                background-color: #45a049; 
            }
            .collapsible:after {
                content: '\002B';
                color: white;
                font-weight: bold;
                float: right;
                margin-left: 5px;
            }
            .active:after {
                content: "\2212";
            }
            .content {
                padding: 0 15px;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.2s ease-out;
                background-color: #e7f3fe;
                border-left: 5px solid #4CAF50;
                margin-bottom: 20px;
                border-radius: 5px;
            }
            dl {
                margin-left: 20px;
            }
            dt {
                font-weight: bold;
                margin-top: 10px;
            }
            dd {
                margin-left: 20px;
                margin-bottom: 10px;
            }
        </style>
    </head>
    <body>
        <h1>Definitions 1</h1>
        <p><strong>Course:</strong> SYSC 4101</p>
        <p><strong>Date:</strong> 2024-09-10</p>
        <p><strong>Overview:</strong> This lecture, "Definitions-Part I," focuses on the essential terminology used in software testing, emphasizing the distinction between faults, errors, and failures and how these concepts relate to observability and controllability in software testing.</p>
        <p><strong>Topics:</strong></p>
        <ul><li>Fault, Error, and Failure Definitions</li><li>Reachability, Infection, and Propagation Conditions</li><li>Software Observability and Controllability</li><li>Observability vs. Controllability in Practice</li><li>Test Scaffolding/Test Harness</li><li>Test Driver, Stub, and Oracle</li><li>Putting Things Together in Test Scaffolding</li><li>A Simple Example of Test Scaffolding</li><li>Automated Test Infrastructure</li></ul>
        <button class="collapsible">Lecture Notes</button>
        <div class="content">
            <h1>SYSC4101 / SYSC5105: Definitions - Part I</h1>
<h2>What are we looking for?</h2>
<ul>
<li>
<p><strong>Fault:</strong> A defect in a system. Usually referred to as a bug in other contexts. Humans commit faults. </p>
<ul>
<li><strong>Example:</strong> A faulty statement in code.</li>
</ul>
</li>
<li>
<p><strong>Error:</strong> An unexpected state entered by the system at runtime due to the activation of a fault. </p>
<ul>
<li><strong>Example:</strong> An erroneous state due to a faulty statement.</li>
</ul>
</li>
<li>
<p><strong>Failure:</strong> The delivered service deviates from what the system is intended for.</p>
</li>
</ul>
<p><strong>Important Note:</strong>  The word "bug" is not part of the vocabulary in SYSC4101.</p>
<ul>
<li>
<p><strong>Fault → Error → Failure:</strong> A failure can only be observed when three conditions are met:</p>
<ul>
<li><strong>Reachability:</strong> The location in the program that contains the fault must be reached.</li>
<li><strong>Infection:</strong> The state of the program must be incorrect.</li>
<li><strong>Propagation:</strong> The incorrect state must propagate to cause some output of the program to be observed as incorrect.</li>
</ul>
</li>
<li>
<p><strong>All three conditions are necessary for a failure to be observed.</strong></p>
<ul>
<li>It is not sufficient to reach the fault, as there may not be any infection, or the delivered service may not be affected. </li>
<li>It is not sufficient to infect the state, as the delivered service may not be affected.</li>
</ul>
</li>
</ul>
<h2>Observability vs. Controllability</h2>
<ul>
<li>
<p><strong>Software Observability:</strong>  How easy it is to observe the behavior of a program in terms of its outputs and effects on its environment and other hardware and software components. </p>
<ul>
<li><strong>Example:</strong> Software that interacts with hardware devices, databases, or remote files has low observability. </li>
<li><strong>Observability relates to propagation.</strong></li>
</ul>
</li>
<li>
<p><strong>Software Controllability:</strong> How easy it is to provide a program with the needed inputs in terms of values, operations, and behaviors. </p>
<ul>
<li><strong>Example:</strong> Software that receives input from keyboards is easy to control. Software that receives input from hardware sensors or distributed software is harder to control.</li>
<li><strong>Controllability relates to reachability and infection.</strong></li>
</ul>
</li>
</ul>
<h2>Test Scaffolding / Test Harness</h2>
<ul>
<li>
<p><strong>Test Scaffolding / Test Harness:</strong> Infrastructure (software and/or hardware) that is put in place to execute test cases.</p>
</li>
<li>
<p><strong>Components:</strong></p>
<ul>
<li>
<p><strong>Test Driver:</strong> A software component or test tool that replaces a component that takes care of the control and/or the calling of a software component.</p>
<ul>
<li>Executes a test case (one execution of system under test with input values) or a test suite (a set of test cases).</li>
</ul>
</li>
<li>
<p><strong>Test Stub (a.k.a. mock):</strong> A skeletal or special-purpose implementation of a software module that is used to develop or test a component that calls the stub or otherwise depends on it.</p>
<ul>
<li>Replaces a called component.</li>
<li><strong>Example:</strong> Simulates a piece of code that is not yet ready.</li>
</ul>
</li>
<li>
<p><strong>Test Oracle:</strong> Assists in deciding whether a test outcome is successful or not.</p>
<ul>
<li>Has two important tasks:<ol>
<li><strong>Comparing the actual output against the expected output.</strong> This is often done by software (e.g., using an assert() statement).</li>
<li><strong>Deciding what the expected output is given the test inputs.</strong> This is often done by humans (e.g., deciding what to check in an assert() statement).</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Stubs and drivers enable components to be isolated from the rest of the system for testing purposes.</strong></p>
<h2>Putting Things Together</h2>
<ul>
<li>
<p>The test driver interacts with the program under test by providing inputs and receiving outputs.</p>
</li>
<li>
<p>The oracle uses the inputs provided by the test driver to determine the expected outputs.</p>
</li>
<li>
<p>The oracle then compares the actual outputs received from the program under test with the expected outputs.</p>
</li>
<li>
<p>The oracle produces a verdict (pass/fail) based on the comparison.</p>
</li>
<li>
<p>Stubs are used to simulate the behavior of components that are not yet ready or that are not being tested.</p>
</li>
</ul>
<h2>A Simple Example</h2>
<ul>
<li>
<p><strong>Function:</strong> <code>root(a, b, c, *root1, *root2)</code> calculates the roots of a quadratic equation.</p>
</li>
<li>
<p><strong>Stub:</strong> <code>mySquareRoot(double num)</code> simulates the behavior of the <code>sqrt()</code> function.</p>
</li>
<li>
<p><strong>Test Case:</strong> The test driver sets up the stub to return a specific value for <code>mySquareRoot()</code>, then calls <code>root()</code> with specific input values. The oracle checks the calculated roots against the expected roots.</p>
</li>
</ul>
<h2>Automated Test Infrastructure</h2>
<ul>
<li>
<p>Common testing frameworks: JUnit, Google's C++ xUnit, TTCN-3</p>
</li>
<li>
<p><strong>Changes:</strong></p>
<ul>
<li>The syntax of test code may differ between frameworks.</li>
</ul>
</li>
<li>
<p><strong>Things that don't change:</strong></p>
<ul>
<li>The core principles of testing remain the same.</li>
<li>You still need to decide what inputs and outputs to use for your tests.</li>
</ul>
</li>
</ul>
<p><strong>Important Note:</strong> Automated testing infrastructure simplifies the process of creating and running tests, but you still need to carefully design your test cases to ensure that they effectively cover the behavior of your software.</p>
        </div>

        <button class="collapsible">Keywords and Definitions</button>
        <div class="content">
            <dl><dt><strong>Infection</strong></dt><dd>The state of the program must be incorrect due to the activation of a fault.</dd><dt><strong>Reachability</strong></dt><dd>The location(s) in the program that contain the fault must be reached.</dd><dt><strong>Fault</strong></dt><dd>A defect in a system.</dd><dt><strong>Error</strong></dt><dd>Errors occur at runtime when some part of the system enters an unexpected state due to the activation of a fault.</dd><dt><strong>Failure</strong></dt><dd>A failure of the system occurs when the delivered service deviates from what the system is intended for.</dd><dt><strong>Software Observability</strong></dt><dd>How easy it is to observe the behavior of a program in terms of its outputs, effects on the environment and other hardware and software components.</dd><dt><strong>Software Controllability</strong></dt><dd>How easy it is to provide a program with the needed inputs, in terms of values, operations, and behaviors.</dd><dt><strong>Test Scaffolding</strong></dt><dd>Infrastructure (software and/or hardware) we put in place to execute test cases.</dd><dt><strong>Test Stub</strong></dt><dd>A skeletal or special-purpose implementation of a software module, used to develop or test a component that calls the stub or otherwise depends on it. It replaces a called component.</dd><dt><strong>Test Driver</strong></dt><dd>A software component or test tool that replaces a component that takes care of the control and/or the calling of a software component.</dd><dt><strong>Test Oracle</strong></dt><dd>Assist in deciding whether a test outcome is successful or not.</dd></dl>
        </div>

        <button class="collapsible">Review Questions</button>
        <div class="content">
    <h3>Q: What is a "fault" in the context of software systems?</h3><p>A: A fault, also historically known as a bug, represents a defect within a system. It's typically introduced by human error, such as a faulty statement or a coding mistake.</p><h3>Q: Explain what an "error" is in software systems and provide an example.</h3><p>A: An error occurs at runtime when a fault is activated, causing the system to enter an unexpected or incorrect state. For example, an erroneous calculation or a memory access violation.</p><h3>Q: What constitutes a "failure" in a software system?</h3><p>A: A failure occurs when the system's delivered service deviates from its intended behavior. It represents an observable consequence of an error, resulting in the system not functioning as expected.</p><h3>Q: Describe the three conditions necessary for a failure to be observed.</h3><p>A: The three essential conditions for a failure to be observed are:

1.  **Reachability:** The faulty code must be reached during execution.
2.  **Infection:** The program's state must be incorrect due to the fault.
3.  **Propagation:** The incorrect state must propagate to produce an observable incorrect output.</p><h3>Q: Define "software observability" and explain factors that can affect it.</h3><p>A: Software observability measures how easily one can observe a program's behavior based on its outputs and its interactions with the environment and other software components. Factors like hardware dependencies, databases, or remote file access can reduce observability.</p><h3>Q: Explain "software controllability" and discuss how input sources impact it.</h3><p>A: Software controllability refers to the ease of providing a program with the necessary inputs (values, operations, and behaviors) for testing.  While keyboard input is easily controllable, inputs from hardware sensors or distributed software pose greater challenges.</p><h3>Q: What is test scaffolding, or test harness, and what components does it often include?</h3><p>A: Test scaffolding, also known as a test harness, is the infrastructure (software or hardware) that facilitates the execution of test cases. It typically involves components like a test driver, test stubs, and a test oracle.</p></div>
        <button class="collapsible">Practice Exam</button>
        <div class="content">
        <h2>Short Answer Questions</h2><h3>Q: Explain the difference between a "fault," an "error," and a "failure" in the context of software testing.</h3><p>A: A fault represents a defect in a system, often introduced during development. An error occurs at runtime when a fault is activated, leading to an unexpected state. A failure occurs when the system's delivered service deviates from its intended behavior due to an error. </p><h3>Q: What is "Test Scaffolding" or "Test Harness" in software testing, and what are its primary components?</h3><p>A: Test scaffolding or harness refers to the infrastructure, including software and hardware, set up to execute test cases. It comprises test drivers, test stubs, and test oracles, which help control the testing process, simulate missing components, and verify the results. </p><h3>Q: What is the significance of "Automated Test Infrastructure" in modern software development?</h3><p>A: Automated test infrastructure streamlines testing by automating the execution of test cases, including test environment setup, input provision, and result verification. This reduces manual effort and allows for more frequent and comprehensive testing. </p><h2>Long Answer Questions</h2><h3>Q: Explain the concepts of "Observability" and "Controllability" in the context of software testing. Provide specific examples to illustrate their significance.</h3><p>A: Observability refers to how easily we can understand the behavior of a program by examining its outputs and effects on the environment. It's crucial for determining if a program is functioning as intended. High observability allows us to readily detect and diagnose issues, while low observability can make it difficult to understand the program's behavior. For instance, software that interacts with hardware devices, databases, or remote files often has low observability because we need to monitor external systems to grasp its effects. On the other hand, a program with clear outputs and minimal interactions with external systems is easier to observe.  
Controllability, in contrast, is about how easily we can control a program's inputs, operations, and behaviors. A program with high controllability allows us to easily test different scenarios by providing specific inputs. However, programs with complex inputs or interactions with external systems often have low controllability. For example, a program that reads input from hardware sensors or interacts with distributed software can be challenging to control, whereas programs that rely on keyboard input for control tend to have higher controllability.   </p><h2>Multiple Choice Questions</h2><h3>Q: Which three conditions are necessary for a failure to be observed in a system?</h3><ul><li>Reachability, Controllability, Propagation</li><li>Infection, Propagation, Observability</li><li>Reachability, Infection, Propagation</li><li>Controllability, Infection, Observability</li></ul><p>Correct Answer: Reachability, Infection, Propagation</p><p>Explanation: These three conditions are crucial for a failure to manifest as a deviation from the intended behavior of the system. Reachability ensures that the faulty code is executed, Infection signifies that the program's state has been corrupted, and Propagation indicates that the corrupted state has affected the program's output.  </p><h3>Q: What is the term for a software component or tool that takes care of the control and/or the calling of a software component during testing?</h3><ul><li>Test Oracle</li><li>Test Harness</li><li>Test Driver</li><li>Test Stub</li></ul><p>Correct Answer: Test Driver</p><p>Explanation: A test driver is a software component or tool designed to control the execution of a test case or suite. It's responsible for setting up the test environment, providing inputs to the program under test, and verifying the results. Think of it as a conductor leading an orchestra, orchestrating the test process. </p><h3>Q: Which of the following is a common purpose of a "Test Stub" in software testing?</h3><ul><li>Provide expected outputs for the test case</li><li>Verify the results of the test execution</li><li>Provide a real-time environment for the program</li><li>Simulate a piece of code that is not yet ready</li></ul><p>Correct Answer: Simulate a piece of code that is not yet ready</p><p>Explanation: Test stubs are used to replace real components that are not yet available or are too complex to interact with during testing. They provide a simplified version of the missing component's behavior, enabling us to test the code that relies on it.  </p><h3>Q: What is the primary role of a "Test Oracle" in a testing process?</h3><ul><li>It controls the execution of the test case.</li><li>It simulates the behavior of a missing component.</li><li>It provides inputs to the program under test.</li><li>It compares the expected output with the actual output.</li></ul><p>Correct Answer: It compares the expected output with the actual output.</p><p>Explanation: The test oracle is responsible for evaluating the results of a test case. It acts as a judge, comparing the expected behavior of the program to the actual output produced by the test execution.  </p><h3>Q: What is the primary goal of software testing?</h3><ul><li>To find all possible bugs in the program.</li><li>To document the program's functionality.</li><li>To identify potential performance issues.</li><li>To ensure that the program is functioning correctly and producing the expected results.</li></ul><p>Correct Answer: To ensure that the program under test is functioning correctly and producing the expected results.</p><p>Explanation: The primary goal of software testing is to validate the correctness of the program. This involves checking if the program behaves as intended, meeting the specified requirements and producing the desired output.  </p></div>
        <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                } 
            });
        }
        </script>
    </body>
    </html>
    