
    <html>
    <head>
        <title>Definitions 1</title>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                line-height: 1.6; 
                padding: 20px; 
                background-color: #f9f9f9; 
                color: #333; 
            }
            h1 { 
                text-align: center; 
                color: #4CAF50; 
            }
            h2, h3 { 
                color: #333; 
                margin-top: 20px; 
            }
            p { 
                margin: 10px 0; 
            }
            .collapsible { 
                background-color: #4CAF50; 
                color: white; 
                cursor: pointer; 
                padding: 15px; 
                width: 100%; 
                border: none; 
                text-align: left; 
                outline: none; 
                font-size: 16px; 
                border-radius: 5px;
                transition: background-color 0.3s;
            }
            .collapsible:hover { 
                background-color: #45a049; 
            }
            .collapsible:after {
                content: '\002B';
                color: white;
                font-weight: bold;
                float: right;
                margin-left: 5px;
            }
            .active:after {
                content: "\2212";
            }
            .content {
                padding: 0 15px;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.2s ease-out;
                background-color: #e7f3fe;
                border-left: 5px solid #4CAF50;
                margin-bottom: 20px;
                border-radius: 5px;
            }
            dl {
                margin-left: 20px;
            }
            dt {
                font-weight: bold;
                margin-top: 10px;
            }
            dd {
                margin-left: 20px;
                margin-bottom: 10px;
            }
        </style>
    </head>
    <body>
        <h1>Definitions 1</h1>
        <p><strong>Course:</strong> SYSC 4101</p>
        <p><strong>Date:</strong> 2024-09-11</p>
        <p><strong>Overview:</strong> This lecture introduces core concepts in software testing for the SYSC4101/5105 courses.  It explains the distinction between faults, errors, and failures, and emphasizes the importance of understanding how these concepts relate to observability and controllability in testing.</p>
        <p><strong>Topics:</strong></p>
        <ul><li>Fault, Error, and Failure Distinction</li><li>Reachability, Infection, and Propagation</li><li>Software Observability and Controllability</li><li>Observability and Controllability in Practice</li><li>Test Scaffolding and Harness</li><li>Test Driver, Stub, and Oracle</li><li>Putting Things Together: Test Architecture</li><li>A Simple Example: Stubbing and Testing</li><li>Automated Test Infrastructure</li></ul>
        <button class="collapsible">Lecture Notes</button>
        <div class="content">
            <h1>SYSC4101/SYSC5105: Definitions - Part I</h1>
<h2>What are we looking for?</h2>
<ul>
<li><strong>Fault:</strong> A defect in a system (historically referred to as a bug).<ul>
<li>Humans commit faults.</li>
<li>Example: a faulty statement.</li>
</ul>
</li>
<li><strong>Error:</strong> Occurs at runtime when a fault causes a part of the system to enter an unexpected state.<ul>
<li>Example: an erroneous state.</li>
</ul>
</li>
<li><strong>Failure:</strong> Occurs when the delivered service deviates from its intended purpose.</li>
</ul>
<p><strong>Important Note:</strong> The term "bug" is not used in SYSC4101.</p>
<p><strong>Fault → Error → Failure</strong></p>
<p>For a failure to be observed, three conditions must be met:</p>
<ol>
<li><strong>Reachability:</strong> The location(s) in the program containing the fault must be reached.</li>
<li><strong>Infection:</strong> The state of the program must be incorrect due to the fault.</li>
<li><strong>Propagation:</strong> The incorrect state must propagate to affect the output of the program.</li>
</ol>
<p><strong>Key Takeaway:</strong> All three conditions are necessary for a failure to be observed. Reaching the fault or infecting the state alone is not sufficient to cause a failure.</p>
<h2>Observability vs. Controllability</h2>
<p><strong>Software Observability:</strong> How easy it is to observe the behavior of a program in terms of its outputs and effects on the environment and other hardware and software components.</p>
<ul>
<li><strong>Low Observability:</strong> Software that affects hardware devices, databases, or remote files has low observability.</li>
</ul>
<p><strong>Observability relates to Propagation.</strong></p>
<p><strong>Software Controllability:</strong> How easy it is to provide a program with the needed inputs (values, operations, and behaviors).</p>
<ul>
<li><strong>High Controllability:</strong> Easy to control software with inputs from keyboards.</li>
<li><strong>Low Controllability:</strong> Inputs from hardware sensors or distributed software are harder to control. Data abstraction also reduces controllability and observability.</li>
</ul>
<p><strong>Controllability relates to Reachability and Infection.</strong></p>
<p><strong>Example:</strong> Consider a program with a control flow graph. </p>
<ul>
<li><strong>Controllability:</strong> How easy is it to reach a specific part of the graph by providing appropriate input values?</li>
<li><strong>Observability:</strong> How easy is it to distinguish the program's output based on the erroneous state caused by a fault?</li>
</ul>
<h2>Test Scaffolding / Test Harness</h2>
<p><strong>Infrastructure (software and/or hardware) used to execute test cases.</strong></p>
<ul>
<li><strong>Test Driver:</strong> A component or test tool that replaces another component, taking care of the control and/or the calling of a software component. It executes a test case (single execution) or a test suite (set of test cases) with input values.</li>
<li><strong>Test Stub (Mock):</strong> A skeletal implementation of a software module used to develop or test a component that calls it. It replaces a called component.  It can simulate a piece of code not yet ready.</li>
<li><strong>Test Oracle:</strong> Assists in determining whether a test outcome is successful or not. It compares the actual output with the expected output.</li>
</ul>
<p><strong>Key Takeaway:</strong> Stubs and drivers enable components to be isolated from the rest of the system for testing purposes.</p>
<p><strong>Oracle's Tasks:</strong></p>
<ol>
<li><strong>Compare Output:</strong> Compares the actual output against the expected output. Often done using assert() statements.</li>
<li><strong>Determine Expected Output:</strong> Decides what the expected output should be, given the test inputs. Often done by a human.</li>
</ol>
<p><strong>Example:</strong></p>
<ul>
<li><strong>Program Under Test (PUT):</strong> A function or module that needs to be tested.</li>
<li><strong>Driver:</strong> Executes the PUT.</li>
<li><strong>Stub(s):</strong> Simulates the behavior of missing components.</li>
<li><strong>Oracle:</strong> Compares actual outputs produced by the PUT with the expected outputs, providing a verdict (pass/fail).</li>
</ul>
<h2>A Simple Example</h2>
<p><strong>Scenario:</strong> We need to test a function <code>root()</code> that calculates the roots of a quadratic equation. The function relies on <code>mySquareRoot()</code>, which is not yet available.</p>
<p><strong>Steps:</strong></p>
<ol>
<li><strong>Stub <code>mySquareRoot()</code>:</strong> Create a stub (called <code>mySquareRoot-Stub.c</code>) that simulates the behavior of <code>mySquareRoot()</code>. It allows the test driver to control the return value of <code>mySquareRoot()</code>.</li>
<li><strong>Test Driver:</strong> Create a driver (called <code>root-UnitTestWithStub.c</code>) that:<ul>
<li>Sets up the test environment (including the stub).</li>
<li>Executes the <code>root()</code> function with specific inputs.</li>
<li>Compares the actual output with the expected output using an oracle (in this case, the driver itself).</li>
<li>Prints the result of the test (pass/fail).</li>
</ul>
</li>
</ol>
<p><strong>Compiling and Executing the Test:</strong></p>
<ol>
<li>Compile the stub, the function, and the driver separately.</li>
<li>Link them together to create the executable file.</li>
<li>Run the executable to execute the test.</li>
</ol>
<p><strong>Compiling and Executing the Program with all Components:</strong></p>
<ol>
<li>Replace the stub with the actual <code>mySquareRoot()</code> implementation.</li>
<li>Compile the entire program.</li>
<li>Run the executable.</li>
</ol>
<h2>Automated Test Infrastructure</h2>
<ul>
<li><strong>Familiar Tools:</strong> JUnit, Google's C++ xUnit, and other framework-specific testing tools.</li>
<li><strong>Less Familiar Tools:</strong> TTCN-3 and organization-specific test infrastructure.</li>
</ul>
<p><strong>What Changes:</strong></p>
<ul>
<li><strong>Syntax:</strong> Testing frameworks have their own syntax for writing tests.</li>
<li><strong>What Remains the Same:</strong> The underlying principles of testing remain the same. We still need to identify inputs and outputs, and we still need to compare actual outputs with expected outputs.</li>
</ul>
<p><strong>Key Takeaway:</strong> The choice of inputs and outputs is crucial for effective testing.</p>
        </div>

        <button class="collapsible">Keywords and Definitions</button>
        <div class="content">
            <dl><dt><strong>Fault</strong></dt><dd>A defect in a system.  Humans are responsible for creating them, and an example is a faulty statement.  Often called "bugs" in other contexts.</dd><dt><strong>Error</strong></dt><dd>A state where the program is incorrect due to a fault being activated.</dd><dt><strong>Failure</strong></dt><dd>A state where the delivered service deviates from what the system is intended for.</dd><dt><strong>Software Observability</strong></dt><dd>How easy it is to observe the behavior of a program in terms of outputs, effects on the environment, and other hardware and software components.</dd><dt><strong>Software Controllability</strong></dt><dd>How easy it is to provide a program with the needed inputs in terms of values, operations, and behaviors.</dd><dt><strong>Reachability</strong></dt><dd>The location(s) in a program that contain a fault must be reached.</dd><dt><strong>Infection</strong></dt><dd>The state of the program must be incorrect.  The program may not be affected even if there is an infection.</dd><dt><strong>Propagation</strong></dt><dd>The infected state must propagate to cause some output of the program to be observed as incorrect.</dd><dt><strong>Test Driver</strong></dt><dd>A software component or test tool that replaces a component that takes care of the control and/or the calling of a software component.</dd><dt><strong>Test Stub</strong></dt><dd>A skeletal or special-purpose implementation of a software module used to develop or test a component that calls the stub or otherwise depends on it.  It replaces a called component.  For example, a stub can be used to simulate a piece of code that is not yet ready.</dd><dt><strong>Test Scaffolding/Harness</strong></dt><dd>Infrastructure (software and/or hardware) we put in place to execute test cases.  It includes test drivers, stubs, and oracles.</dd><dt><strong>Test Oracle</strong></dt><dd>A component that assists in deciding whether a test outcome is successful or not.  It compares the actual output against the expected output and determines if the test passes or fails.</dd></dl>
        </div>

        <button class="collapsible">Review Questions</button>
        <div class="content">
    <h3>Q: Define the terms 'fault', 'error', and 'failure' as they relate to software systems, and explain how they differ from each other.</h3><p>A: A fault is a defect in a system that is typically introduced during development, while an error is an unexpected state that arises at runtime due to the activation of a fault. A failure occurs when the system's delivered service deviates from its intended behavior.</p><h3>Q: Explain the concepts of 'observability' and 'controllability' in software testing. What are the key differences between these two concepts?</h3><p>A: Observability refers to how easily we can observe the behavior of a program through its outputs and interactions with the environment. Controllability, on the other hand, focuses on how easily we can provide the program with the necessary inputs to influence its behavior.</p><h3>Q: Explain the three conditions that must be met for a failure to be observed in software testing. Relate these conditions to the concepts of 'reachability', 'infection', and 'propagation'.</h3><p>A: Reachability refers to whether the code containing the fault can be executed during a test run. Infection indicates if the state of the program becomes incorrect due to the fault, and propagation signifies if the incorrect state affects the program's observable output.</p><h3>Q: What are the roles of a 'test driver' and a 'test stub' in software testing?</h3><p>A: A test driver is a program component or tool responsible for setting up and executing test cases, including supplying input values. A test stub is a simplified version of a component that replaces a called component, often used to simulate missing or incomplete code.</p><h3>Q: What is the purpose of a 'test oracle' in software testing? What tasks does it perform?</h3><p>A: A test oracle plays a crucial role in evaluating the results of a test case. It compares the actual output of the program with the expected output and determines whether the test passes or fails.</p><h3>Q: How do we choose appropriate input and output values for effective software testing?</h3><p>A: The choice of inputs and outputs for testing should be guided by the requirements and intended behavior of the system. This involves identifying critical scenarios, boundary conditions, and potential errors that could arise in the program.</p><h3>Q: Describe the benefits of using automated testing frameworks in software development. Provide examples of popular automated testing frameworks.</h3><p>A: Automated testing frameworks provide a structured environment for executing test cases and verifying results. They typically include tools for test case management, execution, and reporting. Examples include JUnit, xUnit, and TTCN-3.</p></div>
        <button class="collapsible">Practice Exam</button>
        <div class="content">
        <h2>Short Answer Questions</h2><h3>Q: What is a test driver in software testing?</h3><p>A: A test driver is a software component or test tool that replaces a component that takes care of the control and/or the calling of a software component. It executes a test case or a test suite, providing input values to the system under test and managing the execution of the test cases.</p><h3>Q: What is a test stub in software testing?</h3><p>A: A test stub is a skeletal or special-purpose implementation of a software module that replaces a called component. It simulates the behavior of a component that is not yet ready or is too complex to be tested directly. It helps to isolate the component under test from its dependencies.</p><h3>Q: What is a test oracle in software testing?</h3><p>A: A test oracle is a component that helps decide whether a test outcome is successful or not. It compares the actual output of the system under test to the expected output, which is determined by the test case inputs. It can be implemented using software or done by humans.</p><h2>Long Answer Questions</h2><h3>Q: Explain the concepts of Observability and Controllability in software testing. How are they related to the concepts of reachability, infection, and propagation? Why are they important for testing?</h3><p>A: Observability refers to how easy it is to understand the behavior of a program in terms of its outputs, effects on the environment, and other hardware and software components. It is related to the concept of propagation, which refers to the spread of an infected state through the system. Controllability, on the other hand, refers to how easy it is to provide a program with the needed inputs, in terms of values, operations, and behaviors. It is related to the concepts of reachability and infection, which refer to the ability to reach the location(s) in the program that contain the fault and to infect the state of the program with an incorrect value, respectively. Observability is crucial for determining whether a fault has led to a failure, as it allows testers to observe the consequences of the fault. Controllability is important for testing because it allows testers to create test cases that are likely to expose faults. Both observability and controllability are important for ensuring the quality of software systems.</p><h2>Multiple Choice Questions</h2><h3>Q: Which of the following is a software component that controls the execution of test cases, provides input values to the system under test, and manages the execution of the test suite?</h3><ul><li>Test driver</li><li>Test stub</li><li>Test harness</li><li>Test oracle</li></ul><p>Correct Answer: C</p><p>Explanation: The test driver is the software component that controls the execution of test cases. It provides input values to the system under test and manages the execution of the test suite. Test stubs simulate the behavior of components that are not yet ready or are too complex to be tested directly, while test oracles are used to verify the results of the test case execution. Test harnesses are a combination of all these components and provide the infrastructure for running and managing test cases.</p><h3>Q: What is the primary purpose of a test stub in software testing?</h3><ul><li>To provide actual input to the SUT for testing</li><li>To provide a controlled and predictable environment for testing</li><li>To evaluate the outputs produced by the SUT</li><li>To define the expected outputs for a test case</li></ul><p>Correct Answer: B</p><p>Explanation: A test stub is a skeletal or special-purpose implementation of a software module, used to develop or test a component that calls the stub or otherwise depends on it. It replaces a called component. The primary purpose of a test stub is to provide a controlled and predictable environment for testing a component without having to rely on the actual implementation of the dependent component.</p><h3>Q: Why is the word 'bug' not part of the vocabulary in SYSC4101?</h3><ul><li>It is considered to be a less formal and less precise term than 'fault'.</li><li>It is not a technical term used in software engineering.</li><li>It is a term used only in the context of hardware testing.</li><li>It is not a commonly used term in the software industry.</li></ul><p>Correct Answer: A</p><p>Explanation: The word 'bug' is not part of the vocabulary in SYSC4101 because it is considered to be a less formal and less precise term than 'fault'.  A fault is a defect in a system, while a bug is often used to refer to any unexpected behavior, including those that may not be due to an actual fault.  Using the term 'fault' helps to maintain a more rigorous and precise approach to software testing.</p><h3>Q: What is the main function of a test oracle in software testing?</h3><ul><li>To determine whether a test outcome is successful or not</li><li>To generate test cases for a given system</li><li>To simulate the behavior of dependent components</li><li>To provide input values to the system under test</li></ul><p>Correct Answer: A</p><p>Explanation: A test oracle is a component that helps decide whether a test outcome is successful or not. It compares the actual output of the system under test to the expected output, which is determined by the test case inputs. Test oracles can be implemented using software, but they are often done by humans, especially when the expected output is complex or difficult to define.</p><h3>Q: Why is reachability a necessary condition for a failure to be observed in a software system?</h3><ul><li>The faulty statement in the program must be executed for the fault to have any impact on the system's behavior.</li><li>The fault must be detected and corrected before the system is deployed.</li><li>The fault must be propagated to the output of the system for it to be considered a failure.</li><li>The fault must be easily identifiable and reproducible in the system.</li></ul><p>Correct Answer: B</p><p>Explanation: Reachability is a necessary condition for a failure to be observed. This means that the location(s) in the program that contain the fault must be reached for the fault to have any impact on the system's behavior. In the given scenario, if the faulty statement in the program is never executed, it will not cause any failure. Therefore, reachability is crucial to ensure that the fault is actually being tested.</p></div>
        <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                } 
            });
        }
        </script>
    </body>
    </html>
    