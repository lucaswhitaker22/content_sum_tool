
    <html>
    <head>
        <title>Definitions 1</title>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                line-height: 1.6; 
                padding: 20px; 
                background-color: #f9f9f9; 
                color: #333; 
            }
            h1 { 
                text-align: center; 
                color: #4CAF50; 
            }
            h2, h3 { 
                color: #333; 
                margin-top: 20px; 
            }
            p { 
                margin: 10px 0; 
            }
            .collapsible { 
                background-color: #4CAF50; 
                color: white; 
                cursor: pointer; 
                padding: 15px; 
                width: 100%; 
                border: none; 
                text-align: left; 
                outline: none; 
                font-size: 16px; 
                border-radius: 5px;
                transition: background-color 0.3s;
            }
            .collapsible:hover { 
                background-color: #45a049; 
            }
            .collapsible:after {
                content: '\002B';
                color: white;
                font-weight: bold;
                float: right;
                margin-left: 5px;
            }
            .active:after {
                content: "\2212";
            }
            .content {
                padding: 0 15px;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.2s ease-out;
                background-color: #e7f3fe;
                border-left: 5px solid #4CAF50;
                margin-bottom: 20px;
                border-radius: 5px;
            }
        </style>
    </head>
    <body>
        <h1>Definitions 1</h1>
        <p><strong>Course:</strong> SYSC 4101</p>
        <p><strong>Date:</strong> 2024-09-10</p>
        <p><strong>Overview:</strong> This lecture focuses on defining and understanding the critical concepts of "fault", "error", and "failure" in software systems. It also explores the importance of "observability" and "controllability" in relation to these concepts, emphasizing their role in testing and debugging.</p>

        <button class="collapsible">Lecture Notes</button>
        <div class="content">
            <h1>SYSC4101/SYSC5105: Definitions - Part I</h1>
<h2>What are we looking for?</h2>
<ul>
<li><strong>Fault</strong>: A defect in a system (historically referred to as a bug).  Humans commit faults.<ul>
<li>Example: A faulty statement in code.</li>
</ul>
</li>
<li><strong>Error</strong>: Occurs at runtime when a fault causes a system to enter an unexpected state.<ul>
<li>Example: An erroneous state due to a faulty calculation.</li>
</ul>
</li>
<li><strong>Failure</strong>: Occurs when the delivered service deviates from its intended behavior.</li>
</ul>
<p><strong>Important Note</strong>: The term "bug" is not used in SYSC4101.</p>
<h2>Fault, Error, and Failure Relationship</h2>
<ul>
<li><strong>Fault → Error → Failure</strong>:  All three components are necessary for a failure to be observed.<ul>
<li><strong>Reachability</strong>: The location of the fault within the program must be reached.</li>
<li><strong>Infection</strong>: The state of the program must be incorrect due to the fault.</li>
<li><strong>Propagation</strong>: The incorrect state must propagate to cause an incorrect output. </li>
</ul>
</li>
</ul>
<h2>Observability vs. Controllability</h2>
<ul>
<li><strong>Software Observability</strong>: How easily we can observe the behavior of a program in terms of its outputs, effects on the environment, and interaction with other hardware and software components.<ul>
<li>Observability is low for software that interacts with hardware devices, databases, or remote files.</li>
<li><strong>Observability relates to Propagation.</strong></li>
</ul>
</li>
<li><strong>Software Controllability</strong>: How easily we can provide a program with the needed inputs (values, operations, and behaviors) to trigger specific actions.<ul>
<li>Controllability is higher for programs that accept inputs from keyboards.</li>
<li>Controllability decreases for programs that interact with hardware sensors or distributed software due to data abstraction.</li>
<li><strong>Controllability relates to Reachability and Infection.</strong></li>
</ul>
</li>
</ul>
<h2>Visualizing Fault Detection</h2>
<ul>
<li><strong>Reachability</strong>:  How easily we can reach the code containing the fault.</li>
<li><strong>Propagation</strong>: How easily the fault's impact propagates to produce an incorrect output.</li>
<li><strong>Controllability</strong>:  How easily we can control inputs to the program to trigger the fault and its consequences.</li>
<li><strong>Observability</strong>: How easily we can distinguish the incorrect output from the expected output.</li>
</ul>
<h2>Test Scaffolding/Test Harness</h2>
<ul>
<li><strong>Test scaffolding/harness</strong>: Infrastructure (software and/or hardware) used to execute test cases.<ul>
<li><strong>Test Driver</strong>:  A software component that controls and calls the system under test. It executes a test case (one execution with input values) or a test suite (a set of test cases).</li>
<li><strong>Test Stub (Mock)</strong>: A skeletal or special-purpose implementation of a software module that replaces a called component. Used to develop or test a component that calls the stub.<ul>
<li>Example: Simulates a piece of code that is not yet ready.</li>
</ul>
</li>
<li><strong>Test Oracle</strong>:  A component that determines whether a test outcome is successful or not.  It has two key tasks:<ol>
<li><strong>Comparing Actual vs. Expected Output</strong>: Often done using assert statements (by software).</li>
<li><strong>Deciding Expected Output</strong>: Often done by a human.</li>
</ol>
</li>
<li><strong>Stubs and Drivers</strong>: Enable isolating components for testing purposes.</li>
</ul>
</li>
</ul>
<h2>Putting Things Together</h2>
<ol>
<li><strong>Test Inputs</strong>:  Provide data to trigger specific scenarios in the system under test.</li>
<li><strong>Test Driver</strong>: Executes the system under test with the provided inputs.</li>
<li><strong>Test Stub(s)</strong>:  Replace any components that are not yet ready or are difficult to interact with directly.</li>
<li><strong>Program Under Test</strong>:  The software component being tested.</li>
<li><strong>Outputs</strong>:  The results generated by the program under test.</li>
<li><strong>Test Oracle</strong>:  Uses inputs and expected outputs to determine whether the actual outputs are correct.</li>
<li><strong>Verdict</strong>:  Pass or fail, indicating the outcome of the test.</li>
</ol>
<h2>A Simple Example</h2>
<ul>
<li><strong>Scenario</strong>:  Testing a function <code>root()</code> that calculates the roots of a quadratic equation, where <code>mySquareRoot()</code> is a function that calculates the square root.</li>
<li><strong>Requirement</strong>: We need to test <code>root()</code> before <code>mySquareRoot()</code> is ready.</li>
<li><strong>Solution</strong>:  Create a stub for <code>mySquareRoot()</code> to simulate its behavior.<ul>
<li><strong>Stub</strong>: Provides a simple simulation of <code>mySquareRoot()</code>.</li>
<li><strong>Driver</strong>: Executes the test case, setting up the stub with desired return values.</li>
<li><strong>Oracle</strong>: Compares the actual output from <code>root()</code> to the expected output, based on the stubbed <code>mySquareRoot()</code> function.</li>
</ul>
</li>
</ul>
<h2>Automated Test Infrastructure</h2>
<ul>
<li><strong>Familiar Tools</strong>: JUnit, Google's C++ xUnit, and similar testing frameworks.</li>
<li><strong>Less Familiar Tools</strong>: TTCN-3 (Telecommunications Testing and Common Notation) and other organizational-specific testing tools.</li>
</ul>
<h2>Changes and Challenges</h2>
<ul>
<li><strong>Changes</strong>: Syntax and specific tools may vary, but the core principles remain the same.</li>
<li><strong>Challenge</strong>: Determining appropriate input values and expected outputs for testing is a critical step in test case design.</li>
</ul>
<h2>Takeaways</h2>
<ul>
<li>Understanding fault, error, and failure, as well as observability and controllability, is crucial for effective software testing.</li>
<li>Test scaffolding and harnesses are essential for creating and executing test cases.</li>
<li>Automated test infrastructure provides a powerful means of streamlining testing processes.</li>
<li>Selecting appropriate inputs and expected outputs is a crucial step in creating effective test cases.</li>
</ul>
        </div>

        <button class="collapsible">Keywords and Definitions</button>
        <div class="content">
            <h2>Glossary of Key Terms</h2>
<p>Here's a glossary of key terms and concepts from the lecture document/presentation, organized alphabetically:</p>
<ul>
<li>
<p><strong>Controllability</strong>: How easy it is to provide a program with the needed inputs, in terms of values, operations, and behaviors. This relates to <strong>Reachability</strong> and <strong>Infection</strong>. </p>
<ul>
<li><strong>Example</strong>: Inputting values from a keyboard is easier to control than input from hardware sensors or distributed software. </li>
</ul>
</li>
<li>
<p><strong>Error</strong>:  An unexpected state reached at runtime due to the activation of a <strong>Fault</strong>.</p>
<ul>
<li><strong>Example</strong>: A program crashes because of a division by zero error.</li>
</ul>
</li>
<li>
<p><strong>Fault</strong>: A defect in a system, often referred to historically as a "bug". Humans commit faults. </p>
<ul>
<li><strong>Example</strong>: A faulty statement in code that leads to incorrect calculations.</li>
</ul>
</li>
<li>
<p><strong>Failure</strong>: A deviation of the delivered service from what the system is intended for.</p>
<ul>
<li><strong>Example</strong>: A web server responding with a "500 Internal Server Error" instead of the expected web page.</li>
</ul>
</li>
<li>
<p><strong>Infection</strong>: The state of the program being incorrect due to a <strong>Fault</strong>. This is one of the three conditions necessary for a <strong>Failure</strong> to be observed. </p>
</li>
<li>
<p><strong>Observability</strong>: How easy it is to observe the behavior of a program in terms of its outputs and effects on the environment and other software and hardware components. This relates to <strong>Propagation</strong>.</p>
<ul>
<li><strong>Example</strong>: Software that interacts with databases or hardware devices might have lower observability. </li>
</ul>
</li>
<li>
<p><strong>Oracle</strong>: Assists in determining whether a test outcome is successful or not. It has two tasks: </p>
<ol>
<li>Comparing the actual output against the expected output.</li>
<li>Deciding the expected output given the test inputs.</li>
</ol>
</li>
<li>
<p><strong>Propagation</strong>: The infected state must propagate to cause some output to be observed as incorrect. This is one of the three conditions necessary for a <strong>Failure</strong> to be observed.</p>
</li>
<li>
<p><strong>Reachability</strong>: The locations in the program that contain the <strong>Fault</strong> must be reached. This is one of the three conditions necessary for a <strong>Failure</strong> to be observed. </p>
</li>
<li>
<p><strong>Test Driver</strong>: A software component that replaces a component responsible for controlling and/or calling another software component. It executes test cases or test suites.</p>
</li>
<li>
<p><strong>Test Harness/Scaffolding</strong>: The infrastructure (software or hardware) used to execute test cases.  This includes the <strong>Test Driver</strong>, <strong>Test Stub</strong>, and <strong>Test Oracle</strong>.</p>
</li>
<li>
<p><strong>Test Stub (or Mock)</strong>: A skeletal implementation of a software module used for development or testing a component that calls it. It replaces a called component.  </p>
<ul>
<li><strong>Example</strong>: Simulating a piece of code that is not yet ready. </li>
</ul>
</li>
</ul>
        </div>

        <button class="collapsible">Review Questions</button>
        <div class="content">
    <h3>Q: What is a fault in the context of software systems?</h3><p>A: A fault is a defect or error in a system, often referred to as a "bug" in less formal contexts. It represents a flaw in the system's design, implementation, or configuration that could potentially lead to incorrect behavior.</p><h3>Q: Explain the concept of an error in software systems.</h3><p>A: An error occurs at runtime when the system enters an unexpected state due to the activation of a fault. It's the actual manifestation of a fault during program execution.</p><h3>Q: What constitutes a failure in a software system?</h3><p>A: A failure occurs when the system's delivered service deviates from its intended behavior. It's the observable consequence of an error, where the system fails to perform its intended function correctly.</p><h3>Q: Define Reachability as it relates to software faults.</h3><p>A: Reachability refers to the ability to reach the location(s) in the program containing the fault. This means that the code containing the fault must be executed during the program's execution.</p><h3>Q: Explain what is meant by Infection in the context of software faults.</h3><p>A: Infection signifies that the state of the program is incorrect due to the activation of the fault.  The fault has caused the program to deviate from its expected state.</p><h3>Q: What does the concept of Propagation refer to in the context of software faults?</h3><p>A: Propagation refers to the process by which the infected state caused by a fault spreads, ultimately leading to an observable failure. The incorrect state must impact the program's output or behavior.</p><h3>Q: Define observability in the context of software testing.</h3><p>A: Observability refers to how easily you can observe the behavior of a program. It measures how readily you can track the program's outputs, its impact on the environment, and its interactions with other hardware and software components. Observability is crucial for understanding how a program functions and for pinpointing the source of potential errors.</p></div>
        <button class="collapsible">Practice Exam</button>
        <div class="content">
        <h2>SYSC4101 / SYSC5105 Practice Exam: Definitions and Testing</h2>
<p><strong>Instructions:</strong> Answer all questions to the best of your ability.  Please use complete sentences for short and long answer questions.</p>
<p><strong>Multiple Choice (5 points each):</strong></p>
<ol>
<li>
<p>Which of the following is NOT a condition necessary for a failure to be observed?
    a) Reachability 
    b) Infection
    c) Controllability
    d) Propagation</p>
</li>
<li>
<p>What does "observability" relate to?
    a) Reachability 
    b) Infection
    c) Propagation
    d) Controllability</p>
</li>
<li>
<p>What is a test stub?
    a) A component that replaces another component to take care of control or calling
    b) A skeletal implementation of a software module used for testing
    c) A component that compares actual outputs to expected outputs
    d) A component that executes test cases</p>
</li>
<li>
<p>What is a test driver?
    a) A component that replaces another component to take care of control or calling
    b) A skeletal implementation of a software module used for testing
    c) A component that compares actual outputs to expected outputs
    d) A component that executes test cases</p>
</li>
<li>
<p>What is the purpose of a test oracle?
    a) To provide a test case with inputs 
    b) To simulate the behavior of a component that is not yet ready
    c) To determine whether a test outcome is successful or not
    d) To execute test cases</p>
</li>
</ol>
<p><strong>Short Answer (10 points each):</strong></p>
<ol>
<li>
<p>Explain the difference between a fault and an error in software development.</p>
</li>
<li>
<p>Describe how controllability relates to reachability and infection.</p>
</li>
<li>
<p>What is the purpose of test scaffolding in software testing?</p>
</li>
</ol>
<p><strong>Long Answer/Essay (15 points each):</strong></p>
<ol>
<li>
<p>Discuss the concept of observability in the context of software testing. How does observability affect the design of test cases? Provide an example to illustrate your point.</p>
</li>
<li>
<p>Explain the role of test drivers, test stubs, and test oracles in a test harness. How do these components work together to facilitate the testing process? Use a diagram or an example to illustrate your explanation.</p>
</li>
</ol>
<h2>Answer Key</h2>
<p><strong>Multiple Choice:</strong></p>
<ol>
<li><strong>c) Controllability</strong> - Controllability relates to providing inputs to the program, not the conditions necessary for a failure to occur. </li>
<li><strong>c) Propagation</strong> - Observability is about how easy it is to see the effects of a fault through the program, which directly relates to propagation.</li>
<li><strong>b) A skeletal implementation of a software module used for testing</strong> - Test stubs are simplified versions of components that are used to isolate and test other components without needing the full functionality.</li>
<li><strong>d) A component that executes test cases</strong> -  Test drivers are responsible for running test cases and providing the necessary input values.</li>
<li><strong>c) To determine whether a test outcome is successful or not</strong> - The test oracle checks the actual output against the expected output to determine whether the test passed or failed.</li>
</ol>
<p><strong>Short Answer:</strong></p>
<ol>
<li>
<p>A <strong>fault</strong> is a defect in the code, such as a logic error or a typo, that can cause a program to behave incorrectly. An <strong>error</strong> occurs at runtime when a fault is activated, leading to an unexpected state in the program. A fault is a potential problem, while an error is an actual occurrence of a problem.</p>
</li>
<li>
<p>Controllability is closely tied to reachability and infection. <strong>Reachability</strong> is about being able to reach the code containing the fault, which often relies on controllability – the ability to provide specific inputs to trigger that code execution. Once reached, <strong>infection</strong> refers to the fault affecting the program's state. This also depends on controllability as the input might need to be specifically chosen to trigger the fault and create an incorrect state.</p>
</li>
<li>
<p>Test scaffolding, also known as a test harness, provides the infrastructure needed to execute test cases effectively. This includes components like <strong>test drivers</strong>, which run test cases, <strong>test stubs</strong>, which simulate the behavior of other components, and <strong>test oracles</strong>, which compare actual and expected outputs.  The scaffolding facilitates isolation, controlled execution, and evaluation of tests.</p>
</li>
</ol>
<p><strong>Long Answer/Essay:</strong></p>
<ol>
<li>
<p><strong>Observability</strong> refers to the ease of understanding a program's behavior based on its outputs and interactions with its environment. It's important for testing because it affects how easily we can identify and diagnose problems.  If a program has low observability, its effects are difficult to track, making it challenging to design test cases that effectively reveal faults. </p>
<p>For instance, imagine a program that interacts with a remote database. If the program has low observability, we might only see an error message when the database connection fails, without knowing the exact cause. To test such a program, we would need to design scenarios that focus on the database interaction, including different error conditions, to increase the chance of observing and diagnosing faults. </p>
</li>
<li>
<p>A <strong>test harness</strong> is a framework that orchestrates the execution and evaluation of tests. It consists of three key components:</p>
<ul>
<li><strong>Test driver:</strong> This component runs the test cases, providing the necessary inputs and controlling the flow of execution. </li>
<li><strong>Test stub:</strong> This component acts as a placeholder for other components that are not yet ready or too complex to test directly. The stub simulates the behavior of the real component, allowing us to test the component under consideration in isolation.</li>
<li><strong>Test oracle:</strong> This component determines whether a test has passed or failed by comparing the actual output produced by the test case with the expected output.</li>
</ul>
<p>For example, imagine testing a function that calculates the area of a rectangle. We can use a test driver to call the function with specific inputs, a test stub to simulate a function that retrieves the rectangle dimensions, and a test oracle to compare the calculated area with the expected area. </p>
<p><strong>Diagram:</strong>
<code>Test Case (Input)
              |
              v
      +-----------------+
      |  Test Driver   |
      +-----------------+
            |
            |  executes
            v
      +-----------------+
      | Program Under Test |
      +-----------------+
            | uses
            v
      +-----------------+
      |     Stub      |
      +-----------------+
              |
              |  produces
              v
      +-----------------+
      |     Outputs   |
      +-----------------+
            |
            |  collects actual outputs
            v
      +-----------------+
      |    Oracle     |
      +-----------------+
            |
            |  verdict
            v
      +-----------------+
      | Pass / Fail  |
      +-----------------+</code></p>
</li>
</ol>
<p>This diagram demonstrates how the test harness components work together to execute and evaluate a test case.</p>
<p><strong>Scoring Guidelines:</strong></p>
<ul>
<li><strong>Multiple choice:</strong>  1 point for each correct answer</li>
<li><strong>Short answer:</strong>  2 points for each correct aspect of the explanation</li>
<li><strong>Long answer/essay:</strong>  5 points for a clear understanding of the concept, 5 points for explanation with examples or diagrams, and 5 points for overall clarity and organization.</li>
</ul></div>
        <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                } 
            });
        }
        </script>
    </body>
    </html>
    