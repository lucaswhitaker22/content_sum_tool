
    <html>
    <head>
        <title>Input Domain</title>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                line-height: 1.6; 
                padding: 20px; 
                background-color: #f9f9f9; 
                color: #333; 
            }
            h1 { 
                text-align: center; 
                color: #4CAF50; 
            }
            h2, h3 { 
                color: #333; 
                margin-top: 20px; 
            }
            p { 
                margin: 10px 0; 
            }
            .collapsible { 
                background-color: #4CAF50; 
                color: white; 
                cursor: pointer; 
                padding: 15px; 
                width: 100%; 
                border: none; 
                text-align: left; 
                outline: none; 
                font-size: 16px; 
                border-radius: 5px;
                transition: background-color 0.3s;
            }
            .collapsible:hover { 
                background-color: #45a049; 
            }
            .collapsible:after {
                content: '\002B';
                color: white;
                font-weight: bold;
                float: right;
                margin-left: 5px;
            }
            .active:after {
                content: "\2212";
            }
            .content {
                padding: 0 15px;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.2s ease-out;
                background-color: #e7f3fe;
                border-left: 5px solid #4CAF50;
                margin-bottom: 20px;
                border-radius: 5px;
            }
        </style>
    </head>
    <body>
        <h1>Input Domain</h1>
        <p><strong>Course:</strong> SYSC 4101</p>
        <p><strong>Date:</strong> 2024-09-17</p>
        <p><strong>Overview:</strong> This lecture explores input space partitioning, a technique for generating test cases based on criteria derived from the input domain and the software's behavior. The lecture emphasizes a step-by-step procedure for identifying characteristics, blocks, and values, as well as how to ensure the completeness and disjointness of the input model. </p>

        <button class="collapsible">Lecture Notes</button>
        <div class="content">
            <h1>SYSC 4101 / SYSC 5105: Input Space Partitioning - Criteria (Part I)</h1>
<h2>Test Criteria Based on Structure [Offutt]</h2>
<ul>
<li><strong>Graphs:</strong> Visual representation of relationships and data flow. </li>
<li><strong>Logical Expressions:</strong> Using operators like "and", "or", "not" to represent conditions. </li>
<li><strong>Input Domain Characterization:</strong> Defining the possible inputs for a software component or system. <ul>
<li><strong>Example:</strong><ul>
<li>A: {0, 1, &gt;1}</li>
<li>B: {600, 700, 800}</li>
<li>C: {swe, cs, isa, infs}</li>
</ul>
</li>
</ul>
</li>
<li><strong>Syntactic Structures:</strong>  Analyzing the syntax and structure of input data. <ul>
<li><strong>Example:</strong> 
    <code>if (x&gt;y)
        z = x - y;
    else
        z = 2 * x</code></li>
</ul>
</li>
</ul>
<h2>Basic Principles</h2>
<ul>
<li><strong>Choosing elements from the input space, from the specification:</strong> <ul>
<li><strong>Specification:</strong>  Provides information on:<ul>
<li><strong>Input Parameters:</strong>  The variables the function takes as input. </li>
<li><strong>Allowed Ranges:</strong> The acceptable values for each parameter. </li>
<li><strong>Equivalence Class Partitioning + Boundary Value Analysis:</strong>  Identifying groups of inputs that produce similar behavior and testing boundaries between groups. <ul>
<li><strong>What are the boundaries of the range?</strong> (where faults often occur)</li>
<li><strong>What is a within-range value?</strong></li>
<li><strong>What is an out-of-range value?</strong> (robustness)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Equivalence Classes:</strong> Grouping inputs that should produce the same behavior. <ul>
<li><strong>Sense of completeness:</strong> All classes should be exercised. </li>
<li><strong>No redundancy:</strong> Each class should have one input representing it. </li>
</ul>
</li>
<li><strong>Account for the test engineer expertise:</strong> The engineer's experience and knowledge are valuable in designing effective test cases. </li>
</ul>
<h2>Basic Principles - Illustrated</h2>
<ul>
<li>
<p><strong>Example:</strong> A function that takes an integer as input and has different behaviors based on the input value.</p>
<ul>
<li>
<p><strong>Equivalence Classes:</strong> </p>
<ul>
<li>&lt;0</li>
<li>0</li>
<li>[0, 10]</li>
<li>]10, 20]</li>
<li>
<blockquote>
<p>20</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>Boundary Value Analysis:</strong> Testing values at the edges of equivalence classes.</p>
<ul>
<li>&lt;0</li>
<li>0</li>
<li>]0, 10[</li>
<li>[10, 20]</li>
<li>20</li>
<li>
<blockquote>
<p>20</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>Further Boundary Value Analysis:</strong>  Testing values near the edges of equivalence classes. </p>
<ul>
<li>&lt;-1</li>
<li>-1</li>
<li>0</li>
<li>1</li>
<li>9</li>
<li>10</li>
<li>11</li>
<li>]11, 19[</li>
<li>19</li>
<li>20</li>
<li>21</li>
<li>
<blockquote>
<p>21</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Step-by-Step Procedure</h2>
<ol>
<li><strong>Identify functions/functionalities to be tested.</strong> </li>
<li><strong>For each function, identify:</strong><ul>
<li><strong>A. The parameters of the function:</strong> These are part of the function's interface/specification. </li>
<li><strong>B. The environment variables:</strong> These are factors outside the function that can impact its behavior. <ul>
<li><strong>Example:</strong> Network availability, file system settings, system time. </li>
</ul>
</li>
</ul>
</li>
<li><strong>For each parameter or environment variable, identify the characteristics of interest from a testing point of view:</strong><ul>
<li><strong>Characteristics:</strong>  "Major properties" of the parameter or environment variable, described in plain language.  <strong>Do not include actual values.</strong> <ul>
<li><strong>Example:</strong> For a string input, characteristics could include length, encoding, and structure.</li>
</ul>
</li>
<li><strong>Orthogonal perspectives:</strong> Each characteristic should represent a different aspect of the parameter. </li>
</ul>
</li>
<li><strong>For each characteristic, identify blocks:</strong> <ul>
<li><strong>Blocks:</strong>  Divide the domain of values associated with a characteristic into sets of values. </li>
<li><strong>Equivalence Classes/Boundaries:</strong>  Blocks are often defined using these concepts. </li>
<li><strong>Plain language:</strong> Use descriptive language instead of specific values. </li>
</ul>
</li>
<li><strong>For each block, identify representative values:</strong><ul>
<li><strong>Values are not used until test frames and test cases are created.</strong></li>
</ul>
</li>
</ol>
<p><strong>Input Model &amp; Test Model</strong></p>
<p>```
Tested Function
    Parameters and environment variables
        Parameter/variable's characteristics
            Characteristic's blocks
                Values of block</p>
<p>This is the input model, the test model. 
```</p>
<h2>On Characteristics...</h2>
<ul>
<li><strong>Characteristics can specify various types of values.</strong> </li>
<li>
<p><strong>These types are different from the input parameter or environment variable type.</strong></p>
</li>
<li>
<p><strong>Example:</strong> A string input to the program under test.</p>
<p><code>A string input to the program under test
    Different types
    Characteristics:
        Length (integer)
        Encoding (enumeration)
        Structure (regular expression)
        ...
    Orthogonal perspectives on type String</code></p>
</li>
</ul>
<h2>Template, Type-Specific Equivalence Classes (and Boundaries)</h2>
<ul>
<li>
<p><strong>Range:</strong> </p>
<ul>
<li>One class with values inside the range.</li>
<li>Two classes with values outside the range.</li>
<li>Possibility to add classes for boundaries and values near boundaries. </li>
</ul>
</li>
<li>
<p><strong>String:</strong></p>
<ul>
<li>At least one class with legal strings (depending on definition of "legal").</li>
<li>At least one class with illegal strings.</li>
<li>Possibility to identify boundary values, e.g., all digits.</li>
<li>Possibility to consider the content of legal strings and create further classes based on different content impacts. </li>
</ul>
</li>
<li>
<p><strong>Array:</strong></p>
<ul>
<li>One class containing all legal arrays.</li>
<li>One class for the empty array. </li>
<li>One class for arrays larger than expected.</li>
<li>Possibility to add classes for array size boundaries and values near boundaries.</li>
<li>Possibility to add classes based on the structural contents of the array (if specified).</li>
</ul>
</li>
<li>
<p><strong>Enumeration:</strong></p>
<ul>
<li>Each value is a separate class.</li>
<li>May be able to group enumeration elements based on triggered behaviors. </li>
</ul>
</li>
</ul>
<h2>Quality of the Input Model?</h2>
<ul>
<li><strong>It is paramount to check the input model!</strong></li>
<li><strong>Any missing information about how the function behaves?</strong><ul>
<li><strong>Subjectivity:</strong> It can be challenging to determine if all relevant behavior is accounted for.</li>
</ul>
</li>
<li><strong>Are the blocks of a characteristic disjoint?</strong> <ul>
<li><strong>Disjoint:</strong>  An input value should belong to only one block of a characteristic. </li>
</ul>
</li>
<li>
<p><strong>Are the blocks of a characteristic complete?</strong> </p>
<ul>
<li><strong>Complete:</strong>  The blocks should cover all possible values for the characteristic. </li>
</ul>
</li>
<li>
<p><strong>Tool support for this verification (i.e., disjointness, completeness) is possible.</strong></p>
</li>
</ul>
<h2>Criteria -&gt; Test Frames (combination of blocks)</h2>
<ul>
<li><strong>All Combinations Criterion:</strong> All combinations of blocks from all characteristics must be used. </li>
<li><strong>Each Choice/Block Criterion:</strong> Each block of each characteristic must be used at least once. </li>
<li><strong>Pair-Wise Criterion:</strong>  Each block of each characteristic must be combined with a block from each other characteristic. <ul>
<li><strong>Procedure:</strong><ol>
<li><strong>Identify pairs of blocks.</strong> </li>
<li><strong>Identify a minimum set of combinations of blocks to exercise the pairs.</strong></li>
</ol>
</li>
</ul>
</li>
<li><strong>Base Choice Criterion:</strong>  A base choice block is chosen for each characteristic, and a base test frame is formed. Subsequent test frames are created by varying one non-base choice at a time while keeping all other choices constant.</li>
</ul>
<h2>Criteria -&gt; Test Frames -&gt; Test Cases</h2>
<ul>
<li><strong>A test frame</strong> is a combination of blocks from characteristics, where no two blocks are from the same characteristic. <ul>
<li><strong>Satisfy a criterion:</strong> A set of test frames should satisfy a particular criterion (e.g., pair-wise criterion) to ensure adequate coverage. </li>
</ul>
</li>
<li><strong>A test frame is not a test case.</strong></li>
<li><strong>A test frame is a test case specification:</strong> <ul>
<li>Defines what a test case should look like.</li>
<li>Provides conditions that test inputs (the test case) should satisfy. </li>
</ul>
</li>
<li><strong>From a test frame to a test case:</strong> <ul>
<li><strong>Select input values:</strong> Choose values for each block in the test frame to satisfy the conditions.</li>
<li><strong>One test case per test frame:</strong> Create one test case for each test frame. </li>
</ul>
</li>
</ul>
<h2>Criteria Comparison (subsumption)</h2>
<ul>
<li><strong>All Combination Criterion</strong> is the most exhaustive, but can result in a large number of test cases.</li>
<li><strong>Pair-Wise Criterion</strong> is more efficient and reduces the number of test cases, but may not cover all possible combinations. </li>
<li><strong>Base Choice Criterion</strong> offers a balance, focusing on the base choice and exploring variations systematically. </li>
<li><strong>Each Choice Criterion</strong> is the least exhaustive, requiring only one test case per block, but may not cover all interactions between blocks. </li>
</ul>
<h2>Constraints Among Partitions</h2>
<ul>
<li><strong>Some combinations of blocks may be infeasible.</strong> </li>
<li><strong>Constraints:</strong> <ul>
<li><strong>Relations between blocks of different characteristics:</strong> <ul>
<li><strong>Disjoint:</strong> Blocks within the same characteristic cannot be combined. </li>
<li><strong>Constraints:</strong> Define restrictions on blocks from different characteristics. </li>
</ul>
</li>
<li><strong>Properties:</strong> Characteristics can have properties associated with them.<ul>
<li><strong>Notation:</strong> [PropertyName]</li>
</ul>
</li>
<li><strong>Selectors:</strong> Select specific properties for testing. <ul>
<li><strong>Notation:</strong> [if PropertyName], [if propNameA and propNameB], [if not propName]</li>
</ul>
</li>
<li><strong>Special cases:</strong><ul>
<li><strong>[Error]:</strong>  Indicates that a block leads to an error, and should not be combined with other blocks. </li>
<li><strong>[Single]:</strong>  Indicates that a block represents a special or unusual condition and can be adequately tested with one test case.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Constraints</h2>
<ul>
<li><strong>[Error]</strong><ul>
<li><strong>Error condition:</strong>  Indicates that the function will always result in an error when a specific value or block is used. </li>
<li><strong>No combination:</strong>  A block marked with [Error] cannot be combined with blocks from other categories. </li>
</ul>
</li>
<li><strong>[Single]</strong><ul>
<li><strong>Special or redundant conditions:</strong> Indicates a block representing a unique or unusual condition that does not need to be combined with all possible blocks. </li>
<li><strong>No combination:</strong> A block marked with [Single] cannot be combined with blocks from other categories.</li>
<li><strong>Single test case:</strong> This block is considered adequately tested with only one test case. </li>
</ul>
</li>
</ul>
<h2>Conclusions</h2>
<ul>
<li><strong>Identifying parameters, environments, characteristics, and blocks relies heavily on the experience and expertise of the tester.</strong></li>
<li><strong>Makes testing decisions explicit (e.g., constraints), open for review.</strong></li>
<li><strong>Once the first step (identifying characteristics, blocks, and constraints) is complete, the technique becomes straightforward and can be automated.</strong><ul>
<li><strong>Criterion-based test case generation:</strong>  Use criteria to automatically generate test frames and test cases. </li>
</ul>
</li>
<li><strong>The technique for test case reduction (thanks to constraints) makes it useful for practical testing.</strong></li>
</ul>
<h2>Functionality-Based Input Domain Modeling vs. Category Partition</h2>
<p><strong>Mapping of Terminology:</strong></p>
<p>| Functionality-Based Input Domain Modeling | Category Partition |
|---|---|
| Tested Function | Tested Function |
| Characteristics | Categories |
| Blocks | Choices |
| Values | Values |</p>
<h2>Areas for Further Research/Clarification</h2>
<ul>
<li><strong>How to effectively determine the completeness and disjointness of blocks, especially for complex characteristics?</strong></li>
<li><strong>What are best practices for identifying constraints, particularly for unusual or edge-case scenarios?</strong></li>
<li><strong>How can the input model be improved to incorporate information about the intended use of the software?</strong></li>
<li><strong>What tools and techniques can be used to automate the process of generating test frames and test cases from the input model?</strong></li>
</ul>
        </div>

        <button class="collapsible">Keywords and Definitions</button>
        <div class="content">
            <h2>Glossary of Key Terms and Concepts</h2>
<p>Here is a glossary of key terms and concepts from the lecture document/presentation on Input Space Partitioning - Criteria, Part I: </p>
<ul>
<li><strong>Boundary Value Analysis</strong>: A technique used in software testing to identify potential faults at the boundaries of input ranges. It involves testing values at the minimum, maximum, and just inside and outside the range.</li>
<li><strong>Blocks</strong>: Subsets of values within a characteristic's domain. They represent distinct categories of inputs based on shared properties. <ul>
<li><strong>Example:</strong> For the characteristic "length of a string," blocks could be "empty string," "short string," "medium string," and "long string."</li>
</ul>
</li>
<li><strong>Characteristics</strong>:  Properties or aspects of input parameters or environmental variables that are relevant from the perspective of a function's behavior. They are expressed in plain language and represent orthogonal perspectives on the input space. <ul>
<li><strong>Example:</strong> Characteristics of a string input could include length, encoding, and structure (regular expression).</li>
</ul>
</li>
<li><strong>Constraints</strong>: Rules or restrictions that specify combinations of blocks that are infeasible or invalid due to dependencies or limitations.<ul>
<li><strong>Example:</strong>  A constraint could specify that a certain block of an input parameter cannot be combined with a specific block of another parameter.</li>
</ul>
</li>
<li><strong>Equivalence Class Partitioning</strong>: A test design technique that divides the input domain into classes of equivalent values. The assumption is that all values within a class will produce the same behavior.</li>
<li><strong>Environment Variables</strong>:  Factors or conditions outside the direct input parameters that can influence the behavior of a function or system. <ul>
<li><strong>Example:</strong> Network connectivity, system time, or user permissions.</li>
</ul>
</li>
<li><strong>Orthogonal Perspectives</strong>:  Characteristics are considered orthogonal if they represent distinct and independent perspectives on the input space, meaning that choosing a value for one characteristic does not restrict the choice of values for another.</li>
<li><strong>Parameters</strong>:  Inputs that a function directly accepts as part of its interface or definition.</li>
<li><strong>Test Case</strong>: A specific set of input values and expected outputs that are used to verify the behavior of a function or system. </li>
<li><strong>Test Frame</strong>:  A combination of blocks from different characteristics. It acts as a template that defines the conditions for a test case.</li>
<li><strong>Test Model</strong>:  The structure that represents the input space and how it will be partitioned for testing.  It includes the identified functions, characteristics, blocks, and constraints. </li>
<li><strong>Values</strong>:  Concrete instances or specific data points within a block. </li>
</ul>
<p>This glossary provides the most essential vocabulary and concepts needed to understand the lecture material on Input Space Partitioning. </p>
        </div>

        <button class="collapsible">Review Questions</button>
        <div class="content">
    <h3>Q: What is the purpose of Input Domain Characterization in the context of test criteria based on structure?</h3><p>A: Input Domain Characterization describes the input domain of the software under test, which includes parameters like methods, components, and systems.</p><h3>Q: Explain the difference between equivalence classes and boundary value analysis in the context of input space partitioning.</h3><p>A: Equivalence classes are groups of inputs that are expected to produce the same behavior in the software, while boundary value analysis focuses on testing values at the edges of input ranges, where faults are more likely to occur.</p><h3>Q: What is the underlying assumption behind equivalence classes in software testing?</h3><p>A: The behavior of the software is assumed to be the same for all values within an equivalence class. This is based on the idea that if the software behaves correctly for one value in the class, it should behave correctly for all other values in that class.</p><h3>Q: What is the significance of orthogonal perspectives in the context of identifying characteristics for testing?</h3><p>A: Orthogonal perspectives represent different, independent aspects of a characteristic, ensuring that each aspect is covered during testing. For example, when testing a string input, orthogonal perspectives could include length, encoding, and structure.</p><h3>Q: Explain the concept of 'blocks' in the context of input space partitioning and their relationship to characteristics.</h3><p>A: Blocks are partitions of a characteristic's domain into sets of values that represent different behaviors. They are often analogous to equivalence classes or boundaries. The goal is to identify blocks that are relevant to the function's behavior and represent orthogonal perspectives.</p><h3>Q: What is the significance of the Input Model in the context of software testing?</h3><p>A: The Input Model represents the input space for a tested function, including its parameters, environment variables, characteristics, blocks, and values. It serves as a blueprint for designing test cases and ensures that the test coverage is comprehensive.</p><h3>Q: Compare and contrast the All Combinations Criterion and Pair-Wise Criterion in terms of their goals and effectiveness in test case design.</h3><p>A: All Combinations Criterion requires testing all possible combinations of blocks from all characteristics, while Pair-Wise Criterion aims to test all combinations of blocks between pairs of characteristics.  Both criteria provide a level of coverage, but All Combinations can be overly exhaustive, while Pair-Wise offers a more focused approach, prioritizing interactions between characteristics.</p></div>
        <button class="collapsible">Practice Exam</button>
        <div class="content">
        <h2>SYSC 4101 / SYSC 5105 Practice Exam: Input Space Partitioning - Criteria</h2>
<p><strong>Instructions:</strong> Please answer all questions to the best of your ability. Show your work for all questions.</p>
<p><strong>Multiple Choice (5 points each)</strong></p>
<ol>
<li>
<p>Which of the following is NOT a basic principle of input space partitioning?
    a. Choosing elements from the input space.
    b.  Using a random selection of inputs.
    c. The specification provides information on input parameters.
    d.  Account for the test engineer's expertise.</p>
</li>
<li>
<p>Equivalence class partitioning and boundary value analysis are used to identify:
    a.  The boundaries of the range of input values.
    b.  The types of input values.
    c.  The number of test cases needed.
    d.  The environment variables that impact the function's behavior.</p>
</li>
<li>
<p>Which of the following is a characteristic of a parameter or environment variable from a testing point of view?
    a.  An actual value of the parameter.
    b.  A description of the parameter in plain language.
    c.  The expected output of the function.
    d.  The code that implements the function.</p>
</li>
<li>
<p>What is a block in input space partitioning?
    a.  A single input value.
    b.  A set of input values that are considered equivalent.
    c.  A set of test cases.
    d.  A description of the function's behavior.</p>
</li>
<li>
<p>Which of the following is a criterion for combining blocks to form test frames?
    a.  Random selection.
    b.  All combinations of blocks from all characteristics must be used at least once.
    c.  Only blocks from the same characteristic can be combined.
    d.  Test frames must include at least one block from each characteristic.</p>
</li>
</ol>
<p><strong>Short Answer (10 points each)</strong></p>
<ol>
<li>Explain the difference between a test frame and a test case.</li>
<li>What are the two special cases of constraints used in input space partitioning?  How are they used in creating test frames?</li>
<li>Describe the role of the test engineer's expertise in input space partitioning.</li>
</ol>
<p><strong>Long Answer/Essay (20 points each)</strong></p>
<ol>
<li>Explain the concept of "orthogonal perspectives" in input space partitioning.  Provide an example to illustrate your explanation.</li>
<li>Describe the steps involved in creating a test model using input space partitioning.  Include examples of how to identify characteristics, blocks, and constraints.</li>
</ol>
<p><strong>Answer Key</strong></p>
<p><strong>Multiple Choice</strong></p>
<ol>
<li><strong>b. Using a random selection of inputs.</strong>  Input space partitioning aims to systematically cover the input space, not randomly select inputs.</li>
<li><strong>a. The boundaries of the range of input values.</strong> Equivalence class partitioning and boundary value analysis focus on identifying the boundaries of input ranges, which are often where faults are most likely to occur.</li>
<li><strong>b. A description of the parameter in plain language.</strong> Characteristics are described in plain language, focusing on major properties, not actual values.</li>
<li><strong>b. A set of input values that are considered equivalent.</strong> Blocks represent a partition of the characteristic's domain into sets of values that are assumed to produce the same behavior.</li>
<li><strong>b. All combinations of blocks from all characteristics must be used at least once.</strong> The All Combinations Criterion requires that all possible combinations of blocks from all characteristics are tested.</li>
</ol>
<p><strong>Short Answer</strong></p>
<ol>
<li><strong>Test Frame</strong> is a specification of conditions that a test case should satisfy, a combination of blocks from characteristics.  It defines what a test case should look like but doesn't include specific input values. <strong>Test Case</strong> is a concrete set of inputs that satisfies the conditions defined by a test frame. It includes specific values for each parameter and environment variable.</li>
<li>The two special cases of constraints are: <ul>
<li><strong>[Error]</strong> This constraint indicates that a particular block will always result in an error, and thus should not be combined with other blocks to create test frames.  </li>
<li><strong>[Single]</strong>  This constraint suggests that a block only needs to be tested once, as it's considered unusual or redundant. It can be tested independently without combining with other blocks.</li>
</ul>
</li>
<li>The test engineer's expertise is crucial in input space partitioning for the following reasons:<ul>
<li><strong>Identifying characteristics:</strong> Identifying the important properties of parameters and environment variables that might impact the function's behavior requires understanding the system's functionality and potential risks.</li>
<li><strong>Defining blocks:</strong>  Creating meaningful blocks and boundaries requires knowledge of the system's expected behavior and potential error conditions.</li>
<li><strong>Determining constraints:</strong>  The test engineer's expertise is needed to identify any constraints between blocks based on the system's logic and dependencies.</li>
</ul>
</li>
</ol>
<p><strong>Long Answer/Essay</strong></p>
<ol>
<li><strong>Orthogonal Perspectives</strong> in input space partitioning refers to examining characteristics from different and independent viewpoints.  This ensures a comprehensive test model by covering all relevant aspects of each parameter and environment variable.  For example, consider a function that takes a string as input.  The characteristics of the string could be:<ul>
<li><strong>Length</strong> (e.g., empty, short, medium, long)</li>
<li><strong>Content</strong> (e.g., numeric, alphanumeric, special characters)</li>
<li><strong>Format</strong> (e.g., valid email address, valid date)
These characteristics are orthogonal, meaning they are independent of each other. By exploring each characteristic independently, we can achieve thorough test coverage.</li>
</ul>
</li>
<li><strong>Creating a test model using input space partitioning involves the following steps:</strong><ol>
<li><strong>Identify the function/functionality to be tested:</strong>  Clearly define the function or functionality under test.</li>
<li><strong>Identify the parameters and environment variables:</strong> Determine all inputs to the function, including both parameters and relevant environment variables.</li>
<li><strong>Identify characteristics for each parameter and variable:</strong> Define the important properties of each input that could impact the function's behavior.  For example:<ul>
<li><strong>For a numeric parameter:</strong>  Characteristics could be range, sign, type (integer, float), etc.</li>
<li><strong>For a string parameter:</strong>  Characteristics could be length, content, format, encoding, etc.</li>
</ul>
</li>
<li><strong>Identify blocks within each characteristic:</strong> Partition each characteristic into sets of values (blocks) that are considered equivalent for testing.  Use equivalence classes and boundary value analysis to define these blocks.  Examples:<ul>
<li><strong>For the length characteristic:</strong>  Blocks could be empty, short, medium, long.</li>
<li><strong>For the content characteristic:</strong>  Blocks could be all numeric, all alphanumeric, all special characters, etc.</li>
</ul>
</li>
<li><strong>Identify constraints between blocks:</strong>  Determine any restrictions on combining blocks due to system logic or dependencies. Examples:<ul>
<li><strong>[Error]</strong>:  If a specific block represents an error condition, it might not be combinable with other blocks.</li>
<li><strong>[Single]</strong>: A block might be considered special or redundant and only requires a single test case.</li>
</ul>
</li>
<li><strong>Choose a test frame criterion:</strong> Select a criterion for combining blocks into test frames. Common criteria are All Combinations, Each Choice/Block, Pair-Wise, and Base Choice.</li>
<li><strong>Generate test frames:</strong> Based on the chosen criterion, generate test frames by combining blocks from different characteristics.</li>
<li><strong>Create test cases:</strong> For each test frame, select specific values from the corresponding blocks to create concrete test cases that satisfy the defined conditions.</li>
</ol>
</li>
</ol>
<p>This step-by-step process ensures a systematic and comprehensive approach to test model creation using input space partitioning.</p></div>
        <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                } 
            });
        }
        </script>
    </body>
    </html>
    