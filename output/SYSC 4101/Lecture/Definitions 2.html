
    <html>
    <head>
        <title>Definitions 2</title>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                line-height: 1.6; 
                padding: 20px; 
                background-color: #f9f9f9; 
                color: #333; 
            }
            h1 { 
                text-align: center; 
                color: #4CAF50; 
            }
            h2, h3 { 
                color: #333; 
                margin-top: 20px; 
            }
            p { 
                margin: 10px 0; 
            }
            .collapsible { 
                background-color: #4CAF50; 
                color: white; 
                cursor: pointer; 
                padding: 15px; 
                width: 100%; 
                border: none; 
                text-align: left; 
                outline: none; 
                font-size: 16px; 
                border-radius: 5px;
                transition: background-color 0.3s;
            }
            .collapsible:hover { 
                background-color: #45a049; 
            }
            .collapsible:after {
                content: '\002B';
                color: white;
                font-weight: bold;
                float: right;
                margin-left: 5px;
            }
            .active:after {
                content: "\2212";
            }
            .content {
                padding: 0 15px;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.2s ease-out;
                background-color: #e7f3fe;
                border-left: 5px solid #4CAF50;
                margin-bottom: 20px;
                border-radius: 5px;
            }
        </style>
    </head>
    <body>
        <h1>Definitions 2</h1>
        <p><strong>Course:</strong> SYSC 4101</p>
        <p><strong>Date:</strong> 2024-09-13</p>
        <p><strong>Overview:</strong> This lecture focuses on test data selection, particularly contrasting functional and structural testing approaches. It aims to explain how test criteria are used in conjunction with models of software to achieve adequate test coverage.</p>

        <button class="collapsible">Lecture Notes</button>
        <div class="content">
            <h1>SYSC4101 / SYSC5105: Definitions - Part II</h1>
<h2>Exhaustive Testing</h2>
<ul>
<li><strong>Definition:</strong> Exhaustive testing involves testing using <strong>all possible inputs</strong>.</li>
<li><strong>Limitations:</strong>  Exhaustive testing is often <strong>impossible</strong> due to the vast number of potential inputs. </li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li><strong>Factorial Function:</strong> Testing a program that calculates the factorial function (n! = n * (n - 1) * (n - 2) * ... * 1) exhaustively would require running the program with every possible integer value (0, 1, 2, ..., 100, ...).</li>
<li><strong>Compilers:</strong> Exhaustively testing a compiler like <code>javac</code> would involve compiling every possible Java program.</li>
</ul>
<p><strong>Techniques for Reducing Inputs:</strong></p>
<ul>
<li><strong>Equivalence Classes:</strong> Testing criteria group input elements into equivalence classes, reducing the number of test cases. </li>
<li><strong>Test Data Adequacy:</strong> One input is selected from each equivalence class to ensure adequate test data coverage.</li>
<li><strong>Stopping Criteria:</strong>  Testing criteria are used to determine when to stop testing.</li>
</ul>
<h2>Test Data Selection</h2>
<p><strong>Procedure:</strong></p>
<ol>
<li><strong>Test Model:</strong>  Represent the software using a model (not necessarily a graph) that reflects either the specification or the implementation.</li>
<li><strong>Test Objectives (Requirements):</strong> Define the criteria associated with the test model.</li>
<li><strong>Test Data Generation:</strong>  Test cases must exercise all elements within the test model based on the defined objectives.</li>
</ol>
<p><strong>Terminology:</strong></p>
<ul>
<li><strong>Functional Testing:</strong> The test model represents the <em>specification</em>. </li>
<li><strong>Structural Testing:</strong> The test model represents the <em>implementation</em>.</li>
<li><strong>Black-Box Testing:</strong>  Older terminology for Functional Testing.</li>
<li><strong>White-Box Testing:</strong>  Older terminology for Structural Testing.</li>
</ul>
<h2>Functional vs. Structural Testing</h2>
<p><strong>Functional Testing:</strong></p>
<ul>
<li><strong>Focus:</strong>  Checking conformance with the specification.</li>
<li><strong>Advantages:</strong><ul>
<li>Scales up to different levels of granularity (functions, classes, components, systems).</li>
<li>Works for various levels of software development.</li>
</ul>
</li>
<li><strong>Disadvantages:</strong><ul>
<li>Dependent on the specification and level of detail provided.</li>
<li>Does not reveal the extent of system code being tested.</li>
<li>Unable to uncover unexpected or undesirable behavior.</li>
</ul>
</li>
</ul>
<p><strong>Structural Testing:</strong></p>
<ul>
<li><strong>Focus:</strong>  Based on control and data flow criteria.</li>
<li><strong>Advantages:</strong> <ul>
<li>Provides confidence about the coverage of the system under test.</li>
</ul>
</li>
<li><strong>Disadvantages:</strong><ul>
<li>Does not scale up well, primarily applicable at unit and integration testing levels.</li>
<li>Cannot reveal missing functionalities.</li>
<li>Does not work for systems or components.</li>
</ul>
</li>
</ul>
<p><strong>Visual Representation:</strong></p>
<ul>
<li><strong>System:</strong> Represents the overall software.</li>
<li><strong>Specification:</strong> Represents the documented requirements.</li>
<li><strong>Implementation:</strong> Represents the actual code.</li>
</ul>
<p><strong>Key Takeaway:</strong>  Functional and structural testing are complementary approaches that can be used together to improve test coverage and uncover different types of defects.</p>
<h2>Test Model Criterion</h2>
<ul>
<li><strong>Definition:</strong>  A criterion C defines a set of requirements or objectives for a test model M.</li>
<li><strong>Coverage Ratio:</strong> The proportion of elements in M defined by C that are covered by a test set T.</li>
<li><strong>C-Adequacy:</strong> A test set T is considered C-adequate when the coverage ratio reaches 100% for criterion C.</li>
</ul>
<p><strong>Examples:</strong></p>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>M:</strong>  Control flow graph of a function.</li>
<li><strong>C:</strong>  "All the statements" criterion.</li>
<li><strong>Test Set T:</strong>  Exercises 5 out of 8 statements (62.5% coverage).</li>
<li><strong>Adequacy:</strong> The test suite is not adequate for the all-statements criterion.</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>M:</strong> Set of use case scenarios.</li>
<li><strong>C:</strong>  "All the scenarios" criterion.</li>
<li><strong>Test Set T:</strong> Exercises 12 out of 12 scenarios (100% coverage).</li>
<li><strong>Adequacy:</strong> The test suite is adequate for the all-scenarios criterion, and is all-scenarios adequate.</li>
</ul>
<p><strong>Revised Notion of Adequacy:</strong></p>
<ul>
<li><strong>Feasible Elements:</strong>  The coverage ratio considers only the <em>feasible</em> elements in M defined by C.</li>
<li><strong>C-Adequacy:</strong>  A test set T is C-adequate when the coverage ratio achieves 100% for criterion C, considering only feasible elements.</li>
</ul>
<h2>Theoretical Hierarchy of Criteria</h2>
<ul>
<li><strong>Subsumption Relation:</strong> For a model M, criterion C1 subsumes C2 if any C1-adequate test set is also C2-adequate.</li>
<li><strong>Important Note:</strong> Subsumption is <em>not</em> a subset relation.</li>
</ul>
<p><strong>Example:</strong></p>
<ul>
<li><strong>Model M:</strong> Finite state machines.</li>
<li><strong>C1:</strong> "All-paths" criterion.</li>
<li><strong>C2:</strong> "All-transitions" criterion.</li>
<li><strong>Subsumption:</strong> Any all-paths adequate test suite necessarily exercises all the transitions, making C1 subsume C2.</li>
</ul>
<p><strong>Consequences of Subsumption:</strong></p>
<ul>
<li><strong>Satisfying C1:</strong> Usually more expensive than satisfying C2 (e.g., requires more test cases).</li>
<li><strong>C1-Adequate Test Suite:</strong>  Tends to detect more faults than a C2-adequate test suite.</li>
</ul>
<h2>Two Ways to Use Test Criteria</h2>
<ol>
<li>
<p><strong>Generate Test Values/Test Cases:</strong></p>
</li>
<li>
<p><strong>Criterion Type:</strong> Selection criterion.</p>
</li>
<li><strong>Tool:</strong> A <em>generator</em> (tool or human) that automatically produces values to satisfy the criterion.</li>
<li>
<p><strong>Goal:</strong> Create a (software) generator?</p>
</li>
<li>
<p><strong>Evaluate Coverage:</strong></p>
</li>
<li>
<p><strong>Criterion Type:</strong> Coverage criterion.</p>
</li>
<li><strong>Tool:</strong> A <em>recognizer</em> (tool or human) that automatically determines whether a set of values satisfies a criterion.</li>
<li><strong>Goal:</strong> Create a (software) recognizer?</li>
</ol>
<h2>Problems with Test Criteria Generation and Evaluation</h2>
<ul>
<li><strong>Undecidability:</strong> Both generating test values and evaluating coverage are <strong>provably undecidable</strong> for most criteria.</li>
<li><strong>Implications:</strong>  No single algorithm can always find a correct solution for these problems.</li>
<li><strong>Easier Alternative:</strong>  Creating a <em>recognizer</em> is often easier than building a <em>generator</em>.</li>
<li><strong>Availability:</strong> Coverage analysis tools (recognizers) are readily available.</li>
</ul>
<h2>Miss-use of Terminology: "Coverage"</h2>
<ul>
<li><strong>Caution:</strong> Misuse of the term "coverage" is common.</li>
<li>
<p><strong>Example Scenarios:</strong></p>
<ul>
<li>
<p><strong>Scenario 1:</strong> "I am checking what my tests exercise with the all-statements selection criterion."</p>
</li>
<li>
<p><strong>Error:</strong>  The speaker is actually using the all-statements criterion as a <em>recognizer</em> to evaluate coverage, not as a <em>generator</em> to create test cases.</p>
</li>
<li>
<p><strong>Scenario 2:</strong> "I am creating tests with the all-scenarios coverage criterion."</p>
</li>
<li>
<p><strong>Error:</strong> The speaker is using the all-scenarios criterion as a <em>generator</em>, not a <em>recognizer</em>.</p>
</li>
<li>
<p><strong>Scenario 3:</strong> "I am doing structural testing since I check my tests execute all statements."</p>
</li>
<li>
<p><strong>Error:</strong> Structural testing uses a selection criterion to generate tests based on the implementation. The speaker is using the criterion as a <em>recognizer</em> to evaluate coverage.</p>
</li>
<li>
<p><strong>Scenario 4:</strong> "My tests achieve 100% coverage."</p>
</li>
<li>
<p><strong>Error:</strong>  This statement lacks context. "100% coverage" can mean very different things depending on the criterion used. </p>
</li>
</ul>
</li>
<li>
<p><strong>Key Takeaway:</strong>  Clarify which type of criterion is being used (selection or coverage) to avoid confusion and ensure accurate understanding of test coverage.</p>
</li>
</ul>
<h2>Using a Test Selection Criterion</h2>
<p><strong>Steps:</strong></p>
<ol>
<li><strong>Choose a Test Model:</strong> Define the representation of the software under test (e.g., state machine, control flow graph).</li>
<li><strong>Select a Test Criterion:</strong> Choose a criterion to guide test case generation (e.g., all-transitions).</li>
<li><strong>Identify Test Objectives:</strong>  Define the specific aspects of the model that should be exercised (e.g., transitions in a state machine).</li>
<li><strong>Create Test Case Specifications:</strong>  Write down the test cases that will satisfy the objectives.</li>
<li><strong>Identify Test Data/Input:</strong>  Determine the input values needed to execute each test case.</li>
<li><strong>Identify Oracle:</strong> Define the expected outcomes for each test case.</li>
</ol>
<p><strong>Example:</strong></p>
<p><strong>Test Model:</strong> State machine.
<strong>Criterion:</strong> All-transitions.
<strong>Objectives:</strong> Exercise all transitions.
<strong>Test Case Specifications:</strong>
    - Test case 1: Exercise transitions t1, t4, t5.
    - Test case 2: Exercise transitions t1, t2, t8. 
<strong>Test Data/Input:</strong>
    - Test case 1: Input value 10.
    - Test case 2: Input value 20.
<strong>Oracle:</strong> Define the expected state changes and outputs for each test case.</p>
<h2>Example (Graph) Model</h2>
<ul>
<li><strong>Software:</strong> A vending machine.</li>
<li><strong>Functionality:</strong><ul>
<li>Accepts 5p or 10p coins.</li>
<li>Dispenses 15p cans.</li>
</ul>
</li>
<li><strong>Test Model:</strong> A state machine with states Got0, Got5, and Got10.</li>
<li><strong>Criterion:</strong> All-transitions.</li>
<li><strong>Objectives:</strong> Exercise all possible transitions between states.</li>
<li><strong>Test Case Specifications:</strong><ul>
<li>TCS1: [Got0, Got5, Got10]</li>
<li>TCS2: [Got0, Got10, Got0]</li>
<li>TCS3: [Got0, Got10, Got5, Got0]</li>
</ul>
</li>
<li><strong>Test Data/Input:</strong><ul>
<li>TC1: [5p, 5p]</li>
<li>TC2: [10p, 5p]</li>
<li>TC3: [10p, 10p, 10p]</li>
</ul>
</li>
<li><strong>Oracles:</strong><ul>
<li>TC1:  Machine has 10p in, no cans dispensed.</li>
<li>TC2:  Machine has 0p in, one can dispensed.</li>
<li>TC3:  Machine has 0p in, two cans dispensed.</li>
</ul>
</li>
</ul>
<h2>Marick's Recommendation</h2>
<p><strong>Brian Marick's Approach to Software Testing:</strong></p>
<ol>
<li>
<p><strong>Functional Test Generation:</strong></p>
<ul>
<li>Create functional tests based on requirements and design.</li>
<li>Aim to exercise every function.</li>
<li>Use a <em>functional selection criterion</em> (generator) to generate these tests.</li>
</ul>
</li>
<li>
<p><strong>Structural Coverage Evaluation:</strong></p>
<ul>
<li>After executing functional tests, evaluate structural coverage.</li>
<li>Use a <em>structural coverage criterion</em> (recognizer) to analyze the test results.</li>
</ul>
</li>
<li>
<p><strong>Functional Test Augmentation:</strong></p>
<ul>
<li>If structural coverage is incomplete, create additional functional tests (not structural tests) to achieve desired coverage.</li>
</ul>
</li>
</ol>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Form Follows Function:</strong>  Code structure should reflect its intended functionality.</li>
<li><strong>Uncovered Code:</strong>  Uncovered code likely has a purpose that has not been invoked, indicating an untested function.</li>
</ul>
<h2>Test Criteria Based on Structure [Offutt]</h2>
<p><strong>Types of Structural Test Criteria:</strong></p>
<ul>
<li>
<p><strong>Graphs:</strong></p>
<ul>
<li><strong>Elements:</strong>  Method body, method calls, component interactions, state transitions.</li>
<li><strong>Example:</strong> Control flow graph of a function or a state machine.</li>
</ul>
</li>
<li>
<p><strong>Logical Expressions:</strong></p>
<ul>
<li><strong>Elements:</strong> Logical operators (AND, OR, NOT) and operands.</li>
<li><strong>Context:</strong> Can appear in state machines, source code, or software specifications.</li>
<li><strong>Example:</strong>  <code>(not X or not Y) and (A and B)</code>.</li>
</ul>
</li>
<li>
<p><strong>Input Domain Characterization:</strong></p>
<ul>
<li><strong>Elements:</strong>  Input values.</li>
<li><strong>Context:</strong> Describes the range of input values for a method, component, or system.</li>
<li><strong>Example:</strong><ul>
<li>A: <code>{0, 1, &gt; 1}</code> (integer values)</li>
<li>B: <code>{600, 700, 800}</code> (integer values)</li>
<li>C: <code>{swe, cs, isa, infs}</code> (string values)</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Syntactic Structures:</strong></p>
<ul>
<li><strong>Elements:</strong> Syntax of programming language constructs.</li>
<li><strong>Context:</strong> Based on a grammar or other syntactic definition.</li>
<li><strong>Example:</strong> Mutation testing (changing a line of code to see if it breaks the functionality).</li>
</ul>
</li>
</ul>
<h2>Test Criteria - Graphs</h2>
<ul>
<li><strong>Example:</strong>  A control flow graph of a function.</li>
<li><strong>Key Elements:</strong> Nodes represent statements or decisions, edges represent control flow.</li>
<li><strong>Applications:</strong> Testing branches, loops, and other structural aspects of code.</li>
</ul>
<h2>Test Criteria - Logic Expressions</h2>
<ul>
<li><strong>Example:</strong>  A boolean expression like <code>a(b+c)d + e</code>.</li>
<li><strong>Applications:</strong>  Testing the logic of conditional statements, complex calculations, and data flow.</li>
</ul>
<h2>Test Criteria - Input Domain Characterization</h2>
<ul>
<li><strong>Example:</strong>  Identifying input values for a function that handles file names.</li>
<li><strong>Applications:</strong>  Testing edge cases, boundary conditions, and the handling of different data types.</li>
</ul>
<h2>Test Criteria - Syntactic Structures</h2>
<ul>
<li><strong>Example:</strong>  Mutation testing, where small changes are made to the code to see if they trigger errors.</li>
<li><strong>Applications:</strong>  Testing the robustness and correctness of code by introducing intentional errors.</li>
</ul>
        </div>

        <button class="collapsible">Keywords and Definitions</button>
        <div class="content">
            <h1>Glossary of Key Terms and Concepts</h1>
<p>This glossary provides definitions for key terms and concepts from the lecture document, "Definitions-Part II", on software testing.</p>
<ul>
<li><strong>Adequate</strong> : A test set is said to be adequate for a test criterion when the coverage ratio achieves 100% for that criterion.</li>
<li><strong>All-paths</strong> : A test criterion that requires all possible paths through a program to be executed at least once.</li>
<li><strong>All-transitions</strong> : A test criterion that requires all possible transitions in a state machine to be executed at least once.</li>
<li><strong>Coverage ratio</strong> : The proportion of the elements in a test model that are covered by a test set.</li>
<li><strong>Exhaustive testing</strong> : Testing using all possible inputs. This is typically impossible for real-world software.</li>
<li><strong>Feasible</strong> : A test requirement is considered feasible if it is possible to create a test case that satisfies it.</li>
<li><strong>Functional testing</strong> : A type of testing that focuses on verifying the functionality of software based on the specifications. </li>
<li><strong>Generator</strong> : A tool (or human) that automatically generates test values or test cases to satisfy a selection criterion.</li>
<li><strong>Recognizer</strong> : A tool (or human) that automatically decides whether a set of values satisfies a test criterion.</li>
<li><strong>Selection criterion</strong> : A test criterion used to generate test cases. </li>
<li><strong>Structural testing</strong> : A type of testing that focuses on verifying the structure of software, such as the control flow graph.</li>
<li><strong>Subsumes</strong> : In the context of test criteria, C1 subsumes C2 if any C1-adequate test set is also C2-adequate.</li>
<li><strong>Test criterion</strong> : A specific rule or guideline that defines the requirements for an adequate test suite.</li>
<li><strong>Test model</strong> : A representation of the software system being tested. It can be a graph, a state machine, or other types of models.</li>
<li><strong>Test objectives</strong> : The specific goals that a test suite is designed to achieve. These objectives are typically derived from the software requirements. </li>
</ul>
        </div>

        <button class="collapsible">Review Questions</button>
        <div class="content">
    <h3>Q: What is exhaustive testing?</h3><p>A: Exhaustive testing refers to executing a program or software component with every possible input combination. It aims to cover all conceivable scenarios, ensuring that the software behaves correctly under all circumstances.</p><h3>Q: Why is exhaustive testing often impossible?</h3><p>A: Exhaustive testing is often impossible due to the vast number of potential inputs, especially for complex systems or programs. The number of test cases grows exponentially with the complexity of the software, making it impractical to cover all possible combinations.</p><h3>Q: What is the technique used to reduce the number of inputs required for testing?</h3><p>A: Testing criteria group input elements into equivalence classes, where each class represents a set of similar inputs. This strategy helps reduce the number of test cases required while ensuring that the software is thoroughly tested.</p><h3>Q: What are test objectives?</h3><p>A: Test objectives, also known as requirements, are the goals or expectations that the software must meet. They define what aspects of the software need to be verified during testing.</p><h3>Q: What is structural testing?</h3><p>A: Structural testing focuses on the internal structure of the software, examining its control flow, data flow, and implementation details. It is commonly used to assess the completeness and coverage of the code.</p><h3>Q: What is functional testing?</h3><p>A: Functional testing focuses on the functionality of the software, ensuring that it meets the specified requirements and behaves as intended. It is often used to verify the correctness of the software's behavior from a user perspective.</p><h3>Q: How do structural and functional testing differ in terms of their applicability at different testing levels?</h3><p>A: Structural testing is often applied at the unit and integration testing levels, while functional testing is more scalable and can be used at various levels, from individual functions to entire systems.</p></div>
        <button class="collapsible">Practice Exam</button>
        <div class="content">
        <h2>SYSC 4101 / SYSC 5105:  Practice Exam - Definitions - Part II</h2>
<p><strong>Instructions:</strong> Please answer all questions to the best of your ability.  Show your work where applicable.  </p>
<p><strong>Multiple Choice (5 points each):</strong></p>
<ol>
<li>
<p><strong>Which of the following best describes exhaustive testing?</strong>
    a.  Testing using all possible inputs, which is often impossible. 
    b.  Testing using a limited set of inputs, but ensuring all critical paths are covered.
    c.  Testing by focusing on specific input values that are likely to cause errors.
    d.  Testing based on the developer's understanding of the code's internal structure.</p>
</li>
<li>
<p><strong>Which of the following is NOT a benefit of functional testing?</strong>
    a.  It can be scaled up to different levels of granularity.
    b.  It directly verifies the system's compliance with the specifications.
    c.  It can reveal missing functionalities.
    d.  It works well for testing at all levels of granularity, from unit to system.</p>
</li>
<li>
<p><strong>What is a test criterion?</strong>
    a.  A specific input value used to test a function.
    b.  A set of requirements or objectives that must be satisfied by a test suite.
    c.  A tool that automatically generates test cases.
    d.  A method used to analyze the coverage of a test suite.</p>
</li>
<li>
<p><strong>What does it mean for a test criterion C1 to "subsume" another criterion C2?</strong>
    a.  Any test case that satisfies C2 will also satisfy C1.
    b.  Any test case that satisfies C1 will also satisfy C2.
    c.  C1 and C2 are equivalent and provide the same level of testing.
    d.  C1 and C2 are completely unrelated and have no overlap in coverage.</p>
</li>
<li>
<p><strong>Which of the following best describes the difference between a "generator" and a "recognizer" in the context of test criteria?</strong>
    a.  A generator analyzes the coverage of existing test cases, while a recognizer creates test cases.
    b.  A generator creates test cases to satisfy a criterion, while a recognizer checks whether a set of test cases satisfies a criterion.
    c.  A generator is a tool for structural testing, while a recognizer is a tool for functional testing.
    d.  A generator is used for black-box testing, while a recognizer is used for white-box testing.</p>
</li>
</ol>
<p><strong>Short Answer (10 points each):</strong></p>
<ol>
<li>Explain the difference between functional testing and structural testing.</li>
<li>Briefly describe the "coverage ratio" in the context of test criteria.  </li>
<li>Why does Brian Marick recommend starting with functional tests and then checking structural coverage?</li>
</ol>
<p><strong>Long Answer/Essay (20 points each):</strong></p>
<ol>
<li>Explain the concept of "test model criteria" and give two examples.  Discuss the challenges associated with using test model criteria in practice.</li>
<li>Describe the four categories of structural test criteria discussed in the lecture.  Provide examples of each category.</li>
</ol>
<p><strong>Answer Key:</strong></p>
<p><strong>Multiple Choice:</strong></p>
<ol>
<li>
<p><strong>a. Testing using all possible inputs, which is often impossible.</strong> </p>
<ul>
<li>Explanation: Exhaustive testing aims to cover all possible input combinations, but this is often impractical or impossible due to the vast number of potential inputs.</li>
</ul>
</li>
<li>
<p><strong>c. It can reveal missing functionalities.</strong> </p>
<ul>
<li>Explanation:  Functional testing focuses on verifying the expected behavior of the system based on the specifications.  It doesn't delve into the internal structure, so it may not detect functionalities that are not explicitly mentioned in the specifications.</li>
</ul>
</li>
<li>
<p><strong>b. A set of requirements or objectives that must be satisfied by a test suite.</strong> </p>
<ul>
<li>Explanation: A test criterion defines the criteria for deeming a test suite adequate. It outlines the specific requirements or objectives that a test suite should achieve.</li>
</ul>
</li>
<li>
<p><strong>b. Any test case that satisfies C1 will also satisfy C2.</strong> </p>
<ul>
<li>Explanation: Subsumption means that if a test suite satisfies the more comprehensive criterion C1, it automatically satisfies the less comprehensive criterion C2.  </li>
</ul>
</li>
<li>
<p><strong>b. A generator creates test cases to satisfy a criterion, while a recognizer checks whether a set of test cases satisfies a criterion.</strong> </p>
<ul>
<li>Explanation: Generators are used to create test cases that meet the requirements of a specific criterion, while recognizers are used to analyze existing test cases and determine if they adequately satisfy a particular criterion.</li>
</ul>
</li>
</ol>
<p><strong>Short Answer:</strong></p>
<ol>
<li>
<p><strong>Functional testing focuses on verifying the system's behavior according to the specifications, while structural testing focuses on ensuring that all parts of the code have been exercised.</strong> </p>
<ul>
<li>Explanation: Functional testing considers the system's external behavior and ensures it behaves as expected based on the requirements.  Structural testing, on the other hand, delves into the internal structure of the code and aims to execute all branches and paths within the code.</li>
</ul>
</li>
<li>
<p><strong>The coverage ratio is the proportion of elements within a test model that are covered by a given test suite, based on a specific test criterion.</strong> </p>
<ul>
<li>Explanation: It represents the degree to which a test suite effectively exercises elements defined by the test criterion.  A high coverage ratio indicates a more comprehensive test suite.</li>
</ul>
</li>
<li>
<p><strong>Marick recommends starting with functional tests because they ensure the system's basic functionalities are working as expected, and then checking structural coverage to identify any potentially untested code.</strong> </p>
<ul>
<li>Explanation: This approach prioritizes the essential functionality of the system before delving into the structural details.  Untested code likely represents unimplemented functionality, and this method helps ensure that all essential functions are working correctly before exploring potentially redundant or unnecessary code paths.</li>
</ul>
</li>
</ol>
<p><strong>Long Answer/Essay:</strong></p>
<ol>
<li>
<p><strong>Test model criteria are used to specify how effectively a test suite covers a specific aspect of a test model. They define the requirements that a test suite must satisfy to be considered adequate for that model. For example, a test criterion for a finite state machine might be to execute all transitions or all paths within the state machine.</strong> </p>
<ul>
<li>Examples:<ul>
<li><strong>All-statements criterion:</strong> Ensure that every statement within a function or code block is executed at least once.</li>
<li><strong>All-branches criterion:</strong> Ensure that every branch within a conditional statement is executed at least once.</li>
</ul>
</li>
<li>Challenges:<ul>
<li><strong>Deciding which criteria are most important:</strong> There are often multiple criteria that could be used to evaluate a test suite.  Selecting the most relevant criteria requires careful consideration of the specific context and risks.</li>
<li><strong>Determining the feasibility of a criterion:</strong>  Not all criteria are practical or feasible in all situations.  For example, executing all possible paths through a complex program might be impossible or impractical.</li>
<li><strong>Measuring coverage accurately:</strong>  Accurate measurement of coverage can be challenging for complex systems.  This can lead to inaccurate assessments of test suite adequacy.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>The four categories of structural test criteria are graphs, logical expressions, input domain characterization, and syntactic structures.</strong> </p>
<ul>
<li><strong>Graphs:</strong> Criteria based on graphs can be used to ensure that all elements within a state machine, control flow graph, or other graph-based representation are tested.  <ul>
<li>Example: All-transitions criterion for a state machine ensures every transition between states is executed at least once.</li>
</ul>
</li>
<li><strong>Logical Expressions:</strong> These criteria focus on the logical expressions within the code.  <ul>
<li>Example:  A criterion could require that all possible Boolean combinations of variables within a conditional statement are tested.</li>
</ul>
</li>
<li><strong>Input Domain Characterization:</strong>  This approach considers the set of all possible inputs that the system can accept.  <ul>
<li>Example: Testing boundary values and different combinations of input parameters to ensure the system handles all valid and invalid inputs correctly.</li>
</ul>
</li>
<li><strong>Syntactic Structures:</strong>  These criteria focus on the syntactic structure of the code, such as the grammar or specific code patterns.<ul>
<li>Example: Mutation testing, where small, intentional changes are made to the code to see if the test suite can detect them. </li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Please note: this is a comprehensive practice exam designed to assess understanding of the key concepts from the lecture material.  It is not intended to be an exhaustive representation of all possible exam questions.</p></div>
        <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                } 
            });
        }
        </script>
    </body>
    </html>
    