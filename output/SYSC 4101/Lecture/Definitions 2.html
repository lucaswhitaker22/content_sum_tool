
    <html>
    <head>
        <title>Definitions 2</title>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                line-height: 1.6; 
                padding: 20px; 
                background-color: #f9f9f9; 
                color: #333; 
            }
            h1 { 
                text-align: center; 
                color: #4CAF50; 
            }
            h2, h3 { 
                color: #333; 
                margin-top: 20px; 
            }
            p { 
                margin: 10px 0; 
            }
            .collapsible { 
                background-color: #4CAF50; 
                color: white; 
                cursor: pointer; 
                padding: 15px; 
                width: 100%; 
                border: none; 
                text-align: left; 
                outline: none; 
                font-size: 16px; 
                border-radius: 5px;
                transition: background-color 0.3s;
            }
            .collapsible:hover { 
                background-color: #45a049; 
            }
            .collapsible:after {
                content: '\002B';
                color: white;
                font-weight: bold;
                float: right;
                margin-left: 5px;
            }
            .active:after {
                content: "\2212";
            }
            .content {
                padding: 0 15px;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.2s ease-out;
                background-color: #e7f3fe;
                border-left: 5px solid #4CAF50;
                margin-bottom: 20px;
                border-radius: 5px;
            }
            dl {
                margin-left: 20px;
            }
            dt {
                font-weight: bold;
                margin-top: 10px;
            }
            dd {
                margin-left: 20px;
                margin-bottom: 10px;
            }
        </style>
    </head>
    <body>
        <h1>Definitions 2</h1>
        <p><strong>Course:</strong> SYSC 4101</p>
        <p><strong>Date:</strong> 2024-09-17 00:00:00</p>
        <p><strong>Overview:</strong> This lecture focuses on test model criteria, a crucial aspect of software testing. It delves into the concept of exhaustive testing and explores techniques to reduce the number of test cases. The lecture then introduces two primary testing approaches: functional testing, which checks conformance with specifications, and structural testing, which examines the control flow and data flow of the system. It emphasizes the importance of selecting appropriate test criteria based on the testing objectives and the model being tested. The lecture also discusses the theoretical hierarchy of criteria, highlighting the subsumption relation between criteria and its implications for test suite adequacy. Finally, it explores two ways to utilize test criteria: generating test cases to satisfy the criterion and evaluating the coverage achieved by externally generated test cases. The lecture concludes by addressing the challenges associated with creating generators and recognizers for test criteria and presents Marick's recommendation for a practical approach to testing.</p>
        <p><strong>Topics:</strong></p>
        <ul><li>Exhaustive Testing</li><li>Test Data Selection</li><li>Functional vs. Structural Testing</li><li>Test Model Criterion</li><li>Theoretical Hierarchy of Criteria</li><li>Two Ways to Use Test Criteria</li><li>Miss-use of Terminology</li><li>Using a Test Selection Criterion</li><li>Test Criteria Based on Structure</li><li>Test Criteria - Graphs</li><li>Test Criteria - Logic Expressions</li><li>Test Criteria - Input Domain Characterization</li><li>Test Criteria - Syntactic Structure</li></ul>
        <button class="collapsible">Lecture Notes</button>
        <div class="content">
            <h1>SYSC 4101 / SYSC 5105: Definitions—Part II</h1>
<h2>Exhaustive Testing</h2>
<h3>Definition</h3>
<ul>
<li><strong>Exhaustive testing</strong> involves testing a program with all possible inputs.</li>
<li>This approach is most of the time impossible due to the vast number of potential inputs.</li>
</ul>
<h3>Examples</h3>
<ul>
<li><strong>Factorial Function</strong>: Testing a program that computes the factorial function (<code>n = n * (n-1) * (n-2) * ... * 1</code>) would require running the program with all possible integer values, which is impractical.</li>
<li><strong>Compiler</strong>: Exhaustive testing for a compiler, such as <code>javac</code>, would involve compiling every possible Java program, which is clearly infeasible.</li>
</ul>
<h3>Reducing Test Cases</h3>
<ul>
<li>To manage the number of inputs, testing criteria are used to group input elements into <strong>equivalence classes</strong>.</li>
<li>One input is selected from each class.</li>
<li>Criteria help decide which test inputs to use and when to stop testing.</li>
</ul>
<h2>Test Data Selection Procedure</h2>
<h3>Software Representation</h3>
<ul>
<li>The test model can represent either the <strong>specification</strong> (Functional Testing) or the <strong>implementation</strong> (Structural Testing).</li>
</ul>
<h4>Functional Testing</h4>
<ul>
<li>Focuses on checking conformance with the specification.</li>
<li><strong>Example</strong>: Testing a vending machine based on its functional requirements.</li>
</ul>
<h4>Structural Testing</h4>
<ul>
<li>Focuses on the internal structure of the software.</li>
<li><strong>Example</strong>: Testing based on the control flow graph of a function.</li>
</ul>
<h3>Steps in Test Data Selection</h3>
<ol>
<li><strong>Choose a Test Model</strong></li>
<li>
<p>Select a model that represents either the specification or the implementation.</p>
</li>
<li>
<p><strong>Select a Test Criterion</strong></p>
</li>
<li>
<p>Choose a criterion associated with the test model (e.g., all-statements, all-transitions).</p>
</li>
<li>
<p><strong>Identify Test Objectives</strong></p>
</li>
<li>
<p>Determine what needs to be exercised in the model (e.g., transitions, statements).</p>
</li>
<li>
<p><strong>Create Test Case Specifications</strong></p>
</li>
<li>
<p>Define specific test cases that meet the test objectives.</p>
</li>
<li>
<p><strong>Identify Test Data/Input</strong></p>
</li>
<li>
<p>Determine the input values needed to execute each test case.</p>
</li>
<li>
<p><strong>Identify Oracle</strong></p>
</li>
<li>Define what is expected during and after the execution of each test case.</li>
</ol>
<h2>Functional vs. Structural Testing</h2>
<h3>Functional Testing</h3>
<ul>
<li><strong>Pros</strong>:</li>
<li>Checks conformance with the specification.</li>
<li>Scales up to different granularity levels (function, class, package, system).</li>
<li><strong>Cons</strong>:</li>
<li>Depends on the detail of the specification.</li>
<li>Does not reveal how much of the system code is being tested.</li>
<li>Cannot detect unexpected functionalities.</li>
</ul>
<h3>Structural Testing</h3>
<ul>
<li><strong>Pros</strong>:</li>
<li>Based on control and data flow criteria.</li>
<li>Allows confidence in how much of the system is being tested.</li>
<li><strong>Cons</strong>:</li>
<li>Does not scale up well beyond unit and integration testing levels.</li>
<li>Cannot reveal missing functionalities.</li>
<li>Does not work for packages/components or systems.</li>
</ul>
<h2>Test Model Criterion</h2>
<h3>Coverage Ratio</h3>
<ul>
<li>Given a criterion <code>C</code> for a model <code>M</code>, the coverage ratio of a test set <code>T</code> is the proportion of elements in <code>M</code> defined by <code>C</code> that are covered by <code>T</code>.</li>
<li>A test set <code>T</code> is <strong>C-adequate</strong> when the coverage ratio achieves 100% for criterion <code>C</code>.</li>
</ul>
<h3>Examples</h3>
<ul>
<li><strong>Control Flow Graph</strong>: A test suite exercises 5 out of 8 statements, achieving 62.5% coverage.</li>
<li>The test suite is not adequate for the all-statements criterion.</li>
<li><strong>Use Case Scenarios</strong>: A test suite exercises all 12 scenarios, achieving 100% coverage.</li>
<li>The test suite is adequate for the all-scenarios criterion.</li>
</ul>
<h2>Revised Notion of Adequacy</h2>
<ul>
<li>When not all test requirements are feasible, the coverage ratio is calculated based on feasible elements.</li>
<li>A test set <code>T</code> is <strong>C-adequate</strong> when it covers 100% of the feasible elements defined by <code>C</code>.</li>
</ul>
<h2>Theoretical Hierarchy of Criteria</h2>
<h3>Subsumption Relation</h3>
<ul>
<li>For a given model <code>M</code>, criterion <code>C1</code> subsumes <code>C2</code> if any <code>C1</code>-adequate test set is also <code>C2</code>-adequate.</li>
<li><strong>Example</strong>: For finite state machines, the all-paths criterion subsumes the all-transitions criterion.</li>
</ul>
<h3>Implications</h3>
<ul>
<li>Satisfying <code>C1</code> tends to be more expensive than satisfying <code>C2</code>.</li>
<li>A <code>C1</code>-adequate test suite tends to detect more faults than a <code>C2</code>-adequate test suite.</li>
</ul>
<h2>Using Test Criteria</h2>
<h3>Two Ways to Use Test Criteria</h3>
<ol>
<li><strong>Generate Test Values/Test Cases</strong></li>
<li>Use a criterion as a selection criterion to generate values that satisfy the criterion.</li>
<li>Need a generator tool or human to create these values.</li>
<li><strong>Evaluate Coverage</strong></li>
<li>Use a criterion as a coverage criterion to evaluate the coverage achieved by externally generated test values/test cases.</li>
<li>Need a recognizer tool or human to decide whether a set of values satisfies a criterion.</li>
</ol>
<h3>Problems and Issues</h3>
<ul>
<li>Creating generators and recognizers is often undecidable for most criteria.</li>
<li>However, it is generally easier to build recognizers than generators.</li>
<li>Coverage analysis tools (recognizers) are more plentiful.</li>
</ul>
<h2>Misuse of Terminology</h2>
<ul>
<li>Beware of misusing terms like “coverage”:</li>
<li><strong>Example</strong>: Using the all-statements criterion in a recognizer context instead of a generator context.</li>
</ul>
<h2>Using a Test Selection Criterion</h2>
<h3>Steps</h3>
<ol>
<li><strong>Choose a Test Model</strong></li>
<li><strong>Select a Test Criterion</strong></li>
<li><strong>Identify Test Objectives</strong></li>
<li><strong>Create Test Case Specifications</strong></li>
<li><strong>Identify Test Data/Input</strong></li>
<li><strong>Identify Oracle</strong></li>
</ol>
<h3>Example</h3>
<ul>
<li><strong>State Machine</strong>:</li>
<li>Choose a state machine as the test model.</li>
<li>Select the all-transitions criterion.</li>
<li>Identify transitions as test objectives.</li>
<li>Create test case specifications to exercise these transitions.</li>
<li>Identify input values to execute each test case.</li>
<li>Define what to check during and after execution (oracle).</li>
</ul>
<h2>Marick’s Recommendation</h2>
<h3>Approach</h3>
<ol>
<li><strong>Generate Functional Tests</strong></li>
<li>Generate tests from requirements and design to try every function using a functional selection criterion.</li>
<li><strong>Check Structural Coverage</strong></li>
<li>Check the structural coverage after functional tests are verified.</li>
<li><strong>Generate Additional Functional Tests</strong></li>
<li>Generate functional tests to induce additional coverage where structural coverage is imperfect.</li>
</ol>
<h2>Test Criteria Based on Structure [Offutt]</h2>
<h3>Types of Test Criteria</h3>
<ul>
<li><strong>Graphs</strong>: State machines, control flow graphs.</li>
<li><strong>Logical Expressions</strong>: Conditional statements, loops.</li>
<li><strong>Input Domain Characterization</strong>: Describes the input domain of the software under test.</li>
<li><strong>Syntactic Structures</strong>: Based on grammar or other syntactic definitions (e.g., mutation testing).</li>
</ul>
<h3>Examples</h3>
<ul>
<li><strong>State Machine</strong>: Testing transitions in a vending machine.</li>
<li><strong>Logical Expressions</strong>: Testing conditional statements in a compiler.</li>
<li><strong>Input Domain Characterization</strong>: Testing input ranges for a method.</li>
<li><strong>Syntactic Structures</strong>: Mutation testing based on syntactic rules.</li>
</ul>
<h2>Case Studies</h2>
<h3>Vending Machine</h3>
<ul>
<li><strong>Specification</strong>: Gets 5p or 10p coins, sells 15p cans.</li>
<li><strong>Test Model</strong>: State machine representing the vending machine's states.</li>
<li><strong>Test Criterion</strong>: All-transitions.</li>
<li><strong>Test Case Specifications</strong>: Define sequences of transitions to test.</li>
<li><strong>Test Data/Input</strong>: Input values (coins) to execute each test case.</li>
<li><strong>Oracle</strong>: Expected outcomes (cans dispensed or not).</li>
</ul>
<h3>ATM System</h3>
<ul>
<li><strong>Feature</strong>: Transfer feature in an ATM system deployed as a Web service.</li>
<li><strong>Test Model</strong>: Use case scenarios or state machines representing the transfer process.</li>
<li><strong>Test Criterion</strong>: All-scenarios or all-transitions.</li>
<li><strong>Test Case Specifications</strong>: Define test cases to exercise these scenarios or transitions.</li>
<li><strong>Test Data/Input</strong>: Input values (user credentials, amounts) to execute each test case.</li>
<li><strong>Oracle</strong>: Expected outcomes (successful transfers, error messages).</li>
</ul>
<h3>TCAS System</h3>
<ul>
<li><strong>Feature</strong>: Collision avoidance system for aircraft.</li>
<li><strong>Test Model</strong>: State machines or control flow graphs representing the system's logic.</li>
<li><strong>Test Criterion</strong>: All-paths or all-transitions.</li>
<li><strong>Test Case Specifications</strong>: Define test cases to exercise these paths or transitions.</li>
<li><strong>Test Data/Input</strong>: Input values (aircraft positions, velocities) to execute each test case.</li>
<li><strong>Oracle</strong>: Expected outcomes (alerts, advisories).</li>
</ul>
<h2>Key Takeaways</h2>
<ul>
<li><strong>Exhaustive Testing is Impractical</strong>: It is generally impossible to test all possible inputs.</li>
<li><strong>Equivalence Classes</strong>: Group inputs into equivalence classes to reduce the number of test cases.</li>
<li><strong>Functional vs. Structural Testing</strong>: Functional testing checks conformance with specifications, while structural testing checks the internal structure of the software.</li>
<li><strong>Test Criteria</strong>: Use criteria to select and evaluate test cases; ensure clear understanding of generator and recognizer contexts.</li>
<li><strong>Marick’s Recommendation</strong>: Combine functional and structural testing approaches for comprehensive coverage.</li>
<li><strong>Case Studies</strong>: Apply test criteria and models to real-world systems like vending machines, ATM systems, and TCAS systems.</li>
</ul>
        </div>

        <button class="collapsible">Keywords and Definitions</button>
        <div class="content">
            <dl><dt><strong>Exhaustive Testing</strong></dt><dd>A testing technique that involves executing all possible combinations of inputs to a system.</dd><dt><strong>Functional Testing</strong></dt><dd>A testing approach that focuses on verifying the functionality of a system based on its specifications.</dd><dt><strong>Structural Testing</strong></dt><dd>A testing approach that focuses on examining the internal structure and code of a system to ensure it is implemented correctly.</dd><dt><strong>Test Model</strong></dt><dd>A representation of a system's behavior or implementation, used as a basis for designing test cases.</dd><dt><strong>Test Model Criterion</strong></dt><dd>A criterion used to define the coverage of a test suite, specifying the elements of a test model that must be exercised.</dd><dt><strong>Coverage Ratio</strong></dt><dd>The proportion of elements in a test model that are covered by a test suite, expressed as a percentage.</dd><dt><strong>C-adequate</strong></dt><dd>A test suite that satisfies all the requirements of a specific test model criterion.</dd><dt><strong>Subsumption</strong></dt><dd>A relationship between two test model criteria where a test suite that satisfies the first criterion also satisfies the second criterion.</dd><dt><strong>Generator</strong></dt><dd>A tool or process that automatically generates test cases based on a given test model criterion.</dd><dt><strong>Recognizer</strong></dt><dd>A tool or process that automatically determines whether a set of test cases satisfies a specific test model criterion.</dd><dt><strong>Logical Expressions</strong></dt><dd>A type of test model criterion that focuses on the logical expressions used in a system's code or specifications.</dd><dt><strong>Input Domain Characterization</strong></dt><dd>A type of test model criterion that focuses on the input domain of a system, defining the range of possible inputs.</dd><dt><strong>Syntactic Structures</strong></dt><dd>A type of test model criterion that focuses on the syntactic structure of a system's code, such as the grammar or other syntactic rules.</dd><dt><strong>Mutation Testing</strong></dt><dd>A testing approach that involves introducing small, controlled changes to a system's code and observing the effects.</dd><dt><strong>Functional Testing</strong></dt><dd>A testing approach that focuses on verifying the functionality of a system based on its requirements and design.</dd><dt><strong>Structural Testing</strong></dt><dd>A testing approach that focuses on examining the internal structure and code of a system to ensure it is implemented correctly.</dd></dl>
        </div>

        <button class="collapsible">Review Questions</button>
        <div class="content">
    <h3>Q: What is exhaustive testing, and why is it often impractical?</h3><p>A: Exhaustive testing aims to test all possible inputs, but it is often impractical or impossible due to the vast number of potential inputs.</p><h3>Q: How do equivalence classes help in reducing the number of test cases?</h3><p>A: Equivalence classes group similar inputs together, reducing the number of test cases needed while ensuring adequate coverage.</p><h3>Q: What are the key differences between functional and structural testing?</h3><p>A: Functional testing focuses on verifying the software's behavior against its specifications, while structural testing examines the internal structure and code paths.</p><h3>Q: What is a test model, and how does it relate to functional and structural testing?</h3><p>A: A test model represents either the specification or the implementation of the software, providing a framework for selecting test cases.</p><h3>Q: What is a test criterion, and what is its role in test design?</h3><p>A: A test criterion defines specific requirements or objectives that a test suite must satisfy to be considered adequate.</p><h3>Q: What is the coverage ratio, and how is it used to assess the adequacy of a test suite?</h3><p>A: The coverage ratio measures the proportion of elements in a test model that are covered by a test suite, indicating the extent to which the test suite exercises the model.</p><h3>Q: Explain the concept of subsumption between test criteria, and what are its implications for test design?</h3><p>A: A criterion C1 subsumes another criterion C2 if any test suite that satisfies C1 also automatically satisfies C2. This implies that C1 is generally more comprehensive and potentially more expensive to satisfy.</p></div>
        <button class="collapsible">Practice Exam</button>
        <div class="content">
        <h2>Short Answer Questions</h2><h3>Q: What is exhaustive testing, and why is it often impractical? Briefly describe techniques used to address this limitation.</h3><p>A: Exhaustive testing aims to test all possible inputs, but it is often impractical or impossible due to the vast number of potential inputs. Techniques like equivalence partitioning and boundary value analysis are used to reduce the number of test cases while still achieving adequate coverage.</p><h3>Q: What is a test criterion, and what are its primary uses in software testing?</h3><p>A: A test criterion specifies a set of requirements or objectives that must be met to achieve adequate test coverage. These criteria can be used to generate test cases or evaluate the coverage achieved by existing test cases.</p><h2>Long Answer Questions</h2><h3>Q: Explain the difference between functional and structural testing, highlighting their respective goals and approaches.</h3><p>A: Functional testing focuses on verifying that the software meets its specified requirements, while structural testing aims to ensure that all parts of the code are executed at least once. Functional testing is driven by the system's intended behavior, while structural testing is based on the internal structure of the code. Both approaches are valuable for different reasons and can be used in combination for comprehensive testing.</p><h2>Multiple Choice Questions</h2><h3>Q: Which test criterion aims to ensure that every statement in a function's control flow graph is executed at least once?</h3><ul><li>All-paths</li><li>All-transitions</li><li>All-statements</li></ul><p>Correct Answer: All-statements</p><p>Explanation: The all-statements criterion ensures that every statement in the control flow graph of a function is executed at least once during testing.</p><h3>Q: Which statement is generally true regarding the complexity of building test criteria recognizers and generators?</h3><ul><li>It is always easier to build a recognizer than a generator.</li><li>It is often easier to build a generator than a recognizer.</li><li>Both generators and recognizers are equally complex to build.</li><li>Building generators and recognizers is a trivial task for most criteria.</li></ul><p>Correct Answer: It is often easier to build a recognizer than a generator.</p><p>Explanation: Recognizers are tools that determine if a set of test values satisfies a given criterion, while generators create test values to satisfy the criterion. While both tasks can be challenging, building a recognizer is often considered less complex.</p><h3>Q: What is the revised definition of the coverage ratio of a test set T, taking into account the feasibility of test requirements?</h3><ul><li>The coverage ratio of a test set T is the proportion of the elements in M defined by C covered by T.</li><li>The coverage ratio of a test set T is the proportion of the elements in M covered by T.</li><li>The coverage ratio of a test set T is the proportion of the elements in C covered by T.</li><li>The coverage ratio of a test set T is the proportion of the elements in M defined by C that are not covered by T.</li></ul><p>Correct Answer: The coverage ratio of a test set T is the proportion of the feasible elements in M defined by C covered by T.</p><p>Explanation: This definition emphasizes that the coverage ratio considers only feasible elements, acknowledging that not all test requirements might be achievable in practice.</p><h3>Q: Which type of testing aims to ensure that all parts of the code are executed, often using criteria like all-statements or all-paths?</h3><ul><li>Functional testing</li><li>Structural testing</li><li>Black-box testing</li><li>White-box testing</li></ul><p>Correct Answer: Structural testing</p><p>Explanation: Structural testing focuses on ensuring that all parts of the code are executed, often using criteria like all-statements or all-paths. This approach is based on the internal structure of the code.</p><h3>Q: What concept describes the relationship between test criteria for the same model where one criterion implies the satisfaction of another?</h3><ul><li>The subset relation between criteria for the same model M</li><li>The equivalence relation between criteria for the same model M</li><li>The subsumption relation between criteria for the same model M</li><li>The intersection relation between criteria for the same model M</li></ul><p>Correct Answer: The subsumption relation between criteria for the same model M</p><p>Explanation: The subsumption relation helps understand the hierarchy of test criteria. If criterion C1 subsumes C2, then any test set that satisfies C1 will also satisfy C2.</p></div>
        <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                } 
            });
        }
        </script>
    </body>
    </html>
    