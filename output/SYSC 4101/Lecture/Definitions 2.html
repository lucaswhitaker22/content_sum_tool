
    <html>
    <head>
        <title>Definitions 2</title>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                line-height: 1.6; 
                padding: 20px; 
                background-color: #f9f9f9; 
                color: #333; 
            }
            h1 { 
                text-align: center; 
                color: #4CAF50; 
            }
            h2, h3 { 
                color: #333; 
                margin-top: 20px; 
            }
            p { 
                margin: 10px 0; 
            }
            .collapsible { 
                background-color: #4CAF50; 
                color: white; 
                cursor: pointer; 
                padding: 15px; 
                width: 100%; 
                border: none; 
                text-align: left; 
                outline: none; 
                font-size: 16px; 
                border-radius: 5px;
                transition: background-color 0.3s;
            }
            .collapsible:hover { 
                background-color: #45a049; 
            }
            .collapsible:after {
                content: '\002B';
                color: white;
                font-weight: bold;
                float: right;
                margin-left: 5px;
            }
            .active:after {
                content: "\2212";
            }
            .content {
                padding: 0 15px;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.2s ease-out;
                background-color: #e7f3fe;
                border-left: 5px solid #4CAF50;
                margin-bottom: 20px;
                border-radius: 5px;
            }
        </style>
    </head>
    <body>
        <h1>Definitions 2</h1>
        <p><strong>Course:</strong> SYSC 4101</p>
        <p><strong>Date:</strong> 2024-09-13</p>
        <p><strong>Overview:</strong> This lecture focuses on the concept of test model criteria, which are used to define the quality and adequacy of test cases. It explores different types of test criteria, including structural and functional criteria, and examines the challenges and trade-offs associated with using them.</p>
        <p><strong>Topics:</strong></p>
        <ul><li>Exhaustive Testing and Test Data Adequacy</li><li>Functional vs. Structural Testing</li><li>Test Model Criterion</li><li>Theoretical Hierarchy of Criteria</li><li>Two Ways to Use Test Criteria</li><li>Miss-use of Terminology</li><li>Using a Test Selection Criterion</li><li>Example of a Test Selection Criterion</li><li>Marick's Recommendation</li><li>Test Criteria Based on Structure</li><li>Test Criteria - Graphs</li><li>Test Criteria - Logic Expressions</li><li>Test Criteria - Input Domain Characterization</li><li>Test Criteria - Syntactic Structures</li></ul>
        <button class="collapsible">Lecture Notes</button>
        <div class="content">
            <h1>SYSC4101 / SYSC5105: Definitions - Part II</h1>
<h2>Exhaustive Testing</h2>
<ul>
<li><strong>Exhaustive testing</strong> - Testing using all possible inputs.<ul>
<li>Most of the time <strong>impossible!</strong></li>
</ul>
</li>
<li><strong>Examples:</strong><ul>
<li>A program that computes the factorial function (n! = n.(n-1).(n-2)...1)<ul>
<li>Exhaustive testing = running the program with 0, 1, ..., 100, ..., i.e., all possible integer values!</li>
</ul>
</li>
<li>A compiler (e.g., javac)<ul>
<li>Exhaustive testing = compiling every possible (Java) program</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Technique used to reduce the number of inputs (i.e., test cases):</strong></p>
<ul>
<li>Testing criteria group input elements into (equivalence) classes</li>
<li>One input is selected in each class (notion of test data adequacy)</li>
<li>Criteria are used to decide which test inputs to use</li>
<li>Criteria are used to decide when to stop testing</li>
</ul>
<h2>Test Data: Procedure to Select?</h2>
<ul>
<li><strong>Test model</strong> - A representation of the software.<ul>
<li><strong>Functional Testing</strong> - The test model is a representation of the specification.</li>
<li><strong>Structural Testing</strong> - The test model is a representation of the implementation.</li>
</ul>
</li>
<li><strong>Test objectives (requirements)</strong> - Criteria associated with the test model.</li>
<li><strong>Test cases</strong> - Must exercise all the elements defined by the test objectives in the model.</li>
<li><strong>Older terminology:</strong><ul>
<li>Black-box testing - Functional Testing</li>
<li>White-box testing - Structural Testing</li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<ol>
<li><strong>Model of the implementation</strong></li>
<li><strong>Structural Testing</strong> - Test cases must exercise all the components and their interactions in the implementation.</li>
</ol>
<p><strong>Example:</strong></p>
<ol>
<li><strong>Model of the functionality</strong></li>
<li><strong>Functional Testing</strong> - Test cases must exercise all the functionalities defined in the specification.</li>
</ol>
<h2>Functional vs. Structural Testing</h2>
<p><strong>Functional Testing:</strong></p>
<ul>
<li><strong>Advantages:</strong><ul>
<li>Checks conformance with the specification.</li>
<li>Scales up (different techniques at different granularity levels).<ul>
<li>Works for a function, a class, a package/component, a system.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Disadvantages:</strong><ul>
<li>Depends on the specification and the degree of detail.</li>
<li>Does not know how much of the system (code) is being tested.<ul>
<li>What if the system performs some unexpected, undesirable task?</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Structural Testing:</strong></p>
<ul>
<li><strong>Advantages:</strong><ul>
<li>Based on control and data flow criteria.</li>
<li>Allows you to be confident about how much of the system is being tested.</li>
</ul>
</li>
<li><strong>Disadvantages:</strong><ul>
<li>Does not scale up (mostly applicable at unit and integration testing levels).<ul>
<li>Doesn't work for a package/component, a system.</li>
</ul>
</li>
<li>Cannot reveal missing functionalities.<ul>
<li>What if part of the specification is not implemented?</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Diagram:</strong></p>
<ul>
<li><strong>System</strong> - The implementation.</li>
<li><strong>Specification</strong> - The requirements.</li>
<li><strong>Missing functionality</strong> - Cannot be revealed by white-box (structural) techniques.</li>
<li><strong>Unexpected functionality</strong> - Cannot be revealed by black-box (functional) techniques.</li>
</ul>
<h2>Test Model Criterion</h2>
<ul>
<li>
<p><strong>Given a criterion C for a model M:</strong></p>
<ul>
<li><strong>Coverage ratio</strong> - The proportion of the elements in M defined by C that are covered by T.</li>
<li><strong>C-adequate</strong> - A test set T is said to be adequate for C when the coverage ratio achieves 100% for criterion C.</li>
</ul>
</li>
<li>
<p><strong>Example 1:</strong></p>
<ul>
<li>M - the control flow graph of a function.</li>
<li>C - "all the statements."</li>
<li>A test suite exercises 5 (out of 8) statements: 62.5% coverage (ratio).</li>
<li><strong>The test suite is not adequate for the all-statements criterion.</strong></li>
</ul>
</li>
<li>
<p><strong>Example 2:</strong></p>
<ul>
<li>M - a set of use case scenarios.</li>
<li>C - "all the scenarios."</li>
<li>A test suite exercises 12 (out of 12) scenarios: 100% coverage (ratio).</li>
<li><strong>The test suite is adequate for the all-scenarios criterion.</strong></li>
<li><strong>The test suite is all-scenarios adequate.</strong></li>
</ul>
</li>
</ul>
<h2>Test Model Criterion (cont.)</h2>
<ul>
<li>
<p><strong>Test criterion:</strong></p>
<ul>
<li>Specifies a set of test requirements/objectives.</li>
<li>Test requirements must be satisfied in order to obtain an adequate test suite.</li>
</ul>
</li>
<li>
<p><strong>Issue!</strong></p>
<ul>
<li>When applying a criterion on a test model, not all test requirements are feasible.</li>
</ul>
</li>
<li>
<p><strong>Revised notion of adequacy:</strong></p>
<ul>
<li><strong>Coverage ratio</strong> - The proportion of the <strong>feasible</strong> elements in M defined by C covered by T.</li>
<li><strong>C-adequate</strong> - A test set T is said to be adequate for C when the coverage ratio achieves 100% for criterion C.</li>
</ul>
</li>
</ul>
<h2>Theoretical Hierarchy of Criteria</h2>
<ul>
<li>
<p><strong>Subsumption relation</strong> - C1 <strong>subsumes</strong> C2 if any C1-adequate test set is also C2-adequate.</p>
<ul>
<li><strong>Beware!</strong> This is not a subset relation.</li>
</ul>
</li>
<li>
<p><strong>Example:</strong></p>
<ul>
<li>Consider criteria all-transitions and all-paths for finite state machines.</li>
<li>All-paths subsumes all-transitions.</li>
<li>Any all-paths adequate test suite necessarily exercises all the transitions.</li>
</ul>
</li>
<li>
<p><strong>Usually (but not always), if C1 subsumes C2:</strong></p>
<ul>
<li>Satisfying C1 <strong>tends</strong> to be more expensive than satisfying C2 (e.g., C1 tends to require more test cases than C2).</li>
<li>A C1-adequate test suite <strong>tends</strong> to detect more faults than a C2-adequate test suite.</li>
</ul>
</li>
</ul>
<h2>Two Ways to Use Test Criteria</h2>
<ul>
<li>
<p><strong>Generate test values / test cases to satisfy the criterion.</strong></p>
<ul>
<li><strong>Selection criterion</strong> - Criterion = selection criterion.</li>
<li><strong>Generator</strong> - Need a tool (or human), a generator, that (automatically) generates values to satisfy the criterion.</li>
<li><strong>Wish:</strong> Create a (software) generator?</li>
</ul>
</li>
<li>
<p><strong>Evaluate coverage achieved by externally generated test values / test cases.</strong></p>
<ul>
<li><strong>Coverage criterion</strong> - Criterion = coverage criterion.</li>
<li><strong>Recognizer</strong> - Need a tool (or human), a recognizer, that (automatically) decides whether a set of values satisfies a criterion.</li>
<li><strong>Wish:</strong> Create a (software) recognizer?</li>
</ul>
</li>
</ul>
<h2>Two Ways to Use Test Criteria (cont.)</h2>
<ul>
<li>
<p><strong>Problems:</strong></p>
<ul>
<li>How to create a generator?</li>
<li>How to create a recognizer?</li>
</ul>
</li>
<li>
<p><strong>Issue!</strong></p>
<ul>
<li>Both problems are provably undecidable for most criteria.<ul>
<li>i.e., not possible to construct a single algorithm that will always, in every situation, find a correct solution.</li>
</ul>
</li>
<li>However, it is often easier to build a <strong>recognizer</strong> than a <strong>generator</strong>.<ul>
<li>Coverage analysis tools (recognizer) are quite plentiful.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Miss-Use of Terminology</h2>
<ul>
<li>
<p><strong>Beware of miss-use of term "coverage."</strong></p>
</li>
<li>
<p><strong>Your colleague says:</strong></p>
<ul>
<li>
<p>"I am checking what my tests exercise with the all-statements selection criterion."</p>
<ul>
<li><strong>Wrong!</strong> They are using the all-statements criterion in a <strong>recognizer context</strong>.</li>
<li><strong>Coverage criterion</strong></li>
</ul>
</li>
<li>
<p>"I am creating tests with the all-scenarios coverage criterion."</p>
<ul>
<li><strong>Wrong!</strong> They are using the all-scenarios criterion in a <strong>generator context</strong>.</li>
<li><strong>Selection criterion</strong></li>
</ul>
</li>
<li>
<p>"I am doing structural testing since I check my tests execute all statements."</p>
<ul>
<li><strong>Wrong!</strong> With structural testing, one uses a selection criterion that applies on a model of the implementation (generator context). Here they are using the criterion in a <strong>recognizer context</strong>.</li>
</ul>
</li>
<li>
<p>"My tests achieve 100% coverage."</p>
<ul>
<li><strong>What criterion?</strong> Different criteria may have extremely different costs!</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Using a Test Selection Criterion</h2>
<p><strong>Steps:</strong></p>
<ol>
<li><strong>Choose a test model.</strong></li>
<li><strong>Select a test criterion.</strong></li>
<li><strong>Identify test objectives.</strong></li>
<li><strong>Create test case specifications.</strong></li>
<li><strong>Identifying test data/input.</strong></li>
<li><strong>Identify Oracle.</strong></li>
</ol>
<p><strong>Example:</strong></p>
<ol>
<li><strong>State machine</strong></li>
<li><strong>All-transitions</strong></li>
<li><strong>The transitions are t1, t2, ...</strong></li>
<li>
<ul>
<li>Test case 1 will exercise transitions t1, t4, t5.</li>
<li>Test case 2 will exercise transitions t1, t2, t8, ...</li>
</ul>
</li>
<li>
<ul>
<li>To execute test case 1, I need to execute with input value 10.</li>
<li>To execute test case 2, I need to execute with input value 20.</li>
</ul>
</li>
<li>What do you feel you need to check during and at the end of the execution of test case 1, test case 2, ... and what is it you should expect?</li>
</ol>
<h2>Example (Graph) Model</h2>
<ul>
<li><strong>Got 0</strong> - initial state</li>
<li><strong>Got 5</strong> - state after inserting 5p</li>
<li><strong>Got 10</strong> - state after inserting 10p</li>
<li><strong>-5p, no can</strong> - transition after inserting 5p and no can is dispensed</li>
<li><strong>-10p, can</strong> - transition after inserting 10p and a can is dispensed</li>
<li><strong>10p, no can</strong> - transition after inserting 10p and no can is dispensed</li>
</ul>
<p><strong>Steps:</strong></p>
<ol>
<li><strong>Choose a test model (see on the left).</strong></li>
<li><strong>Select a test criterion: all-transitions.</strong></li>
<li><strong>Identify test objectives</strong><ul>
<li>Got0 -&gt; Got5</li>
<li>Got5 -&gt; Got10</li>
<li>Got10 -&gt; Got5</li>
<li>Got0 -&gt; Got10</li>
<li>Got5 -&gt; Got10</li>
</ul>
</li>
<li><strong>Create test case specification.</strong><ul>
<li>TCS1 = [Got0, Got5, Got10]</li>
<li>TCS2 = [Got0, Got10, Got0]</li>
<li>TCS3 = [Got0, Got10, Got5, Got0]</li>
</ul>
</li>
<li><strong>Identify test data.</strong><ul>
<li>TC1 = [5p, 5p]</li>
<li>TC2 = [10p, 5p]</li>
<li>TC3 = [10p, 10p, 10p]</li>
</ul>
</li>
<li><strong>Oracles</strong><ul>
<li>TC1 = machine has 10p in, no can</li>
<li>TC2 = machine has 0p in, one can</li>
<li>TC3 = machine has 0p in, two cans</li>
</ul>
</li>
</ol>
<h2>Marick's Recommendation</h2>
<p>Brian Marick recommends the following approach:</p>
<ol>
<li>
<p><strong>Generate functional tests from requirements and design to try every function.</strong></p>
<ul>
<li><strong>Use a functional selection criterion (generator).</strong></li>
</ul>
</li>
<li>
<p><strong>Check the structural coverage after the functional tests are all verified to be successful.</strong></p>
<ul>
<li><strong>Use a structural coverage criterion (recognizer).</strong></li>
</ul>
</li>
<li>
<p><strong>Where the structural coverage is imperfect, generate functional tests (not structural) that induce the additional coverage.</strong></p>
</li>
</ol>
<p><strong>This works because form (structure) should follow function!</strong></p>
<ul>
<li>Uncovered code must have some purpose, and that purpose has not been invoked, so some function is untested.</li>
</ul>
<h2>Test Criteria Based on Structure [Offutt]</h2>
<ul>
<li>
<p><strong>Graphs</strong> - Based on the structure of the program, such as:</p>
<ul>
<li>Method body</li>
<li>Methods and calls</li>
<li>Components interactions</li>
<li>State and transitions</li>
</ul>
</li>
<li>
<p><strong>Logical Expressions</strong> - Can appear in:</p>
<ul>
<li>State machine</li>
<li>Source code</li>
<li>Software specification</li>
</ul>
</li>
<li>
<p><strong>Input Domain Characterization</strong> - Describes the input domain of the software under test (method, component, system).</p>
</li>
<li>
<p><strong>Syntactic Structures</strong> - Based on a grammar, or other syntactic definition.</p>
<ul>
<li>e.g., mutation testing</li>
</ul>
</li>
</ul>
<h2>Test Criteria - Graphs</h2>
<ul>
<li><strong>Example:</strong> A Control Flow Graph of a program.</li>
</ul>
<h2>Test Criteria - Logic Expressions</h2>
<ul>
<li><strong>Example:</strong> Logic expressions can be used to represent the conditions of a program.<ul>
<li><strong>Input</strong> - The input values for the logic expression.</li>
<li><strong>Gi</strong> - The expected output of the logic expression given the input.</li>
<li><strong>N</strong> - The logic expression is not decidable (i.e., the output is unknown).</li>
<li><strong>S</strong> - The logic expression is decidable and the output is "Send."</li>
<li><strong>R</strong> - The logic expression is decidable and the output is "Send."</li>
<li><strong>T</strong> - The logic expression is decidable and the output is "Send."</li>
<li><strong>Cr</strong> - The logic expression is decidable and the output is "Send."</li>
<li><strong>Op</strong> - The logic expression is an operation.</li>
<li><strong>ac</strong> - The logic expression is an "Accept" operation.</li>
<li><strong>Udata</strong> - The logic expression is an "Udata" operation.</li>
<li><strong>Send_sq</strong> - The logic expression is a "Send_sq" operation.</li>
<li><strong>XpSsq, cr</strong> - The logic expression is an "XpSsq, cr" operation.</li>
<li><strong>XpSsq, cr</strong> - The logic expression is an "XpSsq, cr" operation.</li>
<li><strong>XpSsq, cr</strong> - The logic expression is an "XpSsq, cr" operation.</li>
<li><strong>XpSsq, cr</strong> - The logic expression is an "XpSsq, cr" operation.</li>
<li><strong>XpSsq, cr</strong> - The logic expression is an "XpSsq, cr" operation.</li>
<li><strong>XpSsq, cr</strong> - The logic expression is an "XpSsq, cr" operation.</li>
</ul>
</li>
</ul>
<h2>Test Criteria - Input Domain Characterization</h2>
<ul>
<li><strong>Example:</strong> The input domain of a program can be used to generate test cases.<ul>
<li><strong>The grep utility searches any given input files, selecting lines that match one or more patterns. By default, a pattern matches an input line if the regular expression (RE) matches at least one character in the input line.  The RE must match one of the following:  a single character or a character class (e.g., [a-z]) or a range of characters (e.g., a-z) or a character sequence (e.g., [a-z]).  The RE can be made more complex by using the ".<em>" operator.  The "." operator matches any single character, while "</em>" matches 0 or more of the previous character.  For example, ".*" will match any string.  The grep utility is commonly used to search for text within files.</strong></li>
<li><strong>A general ATM (Automatic Teller Machine) system is implemented as Web service and deployed in the Tomcat server. The user and business data are stored in a MySQL database. The system offers several features such as withdrawal deposit transfer query and each of them has its own backend logic.</strong></li>
<li><strong>TCAS is a family of airborne devices that function independently of the ground-based air traffic control (ATC) system, and provide collision avoidance protection for a broad spectrum of aircraft types.  All TCAS systems provide some degree of collision threat alerting, and a traffic display. TCAS I and II differ primarily by their alerting capability. TCAS I provides traffic advisories (TAs) to assist the pilot in the visual acquisition of intruder aircraft. TCAS I is mandated for use in the U.S. for turbine powered, passenger-carrying aircraft having more than 10 and less than 31 seats. TCAS I is also installed on a number of general aviation fixed wing aircraft and helicopters. TCAS II provides TAs and resolution advisories (RAs), i.e., recommended escape maneuvers, in the vertical dimension to either increase or maintain the existing vertical separation between aircraft. TCAS II is mandated by the U.S. for commercial aircraft, including regional airline aircraft with more than 30 seats or a maximum takeoff weight greater than 33,000 lbs. Although not mandated for general aviation use, many turbine-powered general aviation aircraft and some helicopters are also equipped with TCAS II.</strong></li>
</ul>
</li>
</ul>
<h2>Test Criteria - Syntactic Structure</h2>
<ul>
<li><strong>Example:</strong> The syntactic structure of a program can be used to generate test cases.<ul>
<li><strong>The <code>malloc</code> function in the C standard library is a function that allocates a block of memory.  The <code>malloc</code> function takes a single argument, which is the size of the block of memory to be allocated.  The <code>malloc</code> function returns a pointer to the newly allocated block of memory.  The <code>malloc</code> function can be used to allocate memory for arrays, structures, and other data types.</strong></li>
<li><strong>The <code>free</code> function in the C standard library is a function that frees a block of memory.  The <code>free</code> function takes a single argument, which is a pointer to the block of memory to be freed.  The <code>free</code> function does not return a value.</strong></li>
<li><strong>The <code>realloc</code> function in the C standard library is a function that changes the size of a block of memory.  The <code>realloc</code> function takes two arguments.  The first argument is a pointer to the block of memory to be resized.  The second argument is the new size of the block of memory.  The <code>realloc</code> function returns a pointer to the resized block of memory.  If the <code>realloc</code> function fails, it returns a null pointer.</strong></li>
<li><strong>The <code>calloc</code> function in the C standard library is a function that allocates a block of memory and initializes it to zero.  The <code>calloc</code> function takes two arguments.  The first argument is the number of elements to be allocated.  The second argument is the size of each element.  The <code>calloc</code> function returns a pointer to the newly allocated block of memory.  The <code>calloc</code> function can be used to allocate memory for arrays, structures, and other data types.  The <code>calloc</code> function is useful when you want to ensure that the memory you are allocating is initialized to zero.</strong></li>
</ul>
</li>
</ul>
        </div>

        <button class="collapsible">Keywords and Definitions</button>
        <div class="content">
            <h2>Glossary of Key Terms and Concepts</h2>
<p>Here is a glossary of important terms and concepts from the lecture, ordered alphabetically. </p>
<p><strong>All-paths Criterion</strong> 
A test criterion that requires a test suite to cover all possible paths through a program or system. </p>
<p><strong>All-scenarios Criterion</strong>
A test criterion that requires a test suite to cover all possible scenarios or use cases defined in a system's specification.</p>
<p><strong>All-statements Criterion</strong>
A test criterion that requires a test suite to cover all possible statements in a program or system. </p>
<p><strong>All-transitions Criterion</strong>
A test criterion used for state machines that requires a test suite to cover all possible transitions between states. </p>
<p><strong>Coverage Ratio</strong>
The proportion of elements in a model covered by a test suite. </p>
<p><strong>Exhaustive Testing</strong>
Testing a system using all possible inputs. In most cases, this is impossible to achieve due to the vast number of potential inputs. </p>
<p><strong>Functional Testing</strong>
Testing that focuses on verifying the functional behavior of a system against its specification.  </p>
<p><strong>Generator</strong>
A tool or process that automatically generates test cases based on a given selection criterion.  </p>
<p><strong>Input Domain Characterization</strong>
A test criterion that focuses on testing the system's behavior with various inputs from a defined input domain.</p>
<p><strong>Recognizer</strong>
A tool or process that automatically checks if a set of test data satisfies a specific coverage criterion. </p>
<p><strong>Selection Criterion</strong>
A test criterion used to select or generate test cases based on a specific aspect of the system, such as specific functionalities or inputs. </p>
<p><strong>Structural Testing</strong>
Testing that focuses on exercising the internal structure and code of a system. </p>
<p><strong>Subsumes</strong>
A relationship between two test criteria for the same model where a test suite that satisfies the first criterion also satisfies the second criterion.  </p>
<p><strong>Syntactic Structures</strong>
A test criterion that utilizes the syntactic structure of a program or system to generate test cases, often used for techniques like mutation testing. </p>
<p><strong>Test Model</strong>
A representation of a system used for testing, which could be a graph, state machine, or other model. </p>
<p><strong>Test Objectives</strong>
The specific requirements or goals that are to be tested. </p>
<p><strong>Test Suite</strong>
A collection of test cases designed to comprehensively test a system. </p>
<p><strong>Undecidable</strong>
A problem for which there is no general algorithm that can always determine a solution.  </p>
<p><strong>White-Box Testing</strong>
Another name for structural testing, as the tester has access to the internal code and structure of the system.</p>
        </div>

        <button class="collapsible">Review Questions</button>
        <div class="content">
    <h3>Q: What is meant by 'exhaustive testing' and why is it typically not feasible?</h3><p>A: Exhaustive testing involves executing a program with every possible input combination. However, it is often impractical or even impossible to perform exhaustive testing due to the vast number of potential inputs, particularly for complex software systems.</p><h3>Q: Explain the concept of equivalence classes in software testing and how they are used to reduce the number of test cases.</h3><p>A: Equivalence classes are groups of inputs that are expected to produce similar outcomes. By selecting one representative input from each equivalence class, testers can significantly reduce the number of test cases required while still achieving adequate coverage.</p><h3>Q: What are the two primary approaches to test data selection, and how do they differ in their focus?</h3><p>A: Test data selection can be guided by either functional testing or structural testing. Functional testing focuses on verifying the software's behavior against its specifications, while structural testing aims to ensure all components of the code are adequately exercised.</p><h3>Q: What is a 'test model' in the context of software testing, and what role does it play in test data selection?</h3><p>A: A test model is a representation of either the software's specification (functional testing) or its implementation (structural testing). This model serves as the basis for selecting test cases that aim to cover the specified functionalities or code structures.</p><h3>Q: Define 'coverage ratio' in software testing and explain what constitutes an 'adequate' test set in relation to a given criterion.</h3><p>A: The coverage ratio measures the extent to which a test set covers the elements defined by a specific test criterion. An adequate test set achieves 100% coverage for the criterion, indicating that all elements are adequately tested.</p><h3>Q: What is a 'test criterion' in software testing, and how does it contribute to the overall quality of testing?</h3><p>A: A test criterion specifies a set of requirements or objectives that a test set must satisfy to be considered adequate. It provides a framework for ensuring that testing is comprehensive and covers all essential aspects.</p><h3>Q: What is the 'issue' that arises when applying test criteria to software testing, and what implications does this have?</h3><p>A: While test criteria are beneficial for guiding test data selection, they are not always perfectly feasible. Some criteria may require testing that is impractical or impossible to perform due to limitations in the software or testing environment.</p></div>
        <button class="collapsible">Practice Exam</button>
        <div class="content">
        <h2>Short Answer Questions</h2><h3>Q: Explain the significance of the subsumption relation in the context of test model criteria.</h3><p>A: The subsumption relation helps to organize and prioritize test criteria by identifying a hierarchy of coverage levels. This allows testers to focus on more comprehensive criteria that implicitly cover less stringent ones. For example, by ensuring that a test suite covers all paths in a program, we can be confident that it also covers all transitions, making the all-paths criterion more valuable than the all-transitions criterion.</p><h3>Q: Why is choosing the appropriate test model essential in software testing?</h3><p>A: The choice of a test model is crucial because it defines the scope and perspective of the testing effort. It determines what aspects of the system will be tested and how they will be represented. For example, a state machine model is suitable for testing the behavior of a system based on its states and transitions, while a control flow graph model is more appropriate for analyzing the execution flow of a program. The selection of a test model should be aligned with the specific objectives and requirements of the testing process.</p><h3>Q: Why is the identification of test objectives essential for successful software testing?</h3><p>A: The identification of test objectives is crucial because it provides a clear purpose and direction for the testing effort. It helps to ensure that the test cases are relevant to the overall goals and requirements of the system. By clearly defining the objectives, testers can focus their efforts on specific areas of concern and design test cases that effectively target those areas. For example, if the objective is to test the security of a system, test cases should be designed to evaluate the system's vulnerability to attacks and unauthorized access. The test objectives should be specific, measurable, achievable, relevant, and time-bound to ensure their effectiveness and relevance to the overall testing process.</p><h2>Long Answer Questions</h2><h3>Q: Explain the difference between functional testing and structural testing, highlighting their respective focuses and advantages.</h3><p>A: Functional testing focuses on verifying that the software behaves according to its specification. It checks if the system meets the intended functionalities and requirements defined in the documentation. The test cases are designed based on the specification, without considering the internal implementation details. On the other hand, structural testing aims to ensure the quality of the implementation by examining the internal structure and logic of the code. It involves testing the code based on its control flow, data flow, and underlying algorithms. This approach helps to identify defects and vulnerabilities that may not be apparent through functional testing. In summary, functional testing checks the external behavior of the software against its specification, while structural testing examines the internal implementation to ensure code quality and integrity.</p><h3>Q: What is exhaustive testing, and why is it generally impractical? Describe the concept of equivalence partitioning and how it addresses the limitations of exhaustive testing.</h3><p>A: Exhaustive testing is a testing strategy where all possible input combinations are tested. It aims to cover all possible scenarios and identify any potential issues. However, in practice, exhaustive testing is often impossible or infeasible due to the vast number of inputs that need to be evaluated. For example, a program that computes the factorial function would require testing it with all possible integer values, which is practically unachievable. To overcome this limitation, equivalence partitioning is a technique that groups inputs into equivalence classes based on their behavior. One representative input is selected from each class to represent the entire class. This reduces the number of test cases while ensuring adequate coverage. For example, in a program that performs calculations based on input values, inputs within a specific range can be grouped into an equivalence class, and only a single input from that range is tested. Equivalence partitioning helps to achieve a balance between thoroughness and feasibility, allowing for effective testing without overwhelming the testing process.</p><h2>Multiple Choice Questions</h2><h3>Q: In the context of test model criteria, what does the coverage ratio represent?</h3><ul><li>The number of test cases used in the test suite.</li><li>The complexity of the test suite in terms of the number of steps or interactions.</li><li>The proportion of elements in the model covered by the test set.</li><li>The efficiency of the test suite in terms of its execution time and resource consumption.</li></ul><p>Correct Answer: c</p><p>Explanation: The coverage ratio is calculated as the proportion of elements in the model covered by the test set. If the test set covers 100% of the elements defined by the criterion, it is considered adequate for that criterion. Option a is incorrect because the coverage ratio is not necessarily the number of test cases, but the proportion of covered elements. Option b is incorrect because the coverage ratio does not measure the complexity of the test suite. Option d is incorrect because the coverage ratio does not measure the efficiency of the test suite.</p><h3>Q: Which type of testing is primarily concerned with the internal implementation and logic of the code?</h3><ul><li>Structural testing</li><li>Functional testing</li><li>Integration testing</li><li>System testing</li></ul><p>Correct Answer: a</p><p>Explanation: Structural testing focuses on the internal structure and logic of the code. It aims to ensure that the code is well-designed and free from internal inconsistencies. The test cases are designed based on the code's control flow, data flow, and other structural aspects. Functional testing, on the other hand, focuses on the external behavior of the software and verifies whether it meets the specified requirements. It does not concern itself with the internal implementation details.</p><h3>Q: Which statement accurately describes a limitation of structural testing?</h3><ul><li>Structural testing always requires more test cases than functional testing.</li><li>Structural testing is only applicable at unit and integration testing levels.</li><li>Structural testing can reveal missing functionalities that are not implemented.</li><li>Structural testing cannot reveal missing functionalities that are not implemented.</li></ul><p>Correct Answer: d</p><p>Explanation: The statement that structural testing cannot reveal missing functionalities is true because it focuses on the implementation rather than the requirements. If a functionality is not implemented, structural testing will not be able to identify its absence. The other statements about structural testing are incorrect. Structural testing does not always require more test cases than functional testing, and it can be useful at all levels of testing, not just unit and integration testing. Finally, structural testing can provide confidence about the system's internal consistency, but not necessarily about how much of the system is being tested.</p><h3>Q: In test criteria, what is a generator?</h3><ul><li>A tool that verifies whether a set of test cases meets a specific criterion.</li><li>A tool that generates test cases to satisfy a specific criterion.</li><li>A process that is used for functional testing only.</li><li>A process that is used for structural testing only.</li></ul><p>Correct Answer: b</p><p>Explanation: In the context of test criteria, a generator is a tool or process that generates test cases to satisfy a specific criterion. For example, a generator for the all-statements criterion would create test cases that exercise all statements in a program. Option a is incorrect because a recognizer is used to evaluate whether a test set meets a given criterion. Option c is incorrect because both generators and recognizers can be tools or processes. Option d is incorrect because both generators and recognizers can be used for both functional and structural testing, depending on the criterion being used.</p><h3>Q: What does the subsumption relation between test criteria imply?</h3><ul><li>If one criterion subsumes another, the set of model elements to be exercised to satisfy the subsumed criterion is a subset of the set of model elements to be exercised to satisfy the subsuming criterion.</li><li>If one criterion subsumes another, satisfying the subsuming criterion is always more expensive than satisfying the subsumed criterion.</li><li>If one criterion subsumes another, a test suite adequate for the subsuming criterion always detects more faults than a test suite adequate for the subsumed criterion.</li><li>If one criterion subsumes another, the sets of model elements to be exercised to satisfy the two criteria are the same.</li></ul><p>Correct Answer: a</p><p>Explanation: The subsumption relation between test criteria means that if a test suite is adequate for one criterion, it is also adequate for a less stringent criterion. For example, if a test suite covers all paths in a program, it automatically covers all transitions, because every path includes transitions. This implies that the all-paths criterion subsumes the all-transitions criterion. The other options are incorrect because the subsumption relation does not imply that the sets of elements are the same, that satisfying one criterion is always more expensive than satisfying another, or that detecting faults is always better for one criterion than another. The subsumption relation primarily relates to the coverage provided by a test suite and its implications for different criteria.</p></div>
        <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                } 
            });
        }
        </script>
    </body>
    </html>
    