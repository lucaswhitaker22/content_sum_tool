{
    "metadata": {
        "overview": "This lecture focuses on the definition and application of test criteria in software testing, particularly exploring the distinction between functional and structural testing techniques. It emphasizes the importance of selecting appropriate criteria based on the specific testing objectives and the nature of the software model being tested.",
        "topics": [
            "Exhaustive Testing",
            "Test Data Selection Procedures",
            "Functional vs. Structural Testing",
            "Test Model Criteria",
            "Theoretical Hierarchy of Criteria",
            "Two Ways to Use Test Criteria",
            "Miss-use of Terminology",
            "Using a Test Selection Criterion",
            "Example (graph) Model",
            "Marick's Recommendation",
            "Test Criteria Based on Structure [Offutt]",
            "Test Criteria - Graphs",
            "Test Criteria - Logic Expressions",
            "Test Criteria - Input Domain Characterization",
            "Test Criteria - Syntactic Structure"
        ],
        "format": "Lecture",
        "date": "2024-09-17",
        "course": "SYSC 4101",
        "title": "Input Domain",
        "path": "input/SYSC4101-5105_Definitions_PII.pdf"
    },
    "notes": "# SYSC 4101/SYSC 5105: Definitions - Part II\n\n## Exhaustive Testing\n\n*   **Exhaustive testing:** testing using all possible inputs.\n    *   Most of the time, this is **impossible**!\n*   **Examples:**\n    *   A program that computes the factorial function (n! = n * (n - 1) * (n - 2) * ... * 1)\n        *   Exhaustive testing = running the program with 0, 1, 100, ..., i.e., all possible integer values.\n    *   A compiler (e.g., javac)\n        *   Exhaustive testing = compiling every possible (Java) program.\n\n*   **Technique to reduce the number of inputs (i.e., test cases):**\n    *   **Testing criteria:** group input elements into (equivalence) classes.\n    *   **One input is selected in each class** (notion of test data adequacy).\n    *   **Criteria are used to decide which test inputs to use.**\n    *   **Criteria are used to decide when to stop testing.**\n\n## Test Data: Procedure to Select?\n\n*   **Test model:** A representation of the specification or the implementation.\n    *   **Functional testing:** The test model represents the specification.\n    *   **Structural testing:** The test model represents the implementation.\n*   **Test objectives (requirements):** Criteria associated with the test model.\n*   **Test data:**  Test cases must exercise all the elements in the model.\n\n**Older terminology:**\n\n*   **Black-box testing:**  Focuses on the specification.\n*   **White-box testing:** Focuses on the implementation.\n\n## Functional vs. Structural Testing\n\n**Functional Testing:**\n\n*   **Check conformance with the specification.**\n*   **Scales up (different techniques at different granularity levels).**\n    *   Works for a function.\n    *   Works for a class.\n    *   Works for a package/component.\n    *   Works for a system.\n*   **Depends on the specification and the degree of detail.**\n*   **Do not know how much of the system (code) is being tested.**\n    *   What if the system performs some unexpected, undesirable task?\n\n**Structural Testing:**\n\n*   **Based on control and data flow criteria.**\n*   **Allows you to be confident about how much of the system is being tested.**\n*   **Does not scale up (mostly applicable at unit and integration testing levels).**\n    *   Doesn't work for a package/component.\n    *   Doesn't work for a system.\n*   **Cannot reveal missing functionalities.**\n    *   What if part of the specification is not implemented?\n\n## Test Model Criterion\n\n*   **Given a criterion C for a model M:**\n    *   **Coverage ratio:** The proportion of elements in M defined by C that are covered by T.\n    *   **C-adequate:** A test set T is said to be adequate for C when the coverage ratio achieves 100% for criterion C.\n\n*   **Example 1:**\n    *   M = the control flow graph of a function\n    *   C = \"all the statements\"\n    *   A test suite exercises 5 (out of 8) statements: 62.5% coverage (ratio).\n    *   Test suite is **not adequate** for the all-statements criterion.\n\n*   **Example 2:**\n    *   M = a set of use case scenarios\n    *   C = \"all the scenarios\"\n    *   A test suite exercises 12 (out of 12) scenarios: 100% coverage (ratio).\n    *   Test suite is **adequate** for the all-scenarios criterion.\n    *   Test suite is **all-scenarios adequate.**\n\n*   **Test criterion:**\n    *   Specifies a set of test requirements/objectives.\n    *   Test requirements must be satisfied in order to obtain an adequate test suite.\n\n*   **Issue:** When applying a criterion on a test model, not all test requirements are feasible.\n\n*   **Revised notion of adequacy:**\n    *   The **coverage ratio** of a test set T is the proportion of the **feasible elements** in M defined by C covered by T.\n    *   A test set T is said to be **adequate** for C, or simply C-adequate, when the coverage ratio achieves 100% for criterion C.\n\n## Theoretical Hierarchy of Criteria\n\n*   **Subsumption relation:** For a given model M, C1 **subsumes** C2 if any C1-adequate test set is also C2-adequate.\n    *   **Beware:** This is **not a subset relation**! The set of model elements to be exercised to satisfy C2 is not a subset of the set of model elements to be exercised to satisfy C1.\n*   **Example:**\n    *   Consider criteria all-transitions and all-paths for finite state machines. All-paths subsumes all-transitions.\n    *   Any all-paths adequate test suite necessarily exercises all the transitions.\n*   **Usually (but not always), if C1 subsumes C2:**\n    *   Satisfying C1 **tends** to be more expensive than satisfying C2 (e.g., C1 tends to require more test cases than C2).\n    *   A C1-adequate test suite **tends** to detect more faults than a C2-adequate test suite.\n\n## Two Ways to Use Test Criteria\n\n1.  **Generate test values/test cases to satisfy the criterion.**\n    *   **Criterion = selection criterion.**\n    *   Need a tool (or human), a **generator**, that (automatically) generates values to satisfy the criterion.\n    *   **Wish:** create a (software) generator?\n\n2.  **Evaluate coverage achieved by externally generated test values/test cases.**\n    *   **Criterion = coverage criterion.**\n    *   Need a tool (or human), a **recognizer**, that (automatically) decides whether a set of values satisfies a criterion.\n    *   **Wish:** create a (software) recognizer?\n\n## Two Ways to Use Test Criteria (cont.)\n\n*   **Problems:**\n    *   How to create a generator?\n    *   How to create a recognizer?\n\n*   **Issue:** Both problems are provably undecidable for most criteria.\n    *   i.e., not possible to construct a single algorithm that will always, in every situation, find a correct solution.\n*   **However, it is often easier to build a recognizer than a generator.**\n    *   Coverage analysis tools (recognizer) are quite plentiful.\n\n## Miss-Use of Terminology\n\n*   **Beware** of miss-use of the term \"coverage.\"\n\n*   **Your colleague says:**\n    *   \"I am checking what my tests exercise with the all-statements selection criterion.\"\n        *   **Wrong:** they are using the all-statements criterion in a recognizer context. It should be called **coverage criterion.**\n    *   \"I am creating tests with the all-scenarios coverage criterion.\"\n        *   **Wrong:** they are using the all-scenarios criterion in a generator context. It should be called **selection criterion.**\n    *   \"I am doing structural testing since I check my tests execute all statements.\"\n        *   **Wrong:** With structural testing, one uses a selection criterion that applies on a model of the implementation (generator context). Here they are using the criterion in a recognizer context.\n    *   \"My tests achieve 100% coverage.\"\n        *   **What criterion?** Different criteria may have extremely different costs!\n\n## Using a Test Selection Criterion\n\n**Steps:**\n\n1.  **Choose a test model.**\n2.  **Select a test criterion.**\n3.  **Identify test objectives.**\n4.  **Create test case specifications.**\n5.  **Identifying test data/input.**\n6.  **Identify Oracle.**\n\n**Example:**\n\n1.  **State machine.**\n2.  **All-transitions.**\n3.  **The transitions are t1, t2, ...**\n4.  **Test case 1 will exercise transitions t1, t4, t5.**\n    *   Test case 2 will exercise transitions t1, t2, t8, ...\n5.  **To execute test case 1, I need to execute with input value 10 ...**\n    *   To execute test case 2, I need to execute with input value 20 ...\n6.  **What do you feel you need to check during and at the end of the execution of test case 1, test case 2 ... and what is it you should expect?**\n\n## Example (Graph) Model\n\n*   **Specification of a vending machine.**\n*   **Gets 5p or 10p of money.**\n*   **Sells 15p cans.**\n\n1.  **Choose a test model (see on the left).**\n2.  **Select a test criterion: all-transitions.**\n3.  **Identify test objectives:**\n    *   Got0 -> Got5\n    *   Got5 -> Got10\n    *   Got10 -> Got5\n    *   Got0 -> Got10\n    *   Got5 -> Got10\n4.  **Create test case specifications:**\n    *   TCS1 = [Got0, Got5, Got10]\n    *   TCS2 = [Got0, Got10, Got0]\n    *   TCS3 = [Got0, Got10, Got5, Got0]\n5.  **Identify test data:**\n    *   TC1 = [5p, 5p]\n    *   TC2 = [10p, 5p]\n    *   TC3 = [10p, 10p, 10p]\n6.  **Oracles:**\n    *   TC1 = machine has 10p in, no can\n    *   TC2 = machine has 0p in, one can\n    *   TC3 = machine has 0p in, two cans\n\n## Marick's Recommendation\n\nBrian Marick recommends the following approach:\n\n1.  **Generate functional tests from requirements and design to try every function.**\n    *   **Use a functional selection criterion (generator).**\n2.  **Check the structural coverage after the functional tests are all verified to be successful.**\n    *   **Use a structural coverage criterion (recognizer).**\n3.  **Where the structural coverage is imperfect, generate functional tests (not structural) that induce the additional coverage.**\n\nThis works because **form (structure) should follow function**!\n\n*   Uncovered code must have some purpose, and that purpose has not been invoked, so some function is untested.\n\n## Test Criteria Based on Structure [Offutt]\n\n*   **Graphs:**\n    *   Method body\n    *   Methods and calls\n    *   Components interactions\n    *   State and transitions\n    *   ...\n\n*   **Logical Expressions:**\n    *   Can appear in:\n        *   State machine\n        *   Source code\n        *   Software specification\n    *   (not X or not Y) and A and B\n\n*   **Input Domain Characterization:**\n    *   Describes the input domain of the software under test (method, component, system).\n    *   A: {0, 1, >1}\n    *   B: {600, 700, 800}\n    *   C: {swe, cs, isa, infs}\n\n*   **Syntactic Structures:**\n    *   Based on a grammar, or other syntactic definition\n        *   e.g., mutation testing\n    *   ```\n        if (x > y) \n            z = x - y;\n        else\n            z = 2 * x\n        ```\n\n## Test Criteria - Graphs\n\n*   **Example:** A control flow graph of a function.\n\n## Test Criteria - Logic Expressions\n\n*   **Example:** Logic expressions used to generate test cases for a program.\n\n## Test Criteria - Input Domain Characterization\n\n*   **Example:** Input domain characterization for a program.\n    *   The grep utility searches any given input files, selecting lines that match one or more patterns. By default, a pattern matches an input line if the regular expression (RE) matches at least one character within the line.\n    *   A general ATM (Automatic Teller Machine) system is implemented as a Web service and deployed in the Tomcat server. The user and business data are stored in a MySQL database. The system offers several features such as withdrawal, deposit, transfer, query, and each of them has different input constraints.\n    *   TCAS is a family of airborne devices that function independently of the ground-based air traffic control (ATC) system and provide collision avoidance protection for a broad spectrum of aircraft types. All TCAS systems provide some degree of collision threat alerting, and a traffic display. TCAS I and II differ primarily by their alerting capability. TCAS I provides traffic advisories (TAs) to assist the pilot in the visual acquisition of intruder aircraft. TCAS I is mandated for use in the U.S. for turbine-powered, passenger-carrying aircraft having more than 10 and less than 31 seats. TCAS I is also installed on a number of general aviation fixed wing aircraft and helicopters. TCAS II provides TAs and resolution advisories (RAs), i.e., recommended escape maneuvers, in the vertical dimension to either increase or maintain the existing vertical separation between aircraft. TCAS II is mandated by the U.S. for commercial aircraft, including regional airline aircraft with more than 30 seats or a maximum takeoff weight greater than 33,000 lbs. Although not mandated for general aviation use, many turbine-powered general aviation aircraft and some helicopters are also equipped with TCAS II.\n\n## Test Criteria - Syntactic Structure\n\n*   **Example:** Syntactic structure used to generate test cases for a program.\n    *   ```C\n        if (alignment == 0)\n            alignment = DEFAULT_ALIGNMENT;\n        if (size == 0) {\n            /* Default size is what GNU malloc can fit in a 4096-byte block.\n             * 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n             */\n            size = 4096 - extra;\n        }\n        h->chunkfun = (struct _obstack_chunk(*)()) chunkfun;\n        h->alignment = alignment;\n        h->freefun = freefun;\n        h->chunk_size = size;\n        h->extra_arg = arg;\n        h->use_extra_arg = 1;\n        chunk = h->chunk = CALL_CHUNKFUN (h, h->chunk_size);\n        if (!chunk) {\n            h->alloc_failed = 1;\n            return 0;\n        }\n        h->alloc_failed = 0;\n        h->next_free = h->object_base = (char *) chunk + h->chunk_size;\n        chunk->prev = 0;\n        /* The initial chunk now contains no empty object. */\n        h->maybe_empty_object = 0;\n        return 1;\n    ```\n    *   ```java\n        // clean up to avoid a subtle but serious memory leak when using the\n        // same config for multiple JPF objects/runs this listener is an inner\n        // class object that keeps its encapsulating JPF instance alive\n        @Override\n        public void jpfRunTerminated(Config config) {\n            config.removeChangeListener(this);\n        }\n        // this is the backbone of all JPF configuration */\n        Config config;\n        /** The arch policy used to explore the state space */\n    ```\n\n##  Areas for Further Research or Clarification\n\n*   **Automatic test case generation:** How can we automatically generate test cases that satisfy a given criterion?\n*   **Coverage analysis tools:** How can we improve the accuracy and efficiency of coverage analysis tools?\n*   **Test model criteria:** What are the most effective test model criteria for different types of software?\n*   **Integration of functional and structural testing:** How can we effectively combine functional and structural testing to achieve more comprehensive testing?\n\nThese notes provide a comprehensive summary of the lecture on definitions - part II in SYSC 4101/SYSC 5105. Students can use these notes for review and to gain a deeper understanding of the concepts discussed.",
    "review": [
        {
            "answer": "Exhaustive testing aims to execute a program with all possible inputs. This is often impractical or even impossible due to the vast number of potential inputs, particularly for complex software.",
            "question": "What is exhaustive testing, and why is it often considered impractical?"
        },
        {
            "answer": "Testing criteria divide the set of inputs into equivalence classes. This simplifies testing by focusing on a representative input from each class, rather than examining every possible input.",
            "question": "Describe the purpose of testing criteria in the context of exhaustive testing."
        },
        {
            "answer": "Functional testing assesses whether the software meets the specified requirements. It focuses on the external behavior of the software, without delving into the implementation details.",
            "question": "What is the fundamental objective of functional testing?"
        },
        {
            "answer": "Structural testing, also known as white-box testing, examines the internal structure of the software. It aims to ensure that every code path or component is thoroughly tested.",
            "question": "What is structural testing, and how does it differ from functional testing?"
        },
        {
            "answer": "The coverage ratio measures the proportion of elements in a model (like code statements or scenarios) that are exercised by a given test suite. A test suite is considered adequate if it achieves 100% coverage for a specific criterion.",
            "question": "Explain the concept of coverage ratio in test suite evaluation."
        },
        {
            "answer": "The subsumption relation between criteria implies that a test suite that satisfies a more comprehensive criterion (C1) automatically satisfies a less stringent criterion (C2). For example, a test suite that covers all program paths would necessarily cover all statements.",
            "question": "Describe the subsumption relation between test criteria, and provide an illustrative example."
        },
        {
            "answer": "Marick's recommendation suggests a two-phase approach to testing. First, generate functional tests to ensure every function is exercised. Then, evaluate the structural coverage of the code. If gaps exist, create additional functional tests to address those uncovered areas.",
            "question": "Summarize Marick's recommended approach to testing."
        }
    ],
    "keywords": "# Glossary of Key Terms and Concepts\n\nThis glossary defines key terms and concepts from the lecture document on testing.\n\n- **All-paths criterion:** A test criterion that requires a test suite to exercise all possible paths in a model, such as a control flow graph. This criterion tends to be more expensive to satisfy than other criteria, but it can also detect more faults.\n\n- **All-transitions criterion:** A test criterion that requires a test suite to exercise all possible transitions in a model, such as a finite state machine. This criterion is less demanding than the all-paths criterion and can be satisfied with a smaller number of test cases.\n\n- **Coverage criterion:** A test criterion that specifies a set of requirements or objectives that must be satisfied in order to achieve a certain level of coverage. The coverage ratio is the proportion of elements in a model that are covered by a test suite.\n\n- **Coverage ratio:** The proportion of elements in a model that are covered by a test suite. For example, if a model has 10 statements and a test suite covers 5 of them, the coverage ratio is 50%.\n\n- **Exhaustive testing:** A testing strategy that involves testing all possible inputs to a software system. This is often impractical or even impossible, especially for complex systems with a large number of possible inputs.\n\n- **Feasible elements:** The subset of elements in a model that are considered relevant for testing based on a specific criterion. For example, a test criterion might only require testing certain transitions in a finite state machine, and not all of them. \n\n- **Functional testing:** A testing strategy that focuses on verifying that a software system meets its specified requirements. Functional tests are typically designed based on the system's specification and are not concerned with the system's internal implementation.\n\n- **Generator:** A tool or human that automatically generates test values or test cases to satisfy a selection criterion. Generators are used in functional testing to ensure that all possible functions are covered.\n\n- **Recognizer:** A tool or human that automatically decides whether a set of values satisfies a specific criterion. Recognizers are used in coverage testing to assess the coverage of a test suite.\n\n- **Selection criterion:** A test criterion that specifies a set of requirements or objectives that must be satisfied in order to generate test values or test cases. Selection criteria are used in functional testing to ensure that a test suite covers all necessary functions.\n\n- **Structural testing:** A testing strategy that focuses on verifying that a software system's implementation is correct. Structural tests are typically designed based on the system's code and are concerned with the flow of control and data through the system.\n\n- **Subsumes:** A relationship between two criteria for the same model where one criterion is more demanding than the other. For example, the all-paths criterion subsumes the all-transitions criterion because any test suite that satisfies the all-paths criterion will also satisfy the all-transitions criterion.\n\n- **Test model:** A representation of a software system used to guide the design of test cases. Test models can be abstract (e.g., a finite state machine) or concrete (e.g., a control flow graph).\n\n- **Test objectives:** The specific goals or requirements that a test suite should achieve. Test objectives are derived from the system's specification or the test model.\n\n- **Test suite:** A collection of test cases that are designed to test a software system. Test suites are typically organized into different categories based on the test objectives or the testing strategy. \n"
}