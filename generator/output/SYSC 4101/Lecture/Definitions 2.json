{
    "metadata": {
        "overview": "This lecture focuses on the concept of test criteria in software testing, exploring how to select and use them effectively to ensure adequate test coverage. It delves into the distinction between functional and structural testing, emphasizing the importance of selecting appropriate criteria based on the specific testing objectives.",
        "topics": [
            "Exhaustive Testing",
            "Test Data: procedure to select?",
            "Functional vs. Structural Testing",
            "Test Model Criterion",
            "Theoretical Hierarchy of criteria",
            "Two ways to use Test Criteria",
            "Miss-use of terminology",
            "Using a Test Selection Criterion",
            "Test Criteria Based on Structure [Offutt]",
            "Test Criteria-Graphs",
            "Test Criteria-Logic Expressions",
            "Test Criteria-Input Domain Characterization",
            "Test Criteria-Syntactic Structure"
        ],
        "format": "Lecture",
        "date": "2024-09-17T00:00:00",
        "course": "SYSC 4101",
        "title": "Definitions 2",
        "path": "input/SYSC4101-5105_Definitions_PII.pdf"
    },
    "notes": "## SYSC4101 / SYSC5105: Definitions - Part II\n\n### Exhaustive Testing\n\n* **Exhaustive testing** is testing using all possible inputs.\n* **Most of the time, this is impossible!**\n\n**Examples:**\n\n* **A program that computes the factorial function:**\n    * Exhaustive testing would involve running the program with all possible integer values (0, 1, 2, ..., 100, ...).\n* **A compiler (e.g., javac):**\n    * Exhaustive testing would involve compiling every possible Java program.\n\n**Techniques to Reduce the Number of Inputs:**\n\n* **Testing criteria** group input elements into equivalence classes.\n* **One input is selected from each class** to ensure test data adequacy.\n* **Criteria are used to decide which test inputs to use.**\n* **Criteria are used to decide when to stop testing.**\n\n### Test Data: Procedure to Select?\n\n* **Test data selection depends on the test model:**\n    * The test model can represent the specification (**functional testing**) or the implementation (**structural testing**).\n* **Test objectives (requirements) define the criteria for selecting test data.**\n* **Test cases must exercise all elements in the test model.**\n\n**Older Terminology:**\n\n* **Black-box testing:** Functional testing.\n* **White-box testing:** Structural testing.\n\n### Functional vs. Structural Testing\n\n**Functional Testing:**\n\n* **Checks conformance with the specification.**\n* **Scales up to different levels of granularity:**\n    * Works for functions, classes, packages/components, and systems.\n* **Depends on the specification and the degree of detail.**\n* **Does not reveal how much of the system (code) is being tested.**\n    * What if the system performs unexpected or undesirable tasks?\n\n**Structural Testing:**\n\n* **Based on control and data flow criteria.**\n* **Provides confidence about how much of the system is being tested.**\n* **Does not scale up well.**\n    * Mostly applicable at unit and integration testing levels.\n    * Does not work for packages/components or systems.\n* **Cannot reveal missing functionalities.**\n    * What if part of the specification is not implemented?\n\n**Diagram:**\n\n* The system is represented by a box.\n* The specification is represented by a striped box within the system box.\n* The implementation is represented by a dotted box within the system box.\n* **Missing functionality** cannot be revealed by white-box testing.\n* **Unexpected functionality** cannot be revealed by black-box testing.\n\n### Test Model Criterion\n\n* **Given a criterion C for a model M:**\n    * The **coverage ratio** of a test set T is the proportion of elements in M defined by C that are covered by T.\n    * A test set T is **C-adequate** when the coverage ratio achieves 100% for criterion C.\n\n**Example 1:**\n\n* **Model M:** Control flow graph of a function.\n* **Criterion C:** \"All the statements.\"\n* **Test suite:** Exercises 5 out of 8 statements (62.5% coverage).\n* **Conclusion:** The test suite is not adequate for the all-statements criterion.\n\n**Example 2:**\n\n* **Model M:** Set of use case scenarios.\n* **Criterion C:** \"All the scenarios.\"\n* **Test suite:** Exercises 12 out of 12 scenarios (100% coverage).\n* **Conclusion:** The test suite is adequate for the all-scenarios criterion.\n\n* **A test criterion specifies a set of test requirements/objectives.**\n* **Test requirements must be satisfied to obtain an adequate test suite.**\n\n**Issue:**\n\n* **Not all test requirements are feasible when applying a criterion to a test model.**\n\n**Revised Notion of Adequacy:**\n\n* The **coverage ratio** of a test set T is the proportion of **feasible** elements in M defined by C that are covered by T.\n* A test set T is **C-adequate** when the coverage ratio achieves 100% for criterion C.\n\n### Theoretical Hierarchy of Criteria\n\n* **Subsumption relation:** C1 **subsumes** C2 if any C1-adequate test set is also C2-adequate.\n* **Beware:** This is not a subset relation! The set of model elements to be exercised to satisfy C2 is not a subset of the set of model elements to be exercised to satisfy C1.\n\n**Example:**\n\n* **Model M:** Finite state machines.\n* **Criterion C1:** All-paths.\n* **Criterion C2:** All-transitions.\n* **Conclusion:** All-paths subsumes all-transitions. Any all-paths adequate test suite necessarily exercises all the transitions.\n\n**Usually (but not always), if C1 subsumes C2:**\n\n* **Satisfying C1 tends to be more expensive than satisfying C2.** (e.g., C1 tends to require more test cases than C2).\n* **A C1-adequate test suite tends to detect more faults than a C2-adequate test suite.**\n\n### Two Ways to Use Test Criteria\n\n* **Generate test values/test cases to satisfy the criterion.**\n    * **Criterion = selection criterion.**\n    * **Need a tool (or human), a generator, that automatically generates values to satisfy the criterion.**\n    * **Wish:** Create a (software) generator?\n\n* **Evaluate coverage achieved by externally generated test values/test cases.**\n    * **Criterion = coverage criterion.**\n    * **Need a tool (or human), a recognizer, that automatically decides whether a set of values satisfies a criterion.**\n    * **Wish:** Create a (software) recognizer?\n\n**Problems:**\n\n* **How to create a generator?**\n* **How to create a recognizer?**\n\n**Issue:**\n\n* **Both problems are provably undecidable for most criteria.**\n    * It is not possible to construct a single algorithm that will always, in every situation, find a correct solution.\n* **However, it is often easier to build a recognizer than a generator.**\n    * Coverage analysis tools (recognizers) are quite plentiful.\n\n### Miss-Use of Terminology\n\n* **Beware of miss-use of the term \"coverage.\"**\n* **Your colleague says:**\n    * \"I am checking what my tests exercise with the all-statements selection criterion.\"\n        * **Wrong:** They are using the all-statements criterion in a recognizer context (coverage criterion).\n    * \"I am creating tests with the all-scenarios coverage criterion.\"\n        * **Wrong:** They are using the all-scenarios criterion in a generator context (selection criterion).\n    * \"I am doing structural testing since I check my tests execute all statements.\"\n        * **Wrong:** With structural testing, one uses a selection criterion that applies on a model of the implementation (generator context). Here, they are using the criterion in a recognizer context.\n    * \"My tests achieve 100% coverage.\"\n        * **What criterion?** Different criteria may have extremely different costs!\n\n### Using a Test Selection Criterion\n\n**Steps:**\n\n1. **Choose a test model.**\n2. **Select a test criterion.**\n3. **Identify test objectives.**\n4. **Create test case specifications.**\n5. **Identify test data/input.**\n6. **Identify Oracle.**\n\n**Example:**\n\n1. **Test model:** State machine.\n2. **Test criterion:** All-transitions.\n3. **Test objectives:**\n    * Got0 -> Got5\n    * Got10 -> Got0\n    * Got5 -> Got0\n    * Got10 -> Got5\n    * Got0 -> Got10\n    * Got5 -> Got10\n4. **Test case specifications:**\n    * TCS1 = [Got0, Got5, Got10]\n    * TCS2 = [Got0, Got10, Got0]\n    * TCS3 = [Got0, Got10, Got5, Got0]\n5. **Test data:**\n    * TC1 = [5p, 5p]\n    * TC2 = [10p, 5p]\n    * TC3 = [10p, 10p, 10p]\n6. **Oracles:**\n    * TC1 = machine has 10p in, no can\n    * TC2 = machine has 0p in, one can\n    * TC3 = machine has 0p in, two cans\n\n### Example (Graph) Model\n\n* **Specification:** A vending machine that gets 5p or 10p of money and sells 15p cans.\n* **Test model:** A graph representing the state transitions of the vending machine.\n* **Test criterion:** All-transitions.\n* **Test objectives:** All possible state transitions.\n* **Test case specifications:** Sets of transitions to be exercised.\n* **Test data:** Input values (5p or 10p) for each transition.\n* **Oracles:** Expected state after each transition.\n\n### Marick's Recommendation\n\n**Brian Marick recommends the following approach:**\n\n1. **Generate functional tests from requirements and design to try every function.**\n    * **Use a functional selection criterion (generator).**\n2. **Check the structural coverage after the functional tests are all verified to be successful.**\n    * **Use a structural coverage criterion (recognizer).**\n3. **Where the structural coverage is imperfect, generate functional tests (not structural) that induce the additional coverage.**\n\n**This works because form (structure) should follow function!**\n\n* **Uncovered code must have some purpose, and that purpose has not been invoked, so some function is untested.**\n\n### Test Criteria Based on Structure (Offutt)\n\n* **Graphs:**\n    * Method body\n    * Methods and calls\n    * Components interactions\n    * State and transitions\n* **Logical Expressions:**\n    * Can appear in state machines, source code, and software specifications.\n    * Examples: (not X or not Y) and A and B\n* **Input Domain Characterization:**\n    * Describes the input domain of the software under test (method, component, system).\n    * Examples:\n        * A: {0, 1, >1}\n        * B: {600, 700, 800}\n        * C: {swe, cs, isa, infs}\n* **Syntactic Structures:**\n    * Based on a grammar or other syntactic definition.\n    * Example: Mutation testing\n\n### Test Criteria - Graphs\n\n* **Example:** Control flow graph of a function.\n* **Criterion:** All-transitions.\n* **Test data:** Input values that trigger each transition.\n* **Oracles:** Expected state after each transition.\n\n### Test Criteria - Logic Expressions\n\n* **Example:** A logical expression representing a condition in a program.\n* **Criterion:** All possible combinations of truth values for the variables in the expression.\n* **Test data:** Input values that result in each combination of truth values.\n* **Oracles:** Expected output of the expression for each combination of truth values.\n\n### Test Criteria - Input Domain Characterization\n\n* **Example:** A program that reads input files and searches for lines matching a regular expression.\n* **Criterion:** All possible input files and regular expressions.\n* **Test data:** Input files and regular expressions that cover the entire input domain.\n* **Oracles:** Expected output of the program for each input file and regular expression.\n\n### Test Criteria - Syntactic Structures\n\n* **Example:** A program with a specific syntax.\n* **Criterion:** All possible syntactic structures.\n* **Test data:** Input values that result in each syntactic structure.\n* **Oracles:** Expected output of the program for each syntactic structure.\n\n**Note:** These are just examples of test criteria. There are many other criteria that can be used, depending on the specific software being tested.",
    "review": [
        {
            "answer": "Exhaustive testing is a testing technique that aims to cover all possible inputs to a program. However, it is often impossible to achieve due to the vast number of potential inputs, especially for complex programs.",
            "question": "What is exhaustive testing, and why is it often impractical?"
        },
        {
            "answer": "Equivalence classes are groups of inputs that are expected to produce similar outcomes. By selecting one representative input from each class, we can reduce the number of test cases while still achieving a good level of test coverage.",
            "question": "Explain the concept of equivalence classes in testing."
        },
        {
            "answer": "Functional testing focuses on verifying that the software meets its specified requirements, without considering the internal implementation details. Structural testing, on the other hand, examines the internal structure of the code to ensure that all components are adequately tested.",
            "question": "What are the key differences between functional testing and structural testing?"
        },
        {
            "answer": "A test model criterion defines a set of requirements or objectives that must be met for a test suite to be considered adequate. It helps to ensure that the test suite covers all critical aspects of the software.",
            "question": "What is the purpose of a test model criterion?"
        },
        {
            "answer": "The subsumption relation between test criteria indicates that if a test suite satisfies a more comprehensive criterion (C1), it automatically satisfies a less comprehensive criterion (C2). This means that C1 subsumes C2.",
            "question": "Describe the subsumption relation between test criteria, and provide an example."
        },
        {
            "answer": "A test generator is a tool or process that automatically creates test cases based on a given criterion. A test recognizer, on the other hand, determines whether a set of test cases satisfies a specific criterion.",
            "question": "Explain the roles of a test generator and a test recognizer in the context of test criteria."
        },
        {
            "answer": "Marick's recommendation emphasizes a two-step approach: first, generate functional tests to cover all functionalities, and then use structural coverage criteria to ensure that the internal code is adequately tested. This approach prioritizes functionality and uses structural testing to identify any potential gaps in coverage.",
            "question": "Summarize Brian Marick's recommendation for using test criteria."
        }
    ],
    "keywords": [
        {
            "definition": "A technique used to reduce the number of inputs (i.e., test cases) by grouping input elements into equivalence classes, selecting one input from each class, and using criteria to determine which test inputs to use and when to stop testing.",
            "term": "Equivalence Class Testing"
        },
        {
            "definition": "A type of testing that focuses on verifying the functionality of a system based on its specification.",
            "term": "Functional Testing"
        },
        {
            "definition": "A type of testing that focuses on verifying the internal structure of a system, such as its code or control flow.",
            "term": "Structural Testing"
        },
        {
            "definition": "A test criterion that specifies a set of test requirements or objectives that must be satisfied to obtain an adequate test suite.",
            "term": "Test Criterion"
        },
        {
            "definition": "The proportion of elements in a model defined by a criterion that are covered by a test set.",
            "term": "Coverage Ratio"
        },
        {
            "definition": "A test set that achieves 100% coverage for a given criterion.",
            "term": "C-Adequate"
        },
        {
            "definition": "A test criterion that is used to generate test values or test cases to satisfy a specific requirement.",
            "term": "Selection Criterion"
        },
        {
            "definition": "A test criterion that is used to evaluate the coverage achieved by externally generated test values or test cases.",
            "term": "Coverage Criterion"
        },
        {
            "definition": "A tool that automatically generates test values or test cases to satisfy a specific criterion.",
            "term": "Generator"
        },
        {
            "definition": "A tool that automatically decides whether a set of values satisfies a specific criterion.",
            "term": "Recognizer"
        },
        {
            "definition": "A relationship between two criteria for the same model where any test set that is adequate for the first criterion is also adequate for the second criterion.",
            "term": "Subsumption"
        },
        {
            "definition": "A type of test criterion that focuses on the structure of a system, such as its control flow graph or state machine.",
            "term": "Structural Test Criterion"
        },
        {
            "definition": "A type of test criterion that focuses on the input domain of a system, such as the range of values that can be accepted by a function or method.",
            "term": "Input Domain Characterization"
        },
        {
            "definition": "A type of test criterion that focuses on the syntactic structure of a system, such as its code or grammar.",
            "term": "Syntactic Structures"
        },
        {
            "definition": "A type of testing that involves creating a model of the system under test and then using that model to generate test cases.",
            "term": "Model-Based Testing"
        }
    ],
    "practice": {
        "long": [
            {
                "answer": "Functional testing focuses on verifying that the software meets its specified requirements, while structural testing examines the internal structure of the code to ensure it is implemented correctly and efficiently. Functional testing is typically performed from a black-box perspective, where the tester does not have access to the source code, while structural testing is performed from a white-box perspective, where the tester has access to the source code. Both types of testing are essential for ensuring the quality of software, but they focus on different aspects of the system.",
                "question": "Explain the difference between functional and structural testing, highlighting their respective perspectives and goals."
            },
            {
                "answer": "Test criteria are essential for defining the scope and objectives of testing. They provide a set of rules or guidelines that determine which aspects of the software should be tested and how thoroughly. By using test criteria, testers can ensure that their tests are comprehensive and effective in identifying defects. Some common test criteria include statement coverage, branch coverage, and path coverage, which aim to ensure that all parts of the code are executed at least once.",
                "question": "What are test criteria and why are they important in software testing?"
            }
        ],
        "multiple": [
            {
                "answer": "d",
                "explanation": "The all-paths criterion is the most comprehensive, as it requires testing all possible execution paths through the software. This can be very time-consuming and expensive, but it provides the highest level of assurance that all parts of the code have been tested.",
                "options": [
                    "a",
                    "b",
                    "c",
                    "d"
                ],
                "question": "Which of the following test criteria is the most comprehensive and demanding in terms of test effort? \n a) Statement coverage \n b) Branch coverage \n c) Condition coverage \n d) All-paths coverage"
            },
            {
                "answer": "c",
                "explanation": "A test suite that achieves 100% statement coverage ensures that every line of code is executed at least once. However, it does not guarantee that all possible branches or conditions within the code have been tested.",
                "options": [
                    "a",
                    "b",
                    "c",
                    "d"
                ],
                "question": "Which of the following statements is TRUE about 100% statement coverage? \n a) It guarantees that all possible execution paths have been tested. \n b) It is the most comprehensive test criterion. \n c) It ensures that every line of code is executed at least once. \n d) It is always the most efficient way to test software."
            },
            {
                "answer": "b",
                "explanation": "A test generator is a tool that automatically creates test cases based on a given test criterion. It helps testers to generate a large number of test cases efficiently, which can be particularly useful for complex systems.",
                "options": [
                    "a",
                    "b",
                    "c",
                    "d"
                ],
                "question": "What is the purpose of a test generator? \n a) To evaluate the coverage achieved by externally generated test values. \n b) To automatically create test cases based on a given test criterion. \n c) To identify potential defects in the software. \n d) To analyze the results of test execution."
            },
            {
                "answer": "a",
                "explanation": "The all-transitions criterion requires testing all possible transitions between states in a state machine. This ensures that all possible state changes are covered by the test suite.",
                "options": [
                    "a",
                    "b",
                    "c",
                    "d"
                ],
                "question": "Which of the following test criteria is specifically designed for testing state machines? \n a) All-transitions \n b) All-paths \n c) Statement coverage \n d) Branch coverage"
            },
            {
                "answer": "d",
                "explanation": "Structural testing is based on the internal structure of the code, while functional testing focuses on verifying the behavior of the software against its specifications. Therefore, structural testing is more likely to reveal defects related to the implementation of the code, such as logic errors or incorrect data flow.",
                "options": [
                    "a",
                    "b",
                    "c",
                    "d"
                ],
                "question": "Which type of testing is more likely to uncover defects related to the internal structure of the code? \n a) Functional testing \n b) Black-box testing \n c) Regression testing \n d) Structural testing"
            }
        ],
        "short": [
            {
                "answer": "Exhaustive testing aims to test all possible inputs to a system, but it is often impractical or impossible due to the vast number of potential inputs. Test criteria help to reduce the number of test cases by grouping inputs into equivalence classes, selecting representative inputs from each class, and defining rules for stopping testing when sufficient coverage is achieved.",
                "question": "Explain the concept of exhaustive testing and how test criteria help to address its limitations."
            },
            {
                "answer": "A test oracle is a mechanism used to determine whether a test case has passed or failed. It can be a human expert, a specification document, or a separate program that compares the actual output of the system to the expected output. The oracle plays a crucial role in evaluating the effectiveness of test cases and identifying defects.",
                "question": "What is a test oracle and what is its role in software testing?"
            },
            {
                "answer": "The subsumption relation between test criteria indicates that one criterion is more comprehensive than another. If a test suite satisfies a more comprehensive criterion, it automatically satisfies the less comprehensive criterion. For example, the all-paths criterion subsumes the all-transitions criterion because any test suite that covers all possible paths in a state machine will also cover all possible transitions.",
                "question": "Explain the concept of subsumption relation between test criteria and provide an example."
            }
        ]
    }
}